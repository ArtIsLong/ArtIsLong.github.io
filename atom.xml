<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ArtIsLong的博客]]></title>
  <subtitle><![CDATA[好的程序猿都是野路子]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-07-11T13:28:20.000Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[ArtIsLong的博客]]></name>
    <email><![CDATA[799418876@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <link href="/2017/06/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2017/06/16/Docker学习笔记/</id>
    <published>2017-06-16T11:24:41.000Z</published>
    <updated>2017-07-11T13:28:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><blockquote>
<p>Docker简介</p>
</blockquote>
<p>Docker 是一个开源的应用容器引擎，基于 <a href="http://www.runoob.com/go/go-tutorial.html" target="_blank" rel="external">Go 语言</a> 并遵从Apache2.0协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。<br><a id="more"></a></p>
<blockquote>
<p>Docker的应用场景</p>
</blockquote>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境</li>
</ul>
<blockquote>
<p>Docker的优点</p>
</blockquote>
<ul>
<li>简化程序</li>
</ul>
<p>Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。过去需要数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。</p>
<ul>
<li>避免选择恐惧症</li>
</ul>
<p>Docker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个镜像部署。</p>
<ul>
<li>节省开支</li>
</ul>
<p>云计算时代的到来，使开发者不必为了追求效果而配置高额的硬件，Docker改变了高性能必然高价格的思维定势。Docker与云的结合，让云空间得到更充分的利用，不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
<blockquote>
<p>Centos的Docker安装与启动</p>
</blockquote>
<ul>
<li>检查Linux版本</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>uname -r</div></pre></td></tr></table></figure>
<p>Docker要求Centos系统的内核版本高于3.10</p>
<ul>
<li>安装Docker</li>
</ul>
<p>切换到root用户，更新系统</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum update</span></div></pre></td></tr></table></figure>
<p>安装Docker</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum -y install docker</span></div></pre></td></tr></table></figure>
<p>Docker软件包和依赖包已经包含在默认的Centos-Extras软件源里了。</p>
<p>如果这种方式不能安装，也可使用下面的命令进行安装</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# curl -fsSL http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></div></pre></td></tr></table></figure>
<p>执行这个脚本后会添加docker.repo源并安装Docker</p>
<p>注：若安装失败，重新使用上面命令安装时有时会报错，只需要去家目录下的.docker目录中将docker的相关文件删除，然后重新执行命令下载即可。</p>
<ul>
<li>启动Docker服务</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># service docker start</span></div></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> hello-world</div></pre></td></tr></table></figure>
<p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器中运行</p>
<blockquote>
<p>Docker的基本使用</p>
</blockquote>
<ul>
<li>查看Docker常用命令</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker --help</div></pre></td></tr></table></figure>
<p>如我们需要查看其中某个命令的使用方法，可使用以下命令</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker <span class="built_in">run</span> <span class="comment">--help</span></div></pre></td></tr></table></figure>
<ul>
<li>运行一个web应用</li>
</ul>
<p>我们在Docker容器中运行一个Python Flask应用来运行一个web应用</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> <span class="_">-d</span> -P training/webapp python app.py</span></div></pre></td></tr></table></figure>
<p>我们先来看看之前执行docker run –help命令后的结果吧</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run <span class="string">[OPTIONS]</span> IMAGE <span class="string">[COMMAND]</span> <span class="string">[ARG...]</span></div></pre></td></tr></table></figure>
<p>OPTIONS: 代表run命令的一些参数</p>
<p>IMAGE: 镜像名</p>
<p>COMMAND: 运行镜像之后要执行的命令</p>
<p>ARG…: 命令需要的一些参数</p>
<p>好了，我们现在来看看刚刚我们运行一个web应用的命令</p>
<p>-d, –detach=false          Run container in background and print container ID</p>
<p>让容器在后台运行，默认是关闭的</p>
<p>-P, –publish-all=false     Publish all exposed ports to random ports</p>
<p>让容器内部使用的网络端口映射到我们使用的主机上，默认是关闭的</p>
<p>注意: 我们这里用的是大写的-P</p>
<p>小写的-p手动将容器端口映射到宿主机上的端口，如</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> <span class="_">-d</span> -p 5000:5000 training/webapp python app.py</span></div></pre></td></tr></table></figure>
<ul>
<li><p>查看WEB应用容器</p>
<ul>
<li><p>查看正在运行的容器</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</div><div class="line">f5d5071807a8        training/webapp     <span class="string">"python app.py"</span>     <span class="number">13</span> seconds ago      Up <span class="number">12</span> seconds       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp   prickly_davinci</div></pre></td></tr></table></figure>
<p>结果中有容器ID，镜像名，端口，容器名等信息，其中端口显示了prickly_davinci容器端口的映射情况，此时映射的端口是容器自动做的映射，如果我们运行时没使用-P，而是使用-p手动映射，此处则显示手动指定的端口。其次容器名称此处为容器自动指定的，我们可以通过–name来手动指定，如</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> <span class="_">-d</span> -p 5000:5000 --name webapp training/webapp python app.py</span></div></pre></td></tr></table></figure>
<p>上面默认都是绑定tcp端口，如果要绑定UDP端口，可以在端口后面加上/udp</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> <span class="_">-d</span> -p 5000:5000/udp --name webapp training/webapp python app.py</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>查看容器端口映射</p>
<ul>
<li>使用容器ID查看容器端口映射情况</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker port f5d5071807a8</div><div class="line"><span class="number">5000</span>/tcp -&gt; <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">32768</span></div></pre></td></tr></table></figure>
<ul>
<li>使用容器名称查看端口映射情况</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker port prickly_davinci</div><div class="line"><span class="number">5000</span>/tcp -&gt; <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">32768</span></div></pre></td></tr></table></figure>
<ul>
<li>查看具体某个端口的映射情况</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">[docker@localhost docker]</span>$ docker port tomcat <span class="number">8080</span></div><div class="line"><span class="number">0.0.0.0:8080</span></div></pre></td></tr></table></figure>
<p><strong>接下来凡是使用容器标识操作的都使用容器名称，并且容器ID也支持相同的命令操</strong></p>
</li>
<li><p>查看WEB应用程序日志</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker logs -f modest_banach</div></pre></td></tr></table></figure>
<p>-f: 让docker logs像使用tail -f一样来输出容器内部的标准输出</p>
</li>
<li><p>查看WEB应用程序容器的进程</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker top modest_banach</div></pre></td></tr></table></figure>
</li>
<li><p>检查WEB应用程序</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker inspect modest_banach</div></pre></td></tr></table></figure>
</li>
<li><p>停止WEB应用程序</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker stop modest_banach</div></pre></td></tr></table></figure>
</li>
<li><p>启动WEB应用容器</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker start modest_banach</div></pre></td></tr></table></figure>
</li>
<li><p>重启WEB应用容器</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker restart modest_banach</div></pre></td></tr></table></figure>
<p><strong>注</strong>：正在运行的容器我们可以使用restart来重启</p>
</li>
<li><p>移除WEB应用容器</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker rm modest_banach</div></pre></td></tr></table></figure>
<p><strong>注：</strong>移除容器时，容器必须是停止状态。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Docker镜像的使用</p>
</blockquote>
<ul>
<li><p>查看本地镜像列表</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker images</div><div class="line">REPOSITORY          <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             VIRTUAL SIZE</div></pre></td></tr></table></figure>
<p>各个选项说明：</p>
<ul>
<li>REPOSITORY: 表示镜像的仓库源</li>
<li>TAG: 镜像的标签</li>
<li>IMAGE ID: 镜像ID</li>
<li>CREATED: 镜像创建时间</li>
<li>SIZE: 镜像大小</li>
</ul>
<p>同一个仓库源可以有多个TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10,14.04等多个不同的版本，我们可以使用REPOSITORY:TAG来定义不同的镜像，如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="meta">@localhost</span> ~]$ docker run -t -i <span class="string">ubuntu:</span><span class="number">15.10</span> <span class="regexp">/bin/</span>bash</div></pre></td></tr></table></figure>
<p>如果不指定镜像的版本标签，docker将默认使用latest镜像</p>
</li>
<li><p>获取一个新的镜像</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull <span class="symbol">ubuntu:</span><span class="number">15.10</span></div></pre></td></tr></table></figure>
</li>
<li><p>查找镜像</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker search httpd</div><div class="line">NAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</div></pre></td></tr></table></figure>
<p>NAME: 镜像仓库源的名称</p>
<p>DESCRIPTION: 镜像的描述</p>
<p>OFFICIAL: 是否是docker官方发布</p>
</li>
<li><p>拖取镜像</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull httpd</div></pre></td></tr></table></figure>
</li>
<li><p>运行镜像</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> httpd</div></pre></td></tr></table></figure>
</li>
<li><p>自定义镜像</p>
<ul>
<li><p>创建镜像</p>
<p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：</p>
<p>1、从已经创建的容器中更新镜像，并且提交这个镜像</p>
<p>2、使用Dockerfile指令来创建一个新的镜像</p>
</li>
<li><p>更新镜像</p>
<p>在更新镜像之前，我们先用以下命令启动容器，在容器中使用apt-get update命令更新，完成操作后使用exit退出容器。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker run -t -i <span class="symbol">ubuntu:</span><span class="number">15.10</span> /bin/bash</div><div class="line">root<span class="variable">@2d60a31b8bdf</span><span class="symbol">:/</span><span class="comment"># apt-get update</span></div></pre></td></tr></table></figure>
</li>
<li><p>提交容器副本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[docker@localhost ~]$ docker commit -m=<span class="string">"has update"</span> <span class="_">-a</span>=<span class="string">"ubuntu/update"</span> 2d60a31b8bdf ubuntu:v2</div><div class="line">ea547a1aa6de52e24092ff3ca13ae7ae58<span class="built_in">cd</span>35123e2e58e6f3d784208af7ef5e</div></pre></td></tr></table></figure>
<p>-m: 提交的描述信息</p>
<p>-a: 指定镜像作者</p>
<p>2d60a31b8bdf: 容器ID</p>
<p>runoob/ubuntu:v2: 指定要创建的目标镜像名</p>
</li>
<li><p>构建镜像</p>
<p>创建Dockerfile，使用docker build命令来创建一个新的镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[docker@localhost docker]$ cat Dockerfile</div><div class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></div><div class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">"artislong@haha.com"</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span></div><div class="line"><span class="keyword">RUN</span><span class="bash">     useradd docker</span></div><div class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">'docker:123456'</span> |chpasswd</span></div><div class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"LANG=\"en_US.UTF-8\""</span> &gt;/etc/default/<span class="built_in">local</span></span></div><div class="line"><span class="keyword">EXPOSE</span>  <span class="number">22</span></div><div class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></div><div class="line"><span class="keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></div></pre></td></tr></table></figure>
<p>Dockerfile是一个文本格式的配置文件，它由一行行命令语句（指令）组成，并且支持以#开头的注释行</p>
<p>每个指令都会在镜像上创建一个新的层，每个指令的前缀都必须大写。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN指令告诉docker在镜像内执行命令，安装了什么。。。</p>
<p>然后我们通过Dockerfile文件来构建一个镜像</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> docker]<span class="variable">$ </span>docker build -t runoob/<span class="symbol">centos:</span><span class="number">6.7</span> .</div></pre></td></tr></table></figure>
<p>千万不要忽略最后面的 “.”，它表示使用当前目录下的Dockerfile文件</p>
<p>-t: 指定要创建的目标镜像名</p>
<p>​</p>
<p>我们可以使用新的镜像来创建容器</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="name">docker@localhost</span> docker]$ docker run -t -i runoob/centos:6.7 /bin/bash</div><div class="line">[<span class="name">root@ebd742bf9af0</span> /]# id docker</div><div class="line">uid=500(<span class="name">docker</span>) gid=500(<span class="name">docker</span>) groups=500(<span class="name">docker</span>)</div></pre></td></tr></table></figure>
<p>从上面看到新镜像已经包含了我们创建的用户docker</p>
</li>
<li><p>设置镜像标签</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost docker]$ docker <span class="keyword">tag</span> <span class="title">f38a8f197ee4</span> runoob/centos:dev</div></pre></td></tr></table></figure>
<p>docker tag 镜像ID，镜像源名和新的标签名</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Docker安装Nginx</p>
</blockquote>
<ul>
<li>创建Nginx目录，用于存放后面相关文件</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>mkdir -p ~<span class="regexp">/nginx/www</span> ~<span class="regexp">/nginx/logs</span> ~<span class="regexp">/nginx/conf</span></div></pre></td></tr></table></figure>
<p>www目录将映射为nginx容器配置的虚拟目录</p>
<p>logs目录将映射为nginx容器的日志目录</p>
<p>conf目录里的配置文件将映射为nginx容器的配置文件</p>
<ul>
<li>查找Docker Hub上的nginx镜像</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker search nginx</div></pre></td></tr></table></figure>
<ul>
<li>拉取官方nginx镜像</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker pull nginx</div></pre></td></tr></table></figure>
<ul>
<li>查看nginx本地镜像</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker images nginx</div></pre></td></tr></table></figure>
<ul>
<li><p>使用nginx镜像</p>
<ul>
<li>运行容器</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost nginx]$ docker run -<span class="selector-tag">i</span> -t -d -<span class="selector-tag">p</span> <span class="number">80</span>:<span class="number">8081</span> --name nginx -v <span class="variable">$PWD</span>/www:/www -v <span class="variable">$PWD</span>/conf/nginx<span class="selector-class">.conf</span>:/etc/nginx/nginx<span class="selector-class">.conf</span> -v <span class="variable">$PWD</span>/logs:/wwwlogs  -d nginx</div></pre></td></tr></table></figure>
<p>-p 80:8081: 将容器的80端口映射到宿主机的8081端口</p>
<p>-name nginx: 将容器命名为nginx</p>
<p>-v $PWD/www:/www: 将主机中当前目录下的www目录挂载到容器的/www</p>
<p>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf: 将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</p>
<p>-v $PWD/logs:/wwwlogs: 将主机中当前目录下的logs挂载到容器的/wwwlogs</p>
</li>
<li><p>查看容器启动情况</p>
</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker ps</div></pre></td></tr></table></figure>
<ul>
<li>通过浏览器访问</li>
</ul>
<p>访问路径为: <a href="http://主机ip:8081/" target="_blank" rel="external">http://主机ip:8081/</a> ，就可访问nginx</p>
<blockquote>
<p>Docker安装Tomcat</p>
</blockquote>
<ul>
<li>创建tomcat的相关目录</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>mkdir -p ~<span class="regexp">/tomcat/webapps</span> ~<span class="regexp">/tomcat/logs</span> ~<span class="regexp">/tomcat/conf</span></div></pre></td></tr></table></figure>
<ul>
<li>查找Docker Hub上的tomcat镜像</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker search tomcat</div></pre></td></tr></table></figure>
<ul>
<li>拉取官方tomcat镜像</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull tomcat</div></pre></td></tr></table></figure>
<ul>
<li><p>创建测试文件</p>
<ul>
<li><p>在~/tomcat/webapps目录下创建test目录</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> webapps]<span class="variable">$ </span>mkdir test</div></pre></td></tr></table></figure>
</li>
<li><p>进入test目录，编写测试页面</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker<span class="variable">@localhost</span> test]<span class="variable">$ </span>vi index.html</div></pre></td></tr></table></figure>
<p>index.html文件内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>docker中的tomcat测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">                Hello, World! <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">                哈哈哈哈，运行成功啦啦啦啦啦</div><div class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>运行tomcat容器</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[docker@localhost tomcat]$ docker <span class="keyword">run</span><span class="bash"> --name tomcat -p 8080:8080 -v <span class="variable">$PWD</span>/webapps/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span> <span class="_">-d</span> tomcat</span></div></pre></td></tr></table></figure>
<p>命令说明：</p>
<p>-v $PWD/webapps/test:/usr/local/tomcat/webapps/test: 将主机中当前目录下的test挂载到容器的/test</p>
<p>启动成功后，在浏览器访问：<a href="http://主机ip:8080/test/index.html即可访问刚才编写的测试页面" target="_blank" rel="external">http://主机ip:8080/test/index.html即可访问刚才编写的测试页面</a></p>
</li>
</ul>
</li>
</ul>
<p>—————————————————————————分割线———————————————————————–</p>
<blockquote>
<p>Dockerfile学习</p>
</blockquote>
<p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。</p>
<ul>
<li><p>基本结构</p>
<p>Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。</p>
<p>一般Dockerfile文件分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></div><div class="line"><span class="comment"># VERSION 2 - EDITION 1</span></div><div class="line"><span class="comment"># Author:docker_user</span></div><div class="line"><span class="comment"># Command format: Instruction [arguments / command] ..</span></div><div class="line"><span class="comment"># 第一行必须制定基于的基础镜像</span></div><div class="line"><span class="keyword">FROM</span> ubuntu</div><div class="line"><span class="comment"># 维护者信息</span></div><div class="line"><span class="keyword">MAINTAINER</span> docker_user docker_user@email.com</div><div class="line"><span class="comment"># 镜像的操作指令</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"deb http://archive.ubuntu.com/ubuntu/ raring main universe"</span> &gt;&gt; /etc/apt/sources.list</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"\ndaemon off;"</span> &gt;&gt; /etc/nginx/nginx.conf</span></div><div class="line"><span class="comment"># 容器启动时执行指令</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span></div></pre></td></tr></table></figure>
<p>Dockerfile文件编写时，一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息</p>
<p>后面则是镜像操作指令，例如RUN指令，镜像增加新的一层，并提交。最后是CMD指令，来指定运行容器时的操作命令。</p>
<p>以下有两个摘自书上的Dockerfile例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ngnix</span></div><div class="line"><span class="comment"># </span></div><div class="line"><span class="comment"># VERSION 0.0.1</span></div><div class="line"><span class="keyword">FROM</span> ubuntu</div><div class="line"><span class="keyword">MAINTAINER</span> Victor Vieux &lt;victor@docker.com&gt;</div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></div></pre></td></tr></table></figure>
<p>此Dockerfile文件是在ubuntu父镜像基础上安装inotify-tools、nginx、apache2、openssh-server软件，从而创建一个新的Nginx镜像</p>
<p><strong>注</strong> ：inotify-tools是为linux下inotify文件监控工具提供的一套c的开发接口库函数，同时还提供了一系列的命令行工具，这些工具可以用来监控文件系统的事件。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Firefox over VNC</span></div><div class="line"><span class="comment"># </span></div><div class="line"><span class="comment"># VERSION 0.3</span></div><div class="line"><span class="keyword">FROM</span> ubuntu</div><div class="line"><span class="comment"># Install vnc, xvfb in order to reate a 'fake' display and firefox</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefox</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /.vnc</span></div><div class="line"><span class="comment"># Setup a password</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> xllvnc -storepasswd 1234 ~/.vnc/passwd</span></div><div class="line"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">'echo "firefox" &gt;&gt; /.bashrc'</span></span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">5900</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"xllvnc"</span>, <span class="string">"-forever"</span>, <span class="string">"-usepw"</span>, <span class="string">"-create"</span>]</span></div></pre></td></tr></table></figure>
<p>此Dockerfile基于ubuntu父镜像，安装filefox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox</p>
</li>
<li><p>指令</p>
<p>指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。</p>
<ul>
<li><p>FROM</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">FROM</span> &lt;image&gt; 或<span class="keyword">FROM</span>&lt;image&gt;:&lt;tag&gt;</div></pre></td></tr></table></figure>
<p>第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。</p>
</li>
<li><p>MAINTAINER</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">MAINTAINER</span> &lt;name&gt;, 指定维护者信息</div></pre></td></tr></table></figure>
</li>
<li><p>RUN</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt; 或 RUN [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></div></pre></td></tr></table></figure>
<p>RUN <command> 将在shell终端中运行命令，即 /bin/sh -c</p>
<p>RUN [“executable”, “param1”, “param2”]则使用exec执行。</p>
<p>指定使用其他终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”, “echo hello”]。</p>
<p>每条RUN指令将在当前镜像基础上执行指令命令，并提交为新的镜像。当命令较长时可以用 \ 来换行。</p>
</li>
<li><p>CMD</p>
<p>支持三种格式</p>
<ul>
<li><p>使用exec执行，推荐方式</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></div></pre></td></tr></table></figure>
</li>
<li><p>在/bin/sh中执行，提供给需要交互的应用</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></div></pre></td></tr></table></figure>
</li>
<li><p>提供给ENTRYPOINT的默认参数</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p>
</li>
<li><p>EXPOSE</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</div></pre></td></tr></table></figure>
<p>例如：EXPOSE 22 80 8443</p>
<p>就是告诉Docker服务器容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P或者-p来指定端口映射。</p>
</li>
<li><p>ENV</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</div></pre></td></tr></table></figure>
<p>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></div><div class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...</span></div><div class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</div></pre></td></tr></table></figure>
</li>
<li><p>ADD</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">ADD</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span></div></pre></td></tr></table></figure>
<p>该命令将复制指定的<src>到容器中的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</src></dest></src></p>
</li>
<li><p>COPY</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">COPY</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span></div></pre></td></tr></table></figure>
<p>复制本地主机的<src>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<dest>。目标路径不存在时，会自动创建。</dest></src></p>
<p>当使用本地目录为源目录时，推荐使用COPY</p>
</li>
<li><p>ENTRYPOINT</p>
<ul>
<li><p>使用exec执行，推荐方式</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></div></pre></td></tr></table></figure>
</li>
<li><p>在shell中执行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖</p>
<p>每个Dockerfile中只能有一个ENTRYPOINT，当制定多个ENTRYPOINT时，只有最后一个生效。</p>
</li>
<li><p>VOLUME</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></div></pre></td></tr></table></figure>
<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
</li>
<li><p>USER</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">USER</span> daemon</div></pre></td></tr></table></figure>
<p>指定运行容器时的用户名或UID，后续的RUN也会使用指定的用户。</p>
<p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span></div></pre></td></tr></table></figure>
<p>要临时获取管理员权限可以使用gosu，不推荐sudo</p>
</li>
<li><p>WORKDIR</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></div></pre></td></tr></table></figure>
<p>为后续RUN、CMD、ENTRYPOINT指令配置工作目录。</p>
<p>可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></div></pre></td></tr></table></figure>
<p>上面指令最终结果为：/a/b/c</p>
</li>
<li><p>ONBUILD</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为 <span class="keyword">ONBUILD</span> [INSTRUCTION]</div></pre></td></tr></table></figure>
<p>配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[...]</div><div class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></div><div class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></div><div class="line">[...]</div></pre></td></tr></table></figure>
<p>Dockerfile使用上面的内容创建了镜像image-A，如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在Dockerfile后面添加了两条指令，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> image-A</div><div class="line"><span class="comment"># Automatically run the following</span></div><div class="line"><span class="keyword">ADD</span><span class="bash"> . /app/src</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></div></pre></td></tr></table></figure>
<p>使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。</p>
</li>
</ul>
<p>​</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><blockquote>
<p>Docker简介</p>
</blockquote>
<p>Docker 是一个开源的应用容器引擎，基于 <a href="http://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从Apache2.0协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。<br>]]>
    
    </summary>
    
      <category term="Docker,Dockerfile" scheme="/tags/Docker-Dockerfile/"/>
    
      <category term="Docker" scheme="/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat源码分析笔记]]></title>
    <link href="/2017/06/12/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>/2017/06/12/Tomcat源码分析笔记/</id>
    <published>2017-06-12T15:48:32.000Z</published>
    <updated>2017-06-12T16:04:35.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    <![CDATA[Tomcat源码分析]]>
    
    </summary>
    
      <category term="Tomcat" scheme="/tags/Tomcat/"/>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nginx+Tomcat+Redis实现Session共享]]></title>
    <link href="/2017/06/07/session%E5%85%B1%E4%BA%AB/"/>
    <id>/2017/06/07/session共享/</id>
    <published>2017-06-07T06:43:12.000Z</published>
    <updated>2017-06-12T15:33:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Nginx-Tomcat-Redis实现Session共享"><a href="#Nginx-Tomcat-Redis实现Session共享" class="headerlink" title="Nginx+Tomcat+Redis实现Session共享"></a>Nginx+Tomcat+Redis实现Session共享</h2><p>之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。</p>
<p>经过百度，查资料，找到了几种解决session共享的方案。</p>
<ul>
<li><p>不适用session，换作cookie<a id="more"></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">能把session改成cookie，就能避开session的一些弊端，也有资料表明在集群系统中不能使用session。但是博主思考再三，公司项目的session中存储一些比较重要的信息，在以后的业务中也会使用session中的数据，所以直接使用cookie这种方案果断舍弃。</div></pre></td></tr></table></figure>
</li>
<li><p>应用服务器自行实现共享</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">让服务器自行实现session共享，就需要提供一个后端服务器都能访问的公共容器来存储session，比如redis或者memcache，当系统需要获取session时，直接从redis或memcache中获取即可。</div></pre></td></tr></table></figure>
<p>以上两种方式都与Nginx没多大关系了。下面说说使用nginx如何处理</p>
</li>
<li><p>ip_hash</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">之前的博客中对upstream的几种方式做了介绍，相信大家还记得ip_hash的介绍吧，每个请求按访问<span class="built_in">ip</span>的hash结果分配，这样每个访问固定访问一个后端服务器。</div><div class="line">这样一来这个<span class="built_in">ip</span>下的某个客户端和某个后端服务器就能建立稳固的session。这样每个客户端都只对应一个服务器，那就不存在需要共享session的需要了，不过只用<span class="built_in">ip</span>这个因子来分配后端，所以还是存在一些缺陷，不能在以下情况下使用：</div><div class="line"><span class="number">1</span>、nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx就得不到正确的<span class="built_in">ip</span>，也就不能根据<span class="built_in">ip</span>来分配后端了。比如squid(一个高性能的代理缓存服务器)作为最前端，那么nginx只能获取到squid所在服务器的<span class="built_in">ip</span>地址，这种分流方式肯定会混乱的。</div><div class="line"><span class="number">2</span>、nginx的后端还有其他方式的负载均衡。如果nginx后端又有其他的负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台服务器上。</div></pre></td></tr></table></figure>
</li>
<li><p>upstream_hash</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块大多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享；</div><div class="line">这种方式不是很理解，就不做累述了，以后再慢慢研究。读者可自行查找资料学习。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>来自于网络上的方案介绍完了，接下来说说博主项目中的实际操作。</p>
<p>博主最初的打算是使用redis来缓存系统数据，刚好也可以实现session共享。可惜，客户公司方面服务器资源不够，不让使用redis，上面第二种方案瞬间被阉割掉了，有点不爽。这里必须吐槽吐槽客户公司。</p>
<p>由于不让使用redis，所以只能使用第三种方式了，这里就不做太多的累述了，比较简单，配置nginx负载均衡的时候将upstream的方式配置为ip_hash即可，具体配置方式在上篇“Nginx负载均衡配置”中已有例子，可做参考。</p>
<p>简单的解释一下公司项目架构，公司项目采用前后台分离的架构，前端页面使用angularJS实现一种单页面应用，后台服务则使用SpringBoot为前端提供数据服务，后台开发者只需要关注后端逻辑，然后将前端需要的数据转为json传给前端，而不需要去考虑页面的跳转等，而前端人员也不需要关注后台逻辑，可以全身心的提供前端的用户体验度，最主要的是前后台分离后，系统开发职责划分的更加清晰。</p>
<p>关于前后台分离方案，这个<a href="http://web.jobbole.com/82637/" target="_blank" rel="external">博客</a>讲的比较好，读者可做参考。 </p>
<p>这样就完了？没有，这就完了这篇博客也太水了，虽然客户公司不让使用redis，但是博主还是自己抽时间使用nginx+tomcat+redis来自己实现session共享。</p>
<p>——————————————————————这是一个分隔线——————————————————————-</p>
<h4 id="1、软件准备"><a href="#1、软件准备" class="headerlink" title="1、软件准备"></a>1、软件准备</h4><p>因为是自己玩，所以直接在windows上开工了。</p>
<p>nginx-1.11.5，apache-tomcat-7.0.55，redis-2.6.12(windows版)</p>
<p>读者可从<a href="https://github.com/ArtIsLong/documentation/blob/master/resources/nginx_redis_tomcat.zip" target="_blank" rel="external">这里</a>下载。其中有三个jar包最为重要：</p>
<p>commons-pool-1.6.jar，jedis-2.1.0.jar，tomcat-redis-session-manager-tomcat7.jar，在软件包中的tomcat的lib目录下可找到。</p>
<h4 id="2、配置tomcat"><a href="#2、配置tomcat" class="headerlink" title="2、配置tomcat"></a>2、配置tomcat</h4><p>在tomcat中的context.xml文件中加入以下内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Valve</span>  <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionHandlerValve"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionManager"</span></span></div><div class="line">	<span class="attr">host</span>=<span class="string">"localhost"</span> </div><div class="line">	<span class="attr">port</span>=<span class="string">"6379"</span></div><div class="line">	<span class="attr">database</span>=<span class="string">"0"</span> </div><div class="line">	<span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span> /&gt;</div></pre></td></tr></table></figure>
<p>将配置好的tomcat三份，分别命名为apache-tomcat-7.0.55-1，apache-tomcat-7.0.55-2，apache-tomcat-7.0.55-3，然后去将每个tomcat的端口改掉，分别改为8081，8082，8083</p>
<h4 id="3、配置Nginx"><a href="#3、配置Nginx" class="headerlink" title="3、配置Nginx"></a>3、配置Nginx</h4><p>将三个tomcat服务器用nginx代理，</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span>  localhost   &#123;</div><div class="line">	<span class="attribute">server</span>   localhost:<span class="number">8081</span> weight=<span class="number">1</span>;  </div><div class="line">	<span class="attribute">server</span>   localhost:<span class="number">8082</span> weight=<span class="number">1</span>;  </div><div class="line">	<span class="attribute">server</span>   localhost:<span class="number">8083</span> weight=<span class="number">1</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4、测试页面"><a href="#4、测试页面" class="headerlink" title="4、测试页面"></a>4、测试页面</h4><p>在tomcat的webapp目录下新建test目录，在test中新建index.jsp，然后给三个tomcat都拷贝一份</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="zh-CN"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset="UTF-8"&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;%</div><div class="line">	out.println(request.getSession().getId());</div><div class="line">%&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>这可能是可与Hello，World媲美的页面了。</p>
<h4 id="5、启动测试"><a href="#5、启动测试" class="headerlink" title="5、启动测试"></a>5、启动测试</h4><p>先启动redis，在启动三个tomcat，最后再启动nginx，然后访问页面。</p>
<p>有两种访问方式：</p>
<ul>
<li>直接访问三个tomcat，【<a href="http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。" target="_blank" rel="external">http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。</a></li>
<li>多次访问nginx，【<a href="http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致" target="_blank" rel="external">http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致</a></li>
</ul>
<p>好了，这种session共享完成。不过还没完，刚开始介绍时说的那三个jar包还没说说呢，接下来通过tomcat-redis-session-manager-tomcat7.jar的源码来解释一下这种方式实现session共享的原理。</p>
<h4 id="6、Session共享原理分析"><a href="#6、Session共享原理分析" class="headerlink" title="6、Session共享原理分析"></a>6、Session共享原理分析</h4><p>在解释Session共享原理之前，我们先简单的看看Tomcat架构方面的一些知识作为铺垫。</p>
<pre><code>##### 6.1 Tomcat架构原理分析
</code></pre><p>正在深入剖析tomcat源码中，解读清楚了此部分补上</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Nginx-Tomcat-Redis实现Session共享"><a href="#Nginx-Tomcat-Redis实现Session共享" class="headerlink" title="Nginx+Tomcat+Redis实现Session共享"></a>Nginx+Tomcat+Redis实现Session共享</h2><p>之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。</p>
<p>经过百度，查资料，找到了几种解决session共享的方案。</p>
<ul>
<li><p>不适用session，换作cookie]]>
    
    </summary>
    
      <category term="Nginx,Redis,Tomcat" scheme="/tags/Nginx-Redis-Tomcat/"/>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nginx负载均衡配置]]></title>
    <link href="/2017/06/06/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/"/>
    <id>/2017/06/06/Nginx负载均衡配置/</id>
    <published>2017-06-06T14:50:56.000Z</published>
    <updated>2017-07-11T13:34:57.000Z</updated>
    <content type="html"><![CDATA[<p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<a id="more"></a><br>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<h2 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h2><p>这段来自百度百科，简单介绍一下，读者若需详细了解可自行查找资料，本文侧重于Nginx负载相关的具体操作配置介绍。</p>
<p>Nginx常用的功能有Http代理、反向代理，负载均衡器，web缓存等功能，最近项目需要做负载，简单的研究了一下nginx，对反向代理和负载均衡着重看了一下，所以接下来的文章主要对这两部分进行介绍。</p>
<h4 id="1、Nginx服务器的安装"><a href="#1、Nginx服务器的安装" class="headerlink" title="1、Nginx服务器的安装"></a>1、Nginx服务器的安装</h4><p>windowns版Nginx下载地址：<a href="http://nginx.org/en/docs/windows.html" target="_blank" rel="external">http://nginx.org/en/docs/windows.html</a></p>
<blockquote>
<p>windows上安装Nginx比较简单，Nginx官方已经提供了打包好的.exe的运行文件，不需要用户自己去编译运行。直接打开上面的地址，下载好windows版的nginx，解压后双击nginx.exe或者在命令窗口运行nginx.exe即可。</p>
<p>因为Nginx默认端口是80端口，所以启动成功之后在浏览器地址栏输入localhost就可以看到Nginx的欢迎页面。</p>
</blockquote>
<p>linux版的Nginx下载地址：<a href="http://nginx.org/" target="_blank" rel="external">http://nginx.org/</a></p>
<blockquote>
<p>下载nginx之前，请确保自己的linux系统已经安装了g++，gcc。因为nginx是纯C语言编写，在linux下安装时需要去编译源码安装。</p>
</blockquote>
<ul>
<li><p>解压Nginx源码包</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">nginx-1</span><span class="selector-class">.11</span><span class="selector-class">.5</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置一下nginx配置信息</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; chmod -R <span class="number">777</span> nginx<span class="number">-1.11</span><span class="number">.5</span></div><div class="line">&gt; cd nginx<span class="number">-1.11</span><span class="number">.5</span></div><div class="line">&gt; ./configure --prefix=/usr/local/nginx  #此处设置prefix，是设置nginx的安装路径</div></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">make</span> | <span class="built_in">make</span> install <span class="meta">#将源码文件编译成可执行文件和各种库文件，并将其复制到上面设置的安装目录中</span></div></pre></td></tr></table></figure>
</li>
<li><p>启动nginx</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx -c /u</span>sr<span class="regexp">/local/</span>nginx<span class="regexp">/conf/</span>nginx.conf <span class="comment">#这一步可以不指定nginx配置文件</span></div></pre></td></tr></table></figure>
</li>
<li><p>还有最重要的一步，打开Nginx的防火墙端口</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; vi /etc/sysconfig/iptables</div><div class="line">&gt; 添加端口，如： -A INPUT -m <span class="keyword">state</span> --state NEW -m tcp -p tcp --dport <span class="number">80</span> -j ACCEPT</div><div class="line">&gt; /etc/init.d/iptables restart <span class="comment">#重启防火墙，让修改生效</span></div></pre></td></tr></table></figure>
</li>
<li><p>在自己本机的浏览器中输入localhost就可以看到Nginx的欢迎页面。</p>
</li>
</ul>
<h4 id="2、配置Nginx"><a href="#2、配置Nginx" class="headerlink" title="2、配置Nginx"></a>2、配置Nginx</h4><p>​    在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了）</p>
<pre><code>&gt; Nginx的配置文件在安装目录下的conf目录中，一些默认配置都在这个目录下。
</code></pre><blockquote>
<p>nginx.conf 的注释符号为 #</p>
</blockquote>
<p>打开nginx.conf文件，可以大概浏览一下，配置文件基本可以分为几个模块</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">...              #全局块</div><div class="line">events &#123;         #events块</div><div class="line">   ...</div><div class="line">&#125;</div><div class="line">http      #http块</div><div class="line">&#123;</div><div class="line">    ...   #http全局块</div><div class="line">    server        #server块</div><div class="line">    &#123; </div><div class="line">        ...       #server全局块</div><div class="line">        location [PATTERN]   #location块</div><div class="line">        &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        location [PATTERN] </div><div class="line">        &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    server</div><div class="line">    &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">    ...     #http全局块</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>全局块：配置影像nginx的全局指令。一般有nginx的进程数，错误日志文件路径，nginx的主进程号等</li>
<li>events块：配置Nginx的工作模式，每个进程的最大连接数等</li>
<li>http块：可以嵌套多个server，配置代理，缓存，日志等功能以及第三方模块的配置。如文件引入，mime-type定义，连接超时时间，单连接请求数等等</li>
<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server</li>
<li>location块：配置请求的路由，以及各种页面的处理情况</li>
</ul>
<p>给大家附上一个nginx的配置文件，博主在公司的测试环境上搭的一个负载均衡器。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#user  nobody;</span></div><div class="line"><span class="meta">#nginx进程数，建议设置为CPU总核心数</span></div><div class="line">worker_processes  <span class="number">1</span>;</div><div class="line"><span class="meta">#错误日志文件路径</span></div><div class="line">error_log  logs/error.<span class="built_in">log</span>;</div><div class="line"><span class="meta">#error_log  logs/error.log  notice;</span></div><div class="line"><span class="meta">#error_log  logs/error.log  info;</span></div><div class="line"><span class="meta">#nginx主进程号</span></div><div class="line">pid        logs/nginx.pid;</div><div class="line"><span class="meta">#工作模式与连接数上限</span></div><div class="line">events &#123;</div><div class="line">	<span class="meta"># 单个进程的最大连接数（最大连接数=连接数*进程数）</span></div><div class="line">	worker_connections  <span class="number">1024</span>;</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">	<span class="meta">#文件扩展名与文件类型映射表</span></div><div class="line">	include       mime.types;</div><div class="line">	<span class="meta">#默认文件类型</span></div><div class="line">	default_type  application/octet-<span class="keyword">stream</span>;</div><div class="line">	<span class="meta">#日志文件</span></div><div class="line">	access_log  logs/access.<span class="built_in">log</span>  main;</div><div class="line">	<span class="meta">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 </span></div><div class="line">	sendfile        on;</div><div class="line">	<span class="meta">#防止网络阻塞</span></div><div class="line">	<span class="meta">#tcp_nopush     on;</span></div><div class="line">	<span class="meta">#长连接超时时间，单位是秒</span></div><div class="line">	keepalive_timeout  <span class="number">65</span>;</div><div class="line">	<span class="meta">#服务器列表名称随便写</span></div><div class="line">	upstream global &#123;</div><div class="line">		<span class="meta">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重，权值越高被分配到的几率越大。</span></div><div class="line">		server <span class="number">192.168</span><span class="number">.100</span><span class="number">.100</span>:<span class="number">8081</span>; <span class="meta">#weight=1</span></div><div class="line">		server <span class="number">192.168</span><span class="number">.100</span><span class="number">.100</span>:<span class="number">8084</span>;</div><div class="line">		ip_hash; <span class="meta">#upstream的分配方式</span></div><div class="line">	&#125;</div><div class="line">	<span class="meta">#开启gzip压缩输出</span></div><div class="line">	<span class="meta">#gzip  on;</span></div><div class="line">	server &#123;</div><div class="line">		<span class="meta">#监听端口</span></div><div class="line">		listen       <span class="number">8087</span>;</div><div class="line">		<span class="meta">#域名可以有多个，用空格隔开</span></div><div class="line">		server_name  <span class="number">192.168</span><span class="number">.100</span><span class="number">.100</span>;</div><div class="line">		<span class="meta">#默认编码</span></div><div class="line">		<span class="meta">#charset koi8-r;</span></div><div class="line">		<span class="meta">#对“/”启用反向代理</span></div><div class="line">		<span class="keyword">location</span> / &#123;</div><div class="line">			<span class="meta">#前端页面项目部署路径</span></div><div class="line">			root   /home/fisCM/nginx/html;</div><div class="line">			<span class="meta">#默认主页面</span></div><div class="line">			<span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">#5xx错误对应的页面</span></div><div class="line">		<span class="meta">#error_page   500 502 503 504  /50x.html;</span></div><div class="line">		<span class="meta">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></div><div class="line">		<span class="meta">#我们项目的请求路径为http://192.168.100.100:8087/springboot/...</span></div><div class="line">		<span class="keyword">location</span> ^~ /springboot/ &#123;</div><div class="line">			<span class="meta">#请求转向global 定义的服务器列表</span></div><div class="line">			proxy_pass   http:<span class="comment">//global;</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：192.168.100.100地址是博主瞎写的，读者可改为自己实际的IP地址</p>
<p>由于项目比较简单，所以也没有太多复杂的配置，接下来对Nginx负载均衡的一些基础知识做一下简单介绍。</p>
<h4 id="3、nginx的upstream的几种方式"><a href="#3、nginx的upstream的几种方式" class="headerlink" title="3、nginx的upstream的几种方式"></a>3、nginx的upstream的几种方式</h4><pre><code>&gt; 轮询（默认）
</code></pre><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器冗机，能自动剔除。</p>
<blockquote>
<p>ip_hash</p>
</blockquote>
<p>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。</p>
<blockquote>
<p>weight</p>
</blockquote>
<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<blockquote>
<p>fair(第三方)</p>
</blockquote>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<blockquote>
<p>url_hash(第三方)</p>
</blockquote>
<p>按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。</p>
<p>总结一下，负载均衡简单的理解其实可以看做是用户请求Nginx，Nginx将用户的请求URL按照配置的方式截取，然后按照配置的upstream的方式请求后端服务器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。]]>
    
    </summary>
    
      <category term="Nginx,负载均衡" scheme="/tags/Nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SpringBoot动态数据源切换]]></title>
    <link href="/2017/06/01/SpringBoot%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    <id>/2017/06/01/SpringBoot动态数据源切换/</id>
    <published>2017-06-01T13:30:56.000Z</published>
    <updated>2017-06-06T14:58:33.000Z</updated>
    <content type="html"><![CDATA[<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。<a id="more"></a></p>
<hr>
<ul>
<li>1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line"> * Retrieve the current target DataSource. Determines the</div><div class="line"> * &#123;<span class="doctag">@link</span> #determineCurrentLookupKey() current lookup key&#125;, performs</div><div class="line"> * a lookup in the &#123;<span class="doctag">@link</span> #setTargetDataSources targetDataSources&#125; map,</div><div class="line"> * falls back to the specified</div><div class="line"> * &#123;<span class="doctag">@link</span> #setDefaultTargetDataSource default target DataSource&#125; if necessary.</div><div class="line"> * <span class="doctag">@see</span> #determineCurrentLookupKey()</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> DataSource determineTargetDataSource() &#123;</div><div class="line">	Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</div><div class="line">	Object lookupKey = determineCurrentLookupKey();</div><div class="line">	DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.<span class="keyword">get</span>(lookupKey);</div><div class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="literal">null</span>)) &#123;</div><div class="line">		dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> new IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dataSource;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Determine the current lookup key. This will typically be</div><div class="line"> * implemented to check a thread-bound transaction context.</div><div class="line"> * &lt;p&gt;Allows for arbitrary keys. The returned key needs</div><div class="line"> * to match the stored lookup key type, as resolved by the</div><div class="line"> * &#123;<span class="doctag">@link</span> #resolveSpecifiedLookupKey&#125; method.</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object determineCurrentLookupKey();</div></pre></td></tr></table></figure>
<p>源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的）</p>
<p>所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。</p>
<ul>
<li>2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="type">Object</span> determineCurrentLookupKey() &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * DynamicDataSourceContextHolder代码中使用setDataSource</div><div class="line">         * 设置当前的数据源，在路由类中使用getDataSource进行获取，</div><div class="line">         * 交给AbstractRoutingDataSource进行注入使用。</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="type">DynamicDataSourceContextHolder</span>.getDataSource();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3、创建统一数据源管理类DynamicDataSourceContextHolder</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> DynamicDataSourceContextHolder &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 线程本地环境</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; dataSources = <span class="keyword">new</span> ThreadLocal&lt;<span class="keyword">String</span>&gt;();</div><div class="line">    <span class="comment">// 管理所有的数据源Id</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; dataSourceIds = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> setDataSource(<span class="keyword">String</span> dataSource) &#123;</div><div class="line">        dataSources.set(dataSource);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getDataSource() &#123;</div><div class="line">        <span class="built_in">return</span> dataSources.<span class="built_in">get</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> clearDataSource() &#123;</div><div class="line">        dataSources.<span class="built_in">remove</span>();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断指定的DataSource当前是否存在</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> containsDataSource(<span class="keyword">String</span> dataSourceId) &#123;</div><div class="line">        <span class="built_in">return</span> dataSourceIds.contains(dataSourceId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4、重点来了，创建动态数据源注册器DynamicDataSourceRegister</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 默认数据连接池</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> DATASOURCE_TYPE_DEFAULT = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; dataSourceType;</div><div class="line"></div><div class="line">    <span class="comment">// 默认数据源</span></div><div class="line">    <span class="keyword">private</span> DataSource defaultDataSource;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, DataSource&gt; dataSourceMaps = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, DataSource&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加载多数据源配置</div><div class="line">     * @param environment</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setEnvironment(Environment environment) &#123;</div><div class="line">        initDefaultDataSource(environment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化默认数据源</div><div class="line">     * @param environment</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> initDefaultDataSource(Environment environment) &#123;</div><div class="line">        RelaxedPropertyResolver propertyResolver = <span class="keyword">new</span> RelaxedPropertyResolver(environment, <span class="string">"spring.datasource."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(propertyResolver.getProperty(<span class="string">"type"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(<span class="string">"type"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 创建数据源</span></div><div class="line">        <span class="keyword">String</span> jndiName = propertyResolver.getProperty(<span class="string">"jndi-name"</span>);</div><div class="line">        <span class="keyword">String</span>[] jndiNames = jndiName.<span class="built_in">split</span>(<span class="string">","</span>);</div><div class="line">        defaultDataSource = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        dataSourceMaps.put(<span class="string">"AAA"</span>, defaultDataSource);</div><div class="line">        DataSource dataSource1 = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">1</span>]);</div><div class="line">        dataSourceMaps.put(<span class="string">"BBB"</span>, dataSource1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; targetDataSources = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();</div><div class="line">        <span class="comment">// 将主数据源添加到更多数据源中</span></div><div class="line">        targetDataSources.put(<span class="string">"dataSource"</span>, defaultDataSource);</div><div class="line">        DynamicDataSourceContextHolder.dataSourceIds.<span class="built_in">add</span>(<span class="string">"dataSource"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 添加更多数据源</span></div><div class="line">        targetDataSources.putAll(dataSourceMaps);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">key</span> : dataSourceMaps.keySet()) &#123;</div><div class="line">            DynamicDataSourceContextHolder.dataSourceIds.<span class="built_in">add</span>(<span class="built_in">key</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 创建DynamicDataSource</span></div><div class="line">        GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</div><div class="line">        beanDefinition.setBeanClass(DynamicDataSource.class);</div><div class="line">        beanDefinition.setSynthetic(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();</div><div class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"defaultTargetDataSource"</span>, defaultDataSource);</div><div class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"targetDataSources"</span>, targetDataSources);</div><div class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"dataSource"</span>, beanDefinition);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释

&gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中
&gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。
</code></pre><p>5、将动态数据源注册器导入到Spring容器中</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@SpringBootApplication</span></div><div class="line"><span class="variable">@Import</span>(&#123;DynamicDataSourceRegister.class&#125;)</div><div class="line">public class Application &#123;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</div><div class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(Application.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件：</p>
</blockquote>
<ol>
<li>导入的类使用@Configuration进行标注</li>
<li>导入的类中至少有一个使用@Bean标准的方法</li>
<li>导入的类实现了ImportSelector接口</li>
<li>导入的类实现了ImportBeanDefinitionRegistrar接口</li>
</ol>
<p>到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础</p>
<ul>
<li>6、新建一个TargetDataSource注解</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="variable">@Documented</span></div><div class="line">public <span class="variable">@interface</span> TargetDataSource &#123;</div><div class="line">    <span class="selector-tag">String</span> <span class="selector-tag">value</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。</p>
<ul>
<li>7、新建数据源切换AOP切面</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Order(-1)</span>  <span class="comment">//保证此AOP在@Transactional之前执行</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> static <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 通过注解切换数据源（细粒度）</span></div><div class="line">    <span class="meta">@Around(<span class="meta-string">"@annotation(targetDataSource)"</span>)</span></div><div class="line">    <span class="keyword">public</span> Object changeDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable &#123;</div><div class="line">        Object <span class="keyword">object</span> = <span class="literal">null</span>;</div><div class="line">        String dataSourceId = targetDataSource.value();</div><div class="line">        <span class="keyword">if</span>(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123;</div><div class="line">            logger.info(<span class="string">"系统将使用&#123;&#125;数据源"</span>, dataSourceId);</div><div class="line">            DynamicDataSourceContextHolder.setDataSource(dataSourceId);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.debug(<span class="string">"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;"</span>, dataSourceId, joinPoint.getSignature());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">object</span>=joinPoint.proceed();</div><div class="line">        DynamicDataSourceContextHolder.clearDataSource();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">object</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。</p>
<p>最后附一下JNDI数据源在application.properties文件中的配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.jndi-name=<span class="string">java:</span>comp<span class="regexp">/env/</span>jdbc<span class="regexp">/AAA,java:comp/</span>env<span class="regexp">/jdbc/</span>BBB</div></pre></td></tr></table></figure>
<p>其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。</p>
<p>————————————————华丽的分割线—————————————————-</p>
<p>在项目的进展中，此数据源切换已被改造，增加了<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="external">Druid数据源</a>加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。]]>
    
    </summary>
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人简历]]></title>
    <link href="/2017/02/09/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>/2017/02/09/个人简历/</id>
    <published>2017-02-09T14:38:15.000Z</published>
    <updated>2017-02-15T16:35:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a><center>个人简历</center></h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><blockquote>
<p>姓名：陈敏<br>籍贯：甘肃省平凉市<br>出生年月：1993年3月<br>邮箱：15221499301@139.com<br>联系电话：15221499301<br>博客：<a href="http://artislong.github.io" target="_blank" rel="external">http://artislong.github.io</a><br>github：<a href="https://github.com/artislong" target="_blank" rel="external">https://github.com/artislong</a><br>求职意向：Java研发<a id="more"></a></p>
</blockquote>
<h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote>
<p>简洁清晰的编程习惯，学习能力强<br><br>工作主动，执行力及抗压性强<br><br>热爱开源，喜欢学习各种开源技术<br></p>
</blockquote>
<h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><blockquote>
<p>熟练掌握Java编程语言，有较扎实的代码功底和Java核心基础；<br><br>熟悉HTML,CSS,JavaScript,JQuery前端技术<br><br>掌握Oracle，Mysql两种数据库的使用，熟悉SQL语言，了解Oracle的PL/SQL编程；<br><br>熟练使用SVN进行团队协作开发，熟悉Rational Rose，PowerDesigner建模工具<br><br>掌握Spring Boot，并能够熟练使用<br><br>熟悉Struts2,Hibernate,Spring,SpringMVC,MyBatis<br><br>熟悉Jbpm工作流框架常规工作流程<br><br>熟悉memcache，redis缓存服务器，熟悉其常用操作命令及存储机制<br><br>熟悉Linux常用操作命令</p>
</blockquote>
<h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><blockquote>
<p>2015年11月至2016年5月，进入亚信科技实习，从事新业务工单开发工作</p><p><br>2016年6月转正，进入产商品中心项目组，进行产品服务项目以及产品配置化项目的开发</p>
</blockquote>
<h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><blockquote>
<p>项目名称：OA<br>开发环境：window 7，MySQL 5.6，Tomcat7，jdk1.7<br>开发工具：MyEclipse 10<br>项目描述：本项目主旨为实现办公自动化功能，实现了系统管理、网上交流、审批流转等几大功能，系统管理包括部门管理、员工管理、角色管理，其中，角色管理通过拦截请求url的方式实现了权限控制，通过角色来控制对应角色下的用户对系统的操作权限。使用JBPM工作流框架实现审批流转功能，审批流转具有提交请假单、报销单等功能，审批流程由各级审批人员（经理）进行审批处理。使用DWR框架进行消息推送，实现用户登录提醒功能，并将登录用户信息存储到memcached中，用户可以实时查看在线用户人数及在线用户列表。<br>项目职责：设计与开发<br>项目相关技术：Spring，Struts2，Hibernate，JBPM，DWR，JQuery，Ajax，Memcached，以及JQuery相关插件<br>代码地址：<a href="https://github.com/artislong/OA" target="_blank" rel="external">https://github.com/artislong/OA</a><br>收获：通过项目的练习，使我掌握了SSH框架的基本使用方式，项目中的Jstl标签，El表达式的应用，使我明白了Jstl和El在Web项目中的真正作用，并且使我有了较扎实的代码编写能力。通过拦截url实现权限功能，使我在以后的学习中能够更加容易的掌握Apapche Shiro以及Spring Security安全框架。项目的简单灵活的架构设计，为我打下了项目架构设计的基础。</p>
</blockquote>
<p></p><p></p>
<blockquote>
<p>项目名称：CRM（客户关系管理系统）<br>开发环境：window 7，Oracle，Tomcat6，jdk1.6<br>开发工具：Eclipse JavaEE<br>项目描述：CRM系统作为亚信科技（中国）上海分公司的主要项目，是一款上海移动用户定制业务系统，功能齐全，系统庞大，并且与多个外平台交互。系统强健的功能为业务处理提供全程支撑和监控，实现了业务处理的实时计费，实时监控、实时优惠、实时帐务、实时信息查询和实时处理等多项功能，高效的支撑了业务运营。<br>项目职责：本人负责CRM个人新业务工单的开发，在实习期间，主要完成了一下工作：1、完成CRM短信模板配置界面功能的开发（已上线）。  2、使用Appframe框架提供的批量导入框架（BP）实现了客户投诉信息的批量导入，使用类似于POI的工具解析并处理了Excel数据。  3、梳理CRM系统产品缓存策略，阅读Appframe实现memcached客户端的源码，并对其进行优化。  4、开发扫描客户信息的后台实时处理进程，基本熟悉实时任务和定时任务。<br>项目相关技术：Appframe，Javascript，Ajax<br>收获：CRM系统作为为上海移动服务的主打产品，其中灵活多变的业务逻辑，使我在以后的工作中能够更加容易的理解复杂的业务需求，在掌握技术的前提下能够快速针对需求而做出最有效的实现。虽然整个系统庞大而复杂的业务让开发人员理解困难，但是其各种有效的数据库设计也为我在之后个人独立项目中提供了更多的数据库表的设计灵感。</p>
</blockquote>
<p></p><p></p>
<blockquote>
<p>项目名称：产商品项目<br>开发环境：window 7，Oracle，Tomcat7，jdk1.7<br>开发工具：Intellij Idea<br>项目描述：本项目为产商品中心项目，主要分为读和写两部分。第一部分为服务的开发（既读的部分），服务的开发是在原crm系统服务的基础上，使用SpringBoot+Redis对原有服务进行优化改造；第二部分为配置化项目（既写的部分），主要针对中国移动的各种套餐、活动的配置，采用敏捷开发模式，使用配置化开发方式开发出各种套餐活动的配置化界面。<br><br>项目职责：<br>1、在开发服务的过程中，除过对普通的服务进行改造优化外，本人在项目经理的要求下，完成了组合产品定价服务，为移动商城提供服务支持，其功能类似于淘宝天猫等商城中，不同商品组合购买，可以打不同的折扣。</p><p></p>
</blockquote>
<p>2、在配置化开发部分，主要是采用配置与代码协作开发方式，和同伴一起完成套餐、活动配置模板的开发，并在后期带领实习生完成基本配置工作的入门学习。</p>
<blockquote>
<p>项目相关技术：Spring Boot，Redis，JQuery，Ajax，JSON（Java，JS）<br>收获：使我能够熟练使用Spring Boot框架的同时，也使我掌握了查询优化（Java和Oracle）的基本思想，CRM远程调用产品中心接口的改造，也让我基本掌握了通过http协议调用远程接口的方式，同时，项目中，大量JSON数据的处理，也让我能够熟练的利用JSON工具处理JSON类型的数据。</p>
</blockquote>
<h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><blockquote>
<p>2012.9-2016.6  甘肃农业大学  信息管理与信息系统专业<br>2015.7-2015.11  上海杰普科技有限公司  培训JavaEE开发</p>
</blockquote>
<h3 id="技术经历"><a href="#技术经历" class="headerlink" title="技术经历"></a>技术经历</h3><blockquote>
<p>2013.10月开始自学Java方面相关知识<br>2015.9-2016.3，使用SSH框架完成OA系统的开发，同时作为毕设作品<br>2016.12，参考MyBatis的Mapper配置文件，对Spring自身提供的访问数据库的JdbcTemplate进行封装，主要针对JdbcTemplate的自定义SQL进行封装，设计并开发出一个通用的数据容器，用来存储查询结果，并且配置文件具有热加载功能，最后将其做成Spring Boot的一个Starter POM模块。</p>
</blockquote>
<h3 id="在校荣誉"><a href="#在校荣誉" class="headerlink" title="在校荣誉"></a>在校荣誉</h3><blockquote>
<p>2014年10月  甘肃农业大学计算机技能大赛(设计类)一等奖   校级<br>2014年12月  <a href="http://dasai.lanqiao.org/" target="_blank" rel="external">第六届蓝桥杯全国软件大赛甘肃赛区C语言软件开发三等奖</a>  国家级</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[个人简历  基本信息  姓名：陈敏  籍贯：甘肃省平凉市   出生年月：1993年3月  邮箱：15221499301@139.com  联系电话：15221499301   博客：[http://artislong.github.io](http://artislong.github.io)    github：[https://github.com/artislong](https://github.com/artislong)     求职意向：Java研发]]>
    
    </summary>
    
      <category term="个人简历" scheme="/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
      <category term="个人简历" scheme="/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java基本数据类型缓存解析]]></title>
    <link href="/2016/12/22/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    <id>/2016/12/22/java基本数据类型缓存解析/</id>
    <published>2016-12-21T16:46:28.000Z</published>
    <updated>2016-12-22T14:25:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本类型缓存解析"><a href="#基本类型缓存解析" class="headerlink" title="基本类型缓存解析"></a>基本类型缓存解析<a id="more"></a></h2><h3 id="一、Integer缓存解析："><a href="#一、Integer缓存解析：" class="headerlink" title="一、Integer缓存解析："></a>一、Integer缓存解析：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line">       <span class="keyword">static</span> &#123;</div><div class="line">           <span class="comment">// high value may be configured by property</span></div><div class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">           String integerCacheHighPropValue =</div><div class="line">               sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">               i = Math.max(i, <span class="number">127</span>);</div><div class="line">               <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">               h = Math.min(i, Integer.MAX_VALUE - (-low));</div><div class="line">           &#125;</div><div class="line">           high = h;</div><div class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">           <span class="keyword">int</span> j = low;</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line">       &#125;</div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">   	<span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。</p><p><br>2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。</p><p><br>3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。</p><p></p>
<p>所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false</p><p><br><strong><strong>注意</strong></strong>：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=<size>参数即可。</size></p>
<h3 id="二、Long及Byte、Character缓存解析"><a href="#二、Long及Byte、Character缓存解析" class="headerlink" title="二、Long及Byte、Character缓存解析"></a>二、Long及Byte、Character缓存解析</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</div><div class="line">   	<span class="keyword">private</span> LongCache()&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Long</span> cache[] = <span class="keyword">new</span> <span class="keyword">Long</span>[-(<span class="number">-128</span>) + <span class="number">127</span> + <span class="number">1</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</div><div class="line">            cache[i] = <span class="keyword">new</span> <span class="keyword">Long</span>(i - <span class="number">128</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Long</span> valueOf(<span class="keyword">long</span> l) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</div><div class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">-128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></div><div class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">Long</span>(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基本类型缓存解析"><a href="#基本类型缓存解析" class="headerlink" title="基本类型缓存解析"></a>基本类型缓存解析]]>
    
    </summary>
    
      <category term="java缓存" scheme="/tags/java%E7%BC%93%E5%AD%98/"/>
    
      <category term="java基础" scheme="/categories/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot核心]]></title>
    <link href="/2016/12/18/Spring-Boot%E6%A0%B8%E5%BF%83/"/>
    <id>/2016/12/18/Spring-Boot核心/</id>
    <published>2016-12-18T12:26:36.000Z</published>
    <updated>2016-12-22T14:31:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot基本配置"><a href="#一、Spring-Boot基本配置" class="headerlink" title="一、Spring Boot基本配置"></a>一、Spring Boot基本配置</h2><p></p><p></p>
<h4 id="1、入口类和-SpringBootApplication"><a href="#1、入口类和-SpringBootApplication" class="headerlink" title="1、入口类和@SpringBootApplication"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),<a id="more"></a>启动Spring Boot应用项目。</p>
<h4 id="2、关闭特定的自动配置"><a href="#2、关闭特定的自动配置" class="headerlink" title="2、关闭特定的自动配置"></a>2、关闭特定的自动配置</h4><p>通过<strong>@SpringBootApplication</strong>源码可以看出，关闭特定的自动配置应该使用<strong>@SpringBootApplication</strong>注解的exclude参数，例如:<br>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p>
<h4 id="3、定制Banner"><a href="#3、定制Banner" class="headerlink" title="3、定制Banner"></a>3、定制Banner</h4><p>在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。<br>1）我们在src/main/resources下新建一个banner.txt<br>2）通过<a href="http://patorjk.com/software/taag" target="_blank" rel="external">http://patorjk.com/software/taag</a>网站生成字符，将生成的字符复制到banner.txt文件中<br>3）自动程序，这时控制台图案将变成刚才生成的图案</p>
<h4 id="4、关闭banner"><a href="#4、关闭banner" class="headerlink" title="4、关闭banner"></a>4、关闭banner</h4><p>在main方法中修改为(Spring Boot:1.4.0)：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SpringApplication <span class="built_in">application</span> = new SpringApplication(Chapter1Application.<span class="built_in">class</span>);</div><div class="line">   <span class="built_in">application</span>.setBannerMode(Mode.OFF);</div><div class="line">   <span class="built_in">application</span>.<span class="built_in">run</span>(args);</div></pre></td></tr></table></figure>
<p>  或者</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">new</span> <span class="title">SpringApplicationBuilder</span>(<span class="type">Chapter1Application</span>.class) <span class="comment">//</span></span></div><div class="line">               .<span class="title">bannerMode</span>(<span class="type">Mode</span>.<span class="type">OFF</span>) <span class="comment">//</span></div><div class="line">			.<span class="title">run</span>(args);</div></pre></td></tr></table></figure>
<h4 id="5、Spring-Boot配置文件"><a href="#5、Spring-Boot配置文件" class="headerlink" title="5、Spring Boot配置文件"></a>5、Spring Boot配置文件</h4><p>Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。</p><p><br>Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p><br>Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。<br><br>例如：<br><br>修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在<br>application.properties中添加：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">server</span>.port=<span class="number">9090</span></div><div class="line">   <span class="keyword">server</span>.context-path=/helloBoot</div></pre></td></tr></table></figure>
<h4 id="6、官方starter-pom"><a href="#6、官方starter-pom" class="headerlink" title="6、官方starter pom"></a>6、官方starter pom</h4><p><div style="color:gray"><br>spring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持<br><br>spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  准生产特性，用来监控和管理应用<br><br>spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  提供基于ssh协议的监控和管理<br><br>spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用spring-rabbit来支持AMQP<br><br>spring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成<br><br>spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Batch的支持<br><br>spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Cache抽象的支持<br><br>spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法<br><br>spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-elasticsearch对Elasticsearch的支持<br><br>spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-gemfire对分布式存储GenFile的支持<br><br>spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对JPA的支持，包含spring-data-jpa，spring-orm和Hibernate<br><br>spring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-mongodb，对MongoDB进行支持<br><br>spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务<br><br>spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-solr对Apache Solr数据检索平台的支持<br><br>spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对FreeMarker模板引擎的支持<br><br>spring-boot-starter-groovy-templates  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持<br><br>spring-boot-starter-hateoas  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas  通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持<br><br>spring-boot-starter-hornetq  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持<br><br>spring-boot-starter-integration  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持<br><br>spring-boot-starter-jdbc  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持<br><br>spring-boot-starter-jersey  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持<br><br>spring-boot-starter-jta-atomikos  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持<br><br>spring-boot-starter-jta-bitronix  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持<br><br>spring-boot-starter-mail  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持<br><br>spring-boot-starter-mobile  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持<br><br>spring-boot-starter-mustache  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持<br><br>spring-boot-starter-redis  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reids<br><br>spring-boot-starter-security  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持<br><br>spring-boot-starter-social-faceboot  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持<br><br>spring-boot-starter-social-twitter   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持<br><br>spring-boot-starter-test  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板<br><br>spring-boot-starter-thymeleaf  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置<br><br>spring-boot-starter-velocity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持<br><br>spring-boot-starter-web  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvc<br><br>spring-boot-starter-Tomcat  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcat<br><br>spring-boot-starter-Jetty  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcat<br><br>spring-boot-starter-undertow  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcat<br><br>spring-boot-starter-logging  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logback<br><br>spring-boot-starter-log4j  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架<br><br>spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持<br><br>spring-boot-starter-ws  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持<br><br></div></p>
<p></p><p><br>还有第三方为Spring Boot所写的starter pom,这里不做介绍</p>
<h4 id="7、使用xml配置"><a href="#7、使用xml配置" class="headerlink" title="7、使用xml配置"></a>7、使用xml配置</h4><p>Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的<strong>@ImportResource</strong>来加载xml配置，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">ImportResource</span>(&#123;"<span class="selector-tag">classpath</span><span class="selector-pseudo">:context.xml</span>”&#125;)</div></pre></td></tr></table></figure>
<h4 id="8、命令行参数配置"><a href="#8、命令行参数配置" class="headerlink" title="8、命令行参数配置"></a>8、命令行参数配置</h4><p>Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行<br>可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号</p>
<h4 id="9、常规属性配置"><a href="#9、常规属性配置" class="headerlink" title="9、常规属性配置"></a>9、常规属性配置</h4><p>在常规Spring环境下，注入properties文件里的值得方式，通过<strong>@PropertySource</strong>指明properties文件的位置，然后通过<strong>@Value</strong>注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用<strong>@Value</strong>注入即可。<br><br>例如：<br><br>在application.properties文件中添加属性：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">book.author=cm</span></div><div class="line"><span class="keyword">book.name=spring </span><span class="keyword">boot</span></div></pre></td></tr></table></figure>
<p>在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTests</span> </span>&#123;</div><div class="line">	<span class="meta">@Value</span>(<span class="string">"book.author"</span>)</div><div class="line">	<span class="keyword">private</span> String author;</div><div class="line">	<span class="meta">@Value</span>(<span class="string">"book.name"</span>)</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> author;</div><div class="line">   	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10、类型安全的配置（基于properties）"><a href="#10、类型安全的配置（基于properties）" class="headerlink" title="10、类型安全的配置（基于properties）"></a>10、类型安全的配置（基于properties）</h4><p>Spring Boot提供了基于类型安全的配置方式，通过<strong>@ConfigurationProperties</strong>将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"book"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTests</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String author;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11、日志配置"><a href="#11、日志配置" class="headerlink" title="11、日志配置"></a>11、日志配置</h4><p>Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。</p><p><br>默认情况下，Spring Boot使用Logback作为日志框架。日志级别:<strong><strong>logging.file=/home/cm/mylog.log</strong></strong><br>配置日志文件，格式为logging.level.包名=级别：<strong><strong>logging.level.org.springframework.web=DEBUG</strong></strong></p>
<h4 id="12、Profile配置"><a href="#12、Profile配置" class="headerlink" title="12、Profile配置"></a>12、Profile配置</h4><p>Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),<br>通过在application.properties中设置<strong><strong>spring.profiles.active=prod</strong></strong>来指定活动的Profile<br>例如：<br><br>我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。<br><br>两种配置文件分别为：<br></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">application-prod<span class="selector-class">.properties</span>:  server.port=<span class="number">80</span></div><div class="line">application-dev<span class="selector-class">.properties</span>:  server.port=<span class="number">8888</span></div></pre></td></tr></table></figure>
<p>然后在application.properties增加：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=dev(prod)</div></pre></td></tr></table></figure>
<p>通过Profile可以灵活切换Spring Boot项目的配置了。</p>
<h2 id="二、Spring-Boot运行原理"><a href="#二、Spring-Boot运行原理" class="headerlink" title="二、Spring Boot运行原理"></a>二、Spring Boot运行原理</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：</p><p><br><a href="http://i1.piimg.com/4851/bb6e18a430a22a09.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/bb6e18a430a22a09t.jpg"></a><br><a href="http://i1.piimg.com/4851/73ed190dbda257cb.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/73ed190dbda257cbt.jpg"></a></p><p><br>若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：</p><p><br>1）运行jar时增加—debug参数：java -jar xx.jar —debug</p><p><br>2)在application.properties中设置属性：debug=true（这个方便点）</p><p><br>3）在开发工具启动参数中配置</p><p><br><a href="http://i1.piimg.com/4851/db0610f744b512ec.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/db0610f744b512ect.jpg"></a></p><p></p>
<h4 id="1、Spring-Boot运行原理解析："><a href="#1、Spring-Boot运行原理解析：" class="headerlink" title="1、Spring Boot运行原理解析："></a>1、Spring Boot运行原理解析：</h4><p> 对@SpringBootApplication注解说明：<br>  <strong>@SpringBootApplication</strong>是一个组合注解，它的核心功能是由<strong>@EnableAutoConfiguration</strong>注解提供的。<br>查看<strong>@EnableAutoConfiguration</strong>源码</p><p><br><a href="http://i1.piimg.com/4851/df2b568388d67082.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/df2b568388d67082t.jpg"></a></p><p><br>这里<strong>@Import</strong>注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。<br><a href="http://i1.piimg.com/4851/8290194ff6bbbda5.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/8290194ff6bbbda5t.jpg"></a><br><br><a href="http://i1.piimg.com/4851/dba6c685c8097175.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/dba6c685c8097175t.jpg"></a></p><p><br>       任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下：</p><p></p>
<p><div style="color:gray"><br>    @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下<br><br>    @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下<br><br>     @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件<br><br>     @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件<br><br>     @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置<br><br>     @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下<br><br>     @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下<br><br>     @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下<br><br>     @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值<br><br>     @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值<br><br>     @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean<br><br>     @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下<br><br></div></p><p><br>这些注解都是使用了<strong>@Conditional</strong>元注解，不过是使用了不同的条件而已。</p>
<h4 id="2、分析http的编码配置"><a href="#2、分析http的编码配置" class="headerlink" title="2、分析http的编码配置"></a>2、分析http的编码配置</h4><p>配置参数</p>
<p>  HttpEncodingProperties的源码如下：</p><p><br><a href="http://i1.piimg.com/4851/01b5f66dfd191b68.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/01b5f66dfd191b68t.jpg"></a></p><p><br>这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。<br>根据条件配置CharacterEncodingFilter的Bean，源码如下:<br><a href="http://i1.piimg.com/4851/6307e6e411a78c22.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/6307e6e411a78c22t.jpg"></a></p>
<h4 id="3、自定义自动配置（包装成starter-pom）"><a href="#3、自定义自动配置（包装成starter-pom）" class="headerlink" title="3、自定义自动配置（包装成starter pom）"></a>3、自定义自动配置（包装成starter pom）</h4><p>1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></div><div class="line">   	<span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   	    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2) 新建属性配置类HellpServiceProperties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"hello"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceProperties</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG = <span class="string">"world"</span>;</div><div class="line">    <span class="keyword">private</span> String msg = MSG;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">   	&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">   	    <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world</p><p></p>
<p>3）新建依据类HelloService（此类可以是第三方类库的类）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> HelloService &#123;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">String</span> msg;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sayHello() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + msg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getMsg() &#123;</div><div class="line">        <span class="built_in">return</span> msg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setMsg(<span class="keyword">String</span> msg) &#123;</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4）新建自动配置类</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloServiceProperties.<span class="keyword">class</span>)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(HelloService.<span class="keyword">class</span>)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"hello"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="literal">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> &#123;</span></div><div class="line">   	<span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> HelloServiceProperties helloServiceProperties;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HelloService.<span class="keyword">class</span>)</div><div class="line">    <span class="keyword">public</span> HelloService helloService() &#123;</div><div class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</div><div class="line">        helloService.setMsg(helloServiceProperties.getMsg());</div><div class="line">        <span class="keyword">return</span> helloService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据HelloServiceProperties提供的参数，并通过<strong>@ConditionalOnClass</strong>来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。</p><p><br>5）注册自动配置</p><p><br>在src/main/resources中新建META-INF/spring.factories文件，内容为</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.EnableAutoConfiguration</span>=\	  com<span class="selector-class">.gnd</span><span class="selector-class">.springboot</span><span class="selector-class">.config</span><span class="selector-class">.HelloServiceAutoConfiguration</span>&lt;br&gt;</div></pre></td></tr></table></figure>
<p>其中“\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔</p><p><br>6）测试自定义自动配置</p><p><br>新建一个maven web工程，添加如下依赖:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></div><div class="line">   	<span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.gnd.springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>spring-boot-starter-hello为之前新建的自定义自动配置starter pom</p><p><br>新建测试启动类</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@RestController</span></div><div class="line"><span class="variable">@SpringBootApplication</span></div><div class="line">public class Chapter11Application &#123;</div><div class="line">    <span class="variable">@Autowired</span></div><div class="line">    private HelloService helloService;</div><div class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</div><div class="line">    public String index() &#123;</div><div class="line">        <span class="selector-tag">return</span> <span class="selector-tag">helloService</span><span class="selector-class">.sayHello</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args)&#123;</div><div class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(Chapter11Application.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行测试工程之后，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="external">http://localhost:8080/test</a>“测试，测试结果如下:<br><br><a href="http://p1.bpimg.com/4851/6ff00c546916cb99.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://p1.bpimg.com/4851/6ff00c546916cb99t.jpg"></a></p><p><br>新建application.properties配置文件，内容为</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hello.msg</span>=<span class="string">haha</span></div></pre></td></tr></table></figure>
<p>重启工程，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="external">http://localhost:8080/test</a>“测试，测试结果如下:<br><a href="http://p1.bpimg.com/4851/fbf8797b19bd1733.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://p1.bpimg.com/4851/fbf8797b19bd1733t.jpg"></a></p><p></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、Spring-Boot基本配置"><a href="#一、Spring-Boot基本配置" class="headerlink" title="一、Spring Boot基本配置"></a>一、Spring Boot基本配置</h2><p><p></p>
<h4 id="1、入口类和-SpringBootApplication"><a href="#1、入口类和-SpringBootApplication" class="headerlink" title="1、入口类和@SpringBootApplication"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot核心" scheme="/categories/Spring-Boot%E6%A0%B8%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk各版本区别]]></title>
    <link href="/2016/12/18/jdk%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
    <id>/2016/12/18/jdk各版本区别/</id>
    <published>2016-12-17T16:06:43.000Z</published>
    <updated>2016-12-22T14:24:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdk5新特性"><a href="#jdk5新特性" class="headerlink" title="jdk5新特性"></a>jdk5新特性</h1><h3 id="1、自动装箱和拆箱"><a href="#1、自动装箱和拆箱" class="headerlink" title="1、自动装箱和拆箱"></a>1、自动装箱和拆箱</h3><h3 id="2、枚举"><a href="#2、枚举" class="headerlink" title="2、枚举"></a>2、枚举</h3><h3 id="3、静态导入"><a href="#3、静态导入" class="headerlink" title="3、静态导入"></a>3、静态导入</h3><h3 id="4、可变参数"><a href="#4、可变参数" class="headerlink" title="4、可变参数"></a>4、可变参数</h3><h3 id="5、內省"><a href="#5、內省" class="headerlink" title="5、內省"></a>5、內省</h3><p>   内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。<a id="more"></a>Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br><br>   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p>
<h3 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h3><h3 id="7、For-Each循环"><a href="#7、For-Each循环" class="headerlink" title="7、For-Each循环"></a>7、For-Each循环</h3><h2 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h2><h3 id="1、Desktop类和SystemTray类"><a href="#1、Desktop类和SystemTray类" class="headerlink" title="1、Desktop类和SystemTray类"></a>1、Desktop类和SystemTray类</h3><p>   AWT新增加了两个雷：Desktop，SystemTray。</p><p><br>   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档</p><p><br>   SystemTray可以用来在系统托盘区创建一个托盘程序</p>
<h3 id="2、使用JAXB2来实现对象与XML之间的映射"><a href="#2、使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="2、使用JAXB2来实现对象与XML之间的映射"></a>2、使用JAXB2来实现对象与XML之间的映射</h3><p>   也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。</p>
<h3 id="3、StAX"><a href="#3、StAX" class="headerlink" title="3、StAX"></a>3、StAX</h3><p>   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p><p><br>   SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>
<h3 id="4、使用Compiler-API"><a href="#4、使用Compiler-API" class="headerlink" title="4、使用Compiler API"></a>4、使用Compiler API</h3><p>   使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。</p>
<h3 id="5、轻量级Http-Server-API"><a href="#5、轻量级Http-Server-API" class="headerlink" title="5、轻量级Http Server API"></a>5、轻量级Http Server API</h3><h3 id="6、插入式注解处理API"><a href="#6、插入式注解处理API" class="headerlink" title="6、插入式注解处理API"></a>6、插入式注解处理API</h3><h3 id="7、用Console开发控制台程序"><a href="#7、用Console开发控制台程序" class="headerlink" title="7、用Console开发控制台程序"></a>7、用Console开发控制台程序</h3><h3 id="8、对脚本语言的支持如：ruby，groovy，javascript"><a href="#8、对脚本语言的支持如：ruby，groovy，javascript" class="headerlink" title="8、对脚本语言的支持如：ruby，groovy，javascript"></a>8、对脚本语言的支持如：ruby，groovy，javascript</h3><h3 id="9、Common-Annotations"><a href="#9、Common-Annotations" class="headerlink" title="9、Common Annotations"></a>9、Common Annotations</h3><h2 id="jdk7新特性"><a href="#jdk7新特性" class="headerlink" title="jdk7新特性"></a>jdk7新特性</h2><h3 id="1、switch中可以使用字符串"><a href="#1、switch中可以使用字符串" class="headerlink" title="1、switch中可以使用字符串"></a>1、switch中可以使用字符串</h3><h3 id="2、泛型的自动判断"><a href="#2、泛型的自动判断" class="headerlink" title="2、泛型的自动判断"></a>2、泛型的自动判断</h3><h3 id="3、自定义自动关闭类（实现AutoCloseable接口）"><a href="#3、自定义自动关闭类（实现AutoCloseable接口）" class="headerlink" title="3、自定义自动关闭类（实现AutoCloseable接口）"></a>3、自定义自动关闭类（实现AutoCloseable接口）</h3><h3 id="4、新增一些取环境信息的工具方法（System中的方法）"><a href="#4、新增一些取环境信息的工具方法（System中的方法）" class="headerlink" title="4、新增一些取环境信息的工具方法（System中的方法）"></a>4、新增一些取环境信息的工具方法（System中的方法）</h3><h3 id="5、Boolean类型反转，空指针安全，参数与位运算"><a href="#5、Boolean类型反转，空指针安全，参数与位运算" class="headerlink" title="5、Boolean类型反转，空指针安全，参数与位运算"></a>5、Boolean类型反转，空指针安全，参数与位运算</h3><h3 id="6、两个char间的equals"><a href="#6、两个char间的equals" class="headerlink" title="6、两个char间的equals"></a>6、两个char间的equals</h3><h3 id="7、安全的加减乘除"><a href="#7、安全的加减乘除" class="headerlink" title="7、安全的加减乘除"></a>7、安全的加减乘除</h3><h3 id="1、对Java集合（Collections）的增强支持"><a href="#1、对Java集合（Collections）的增强支持" class="headerlink" title="1、对Java集合（Collections）的增强支持"></a>1、对Java集合（Collections）的增强支持</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list=[<span class="string">"item"</span>]; <span class="comment">//向List集合中添加元素</span></div><div class="line"><span class="built_in">String</span> item=list[<span class="number">0</span>]; <span class="comment">//从List集合中获取元素</span></div><div class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="keyword">set</span>=&#123;<span class="string">"item"</span>&#125;; <span class="comment">//向Set集合对象中添加元</span></div><div class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Integer&gt; map=&#123;<span class="string">"key"</span>:<span class="number">1</span>&#125;; <span class="comment">//向Map集合中添加对象</span></div><div class="line"><span class="built_in">int</span> value=map[<span class="string">"key"</span>]; <span class="comment">//从Map集合中获取对象</span></div></pre></td></tr></table></figure>
<p>   但是经过自己测试，按照上面的使用方法，并不能创建集合。</p>
<h3 id="2、int支持二进制数据"><a href="#2、int支持二进制数据" class="headerlink" title="2、int支持二进制数据"></a>2、int支持二进制数据</h3><h3 id="3、在try-catch异常捕捉中，一个catch可以写多个异常类型"><a href="#3、在try-catch异常捕捉中，一个catch可以写多个异常类型" class="headerlink" title="3、在try catch异常捕捉中，一个catch可以写多个异常类型"></a>3、在try catch异常捕捉中，一个catch可以写多个异常类型</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Connection conn = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   	<span class="keyword">Class</span>.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">   	conn = DriverManager.getConnection(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException|SQLException ex) &#123;</div><div class="line">   	ex.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、try-catch中资源定义好之后try-catch自动关闭"><a href="#4、try-catch中资源定义好之后try-catch自动关闭" class="headerlink" title="4、try catch中资源定义好之后try catch自动关闭"></a>4、try catch中资源定义好之后try catch自动关闭</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (BufferedReader <span class="keyword">in</span>  = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> 	FileReader(<span class="string">"in.txt"</span>));</div><div class="line">    	BufferedWriter <span class="keyword">out</span> = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> 	FileWriter(<span class="string">"out.txt"</span>))) &#123;</div><div class="line">	<span class="keyword">int</span> charRead;</div><div class="line">	<span class="keyword">while</span> ((charRead = <span class="keyword">in</span>.read()) != <span class="number">-1</span>) &#123;</div><div class="line">       	System.<span class="keyword">out</span>.printf(<span class="string">"%c "</span>, (<span class="keyword">char</span>)charRead);</div><div class="line">       	<span class="keyword">out</span>.write(charRead);</div><div class="line">   	&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">   	ex.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="jdk8新特性"><a href="#jdk8新特性" class="headerlink" title="jdk8新特性"></a>jdk8新特性</h2><h3 id="1、接口的默认方法"><a href="#1、接口的默认方法" class="headerlink" title="1、接口的默认方法"></a>1、接口的默认方法</h3><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">   	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line">   	<span class="keyword">default</span> <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">return</span> Math.<span class="title">sqrt</span><span class="params">(a)</span></span>;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keyword">double</span> calculate(<span class="keyword">int</span> a) &#123;</div><div class="line">	<span class="built_in">return</span> <span class="built_in">sqrt</span>(a * <span class="number">100</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;;</div><div class="line">  System.out.<span class="built_in">println</span>(formula.calculate(<span class="number">100</span>));  <span class="comment">// 100.0</span></div><div class="line">  System.out.<span class="built_in">println</span>(formula.<span class="built_in">sqrt</span>(<span class="number">16</span>));  <span class="comment">// 4.0</span></div></pre></td></tr></table></figure>
<p>文中的formula被实现为一个匿名类的实例，该代码非常</p>
<h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names = Arrays.asList(<span class="string">"tom"</span>,<span class="string">"jace"</span>,<span class="string">"mike"</span>);</div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;<span class="built_in">String</span>&gt;() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	public <span class="built_in">int</span> compare(<span class="built_in">String</span> o1, <span class="built_in">String</span> o2) &#123;</div><div class="line">		<span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。<br>在Java 8中提供了更简洁的语法，lambda表达式：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (String a, String b) -&gt; &#123;</span></span></div><div class="line">	<span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还可以更简洁：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (String a, String b) -&gt; b.compareTo(a))</span>;</span></div></pre></td></tr></table></figure>
<p>去掉大括号以及return关键字</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (a,b) -&gt; b.compareTo(a))</span>;</span></div></pre></td></tr></table></figure>
<p>Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。</p>
<h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><p>Lambda表达式是如何在java的类型系统中表示的呢？</p><p><br>每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。</p><p><br>我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加<strong>@FunctionalInterface</strong>注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说<strong>@FunctionalInterface</strong>注解标注的接口只能有一个抽象方法。</p><p><br>例如：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Converter&lt;F, T&gt; &#123;</div><div class="line">	T convert(F <span class="keyword">from</span>);</div><div class="line">&#125;</div><div class="line">Converter&lt;String, Integer&gt; <span class="function"><span class="title">converter</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> Integer.valueOf(<span class="keyword">from</span>);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);</div></pre></td></tr></table></figure>
<p>以上代码不需要@FunctionalInterface注解也是正确的。</p>
<h3 id="4、方法与构造函数引用"><a href="#4、方法与构造函数引用" class="headerlink" title="4、方法与构造函数引用"></a>4、方法与构造函数引用</h3><p>上面的代码也可以通过静态方法引用来表示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; converter = <span class="built_in">Integer</span><span class="type">::</span>valueOf;</div><div class="line"><span class="built_in">Integer</span> converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);</div></pre></td></tr></table></figure>
<p>Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">   	<span class="keyword">String</span> firstName;</div><div class="line">    <span class="keyword">String</span> lastName;</div><div class="line">   	Person() &#123;</div><div class="line">   	&#125;</div><div class="line">	<span class="keyword">public</span> Person(<span class="keyword">String</span> firstName, <span class="keyword">String</span> lastName) &#123;</div><div class="line">		<span class="built_in">this</span>.firstName = firstName;</div><div class="line">		<span class="built_in">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指定一个用来创建Person对象的对象工厂接口：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Person</span></span>&gt; </span>&#123;</div><div class="line">	P create(<span class="keyword">String</span> fisrtName, <span class="keyword">String</span> lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建Person对象</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;<span class="keyword">Person</span>&gt; personFactory = <span class="keyword">Person</span>::new;</div><div class="line"><span class="keyword">Person</span> <span class="keyword">person</span> = personFactory.create(<span class="string">"Peter"</span>,<span class="string">"Parker”);</span></div></pre></td></tr></table></figure>
<p>我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<h3 id="5、Lambda作用域"><a href="#5、Lambda作用域" class="headerlink" title="5、Lambda作用域"></a>5、Lambda作用域</h3><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<h3 id="6、访问局部变量"><a href="#6、访问局部变量" class="headerlink" title="6、访问局部变量"></a>6、访问局部变量</h3><p>我们可以直接在lambda表达式中访问外层的局部变量</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, <span class="built_in">String</span>&gt; stringConverter = (from) -&gt; <span class="built_in">String</span>.valueOf(from + <span class="built_in">num</span>);</div><div class="line">stringConverter.convert(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。</p>
<h3 id="7、访问对象字段与静态变量"><a href="#7、访问对象字段与静态变量" class="headerlink" title="7、访问对象字段与静态变量"></a>7、访问对象字段与静态变量</h3><p>和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static int outerStaticNum;</div><div class="line">int outerNum;</div><div class="line">public <span class="literal">void</span> testScopes() &#123;</div><div class="line">   	Converter <span class="function"><span class="title">stringConverter1</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> &#123;</div><div class="line">       	outerNum = <span class="number">23</span>;</div><div class="line">       	<span class="keyword">return</span> String.valueOf(<span class="keyword">from</span>);</div><div class="line">   	&#125;;</div><div class="line">    Converter <span class="function"><span class="title">stringConverter2</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> &#123;</div><div class="line">   	    outerStaticNum = <span class="number">72</span>;</div><div class="line">       	<span class="keyword">return</span> String.valueOf(<span class="keyword">from</span>);</div><div class="line">   	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8、访问接口的默认方法"><a href="#8、访问接口的默认方法" class="headerlink" title="8、访问接口的默认方法"></a>8、访问接口的默认方法</h3><h3 id="9、Date-API"><a href="#9、Date-API" class="headerlink" title="9、Date API"></a>9、Date API</h3><h3 id="10、Annotation注解"><a href="#10、Annotation注解" class="headerlink" title="10、Annotation注解"></a>10、Annotation注解</h3>]]></content>
    <summary type="html">
    <![CDATA[自从1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0）以来，到现在jdk的版本已经更新到1.8了，1.9也即将出现。本文将介绍jdk1.5到1.8各版本的特性。]]>
    
    </summary>
    
      <category term="jdk版本" scheme="/tags/jdk%E7%89%88%E6%9C%AC/"/>
    
      <category term="Java基础" scheme="/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot入门]]></title>
    <link href="/2016/12/13/Spring-Boot%E5%85%A5%E9%97%A8/"/>
    <id>/2016/12/13/Spring-Boot入门/</id>
    <published>2016-12-13T15:18:29.000Z</published>
    <updated>2017-12-22T06:46:31.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="一、Spring-Boot简介"><a href="#一、Spring-Boot简介" class="headerlink" title="一、Spring Boot简介"></a>一、Spring Boot简介</h1><p>   <strong><em>Spring Boot</em></strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<a id="more"></a><br><br>    </p><p>Spring Boot有以下几个优点：<br><br>    1、 没有代码生成，不需要XML配置文件<br><br>    2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br><br>    3、 可以独立运行Spring应用程序<br><br>    4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br><br>    5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br><br>    6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br></p>
<h1 id="二、Spring-Boot入门工程搭建："><a href="#二、Spring-Boot入门工程搭建：" class="headerlink" title="二、Spring Boot入门工程搭建："></a>二、Spring Boot入门工程搭建：</h1><h2 id="1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。"><a href="#1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。" class="headerlink" title="1、采用Spring官网提供的SPRING INITIALIZR进行搭建。"></a>1、采用Spring官网提供的<a href="https://start.spring.io/" target="_blank" rel="external">SPRING INITIALIZR</a>进行搭建。</h2><p>可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。</p>
<h2 id="2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）"><a href="#2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）" class="headerlink" title="2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）"></a>2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）</h2><h3 id="1、新建一个Maven的web工程"><a href="#1、新建一个Maven的web工程" class="headerlink" title="1、新建一个Maven的web工程"></a>1、新建一个Maven的web工程</h3><h3 id="2、在pom-xml文件中添加Spring-Boot的相关依赖"><a href="#2、在pom-xml文件中添加Spring-Boot的相关依赖" class="headerlink" title="2、在pom.xml文件中添加Spring Boot的相关依赖"></a>2、在pom.xml文件中添加Spring Boot的相关依赖</h3><p>添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure>
<p>添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在dependencies中添加Web支持的starter pom。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>spring-boot-starter-web会自动添加它所依赖的jar包</p>
<p>然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="3、简单测试"><a href="#3、简单测试" class="headerlink" title="3、简单测试"></a>3、简单测试</h3><p>新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter01Application</span> </span>&#123;</div><div class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    	SpringApplication.run(Chapter01Application.class, args);</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>注</em></strong>：<br><strong>@SpringBootApplication</strong>是一个组合注解，查看其源码，<strong>@SpringBootApplication</strong><br>组合了<strong>@SpringBootConfiguration</strong>，<strong>@EnableAutoConfiguration</strong>，<strong>@ComponentScan</strong>三个注解，<strong>@SpringBootConfiguration</strong>表示当前类是一个启动应用程序的入口；<strong>@EnableAutoConfiguration</strong>注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了<strong>@Component</strong>注解的类。</p>
<p>然后新建目录controller，在其中新建一个HelloController测试类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</div><div class="line">   	<span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</div><div class="line">   	<span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">       	<span class="keyword">return</span> <span class="string">"Hello, World!"</span>;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>@RestController</strong>也是一个组合注解，组合了<strong>@Controller</strong>，<strong>@ResponseBody</strong>两个注解</p>
<h3 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h3><p>使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>即可访问HelloController。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="一、Spring-Boot简介"><a href="#一、Spring-Boot简介" class="headerlink" title="一、Spring Boot简介"></a>一、Spring Boot简介</h1><p>   <strong><em>Spring Boot</em></strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot" scheme="/categories/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot入门]]></title>
    <link href="/2016/12/13/Spring-Boot%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>/2016/12/13/Spring-Boot基础配置/</id>
    <published>2016-12-13T12:43:01.000Z</published>
    <updated>2017-06-01T14:44:47.000Z</updated>
    <content type="html"><![CDATA[<p>#Spring Boot入门</p>
<p></p><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<br>  </p><p>Spring Boot有以下几个优点：<br><br>   1、 没有代码生成，不需要XML配置文件<br><br>   2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br><br>   3、 可以独立运行Spring应用程序<br><br>   4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br><br>   5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br><br>   6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br></p>
<p>###Spring Boot入门工程搭建：</p>
<h4 id="一、采用Spring官网提供的SPRING-INITIALIZR进行搭建。"><a href="#一、采用Spring官网提供的SPRING-INITIALIZR进行搭建。" class="headerlink" title="一、采用Spring官网提供的SPRING INITIALIZR进行搭建。"></a>一、采用Spring官网提供的<a href="https://start.spring.io/" target="_blank" rel="external">SPRING INITIALIZR</a>进行搭建。<p></p></h4><p>可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。</p><p></p>
<h4 id="二、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）"><a href="#二、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）" class="headerlink" title="二、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）"></a>二、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）</h4><h5 id="1、新建一个Maven的web工程"><a href="#1、新建一个Maven的web工程" class="headerlink" title="1、新建一个Maven的web工程"></a>1、新建一个Maven的web工程<br></h5><h5 id="2、在pom-xml文件中添加Spring-Boot的相关依赖"><a href="#2、在pom-xml文件中添加Spring-Boot的相关依赖" class="headerlink" title="2、在pom.xml文件中添加Spring Boot的相关依赖"></a>2、在pom.xml文件中添加Spring Boot的相关依赖</h5><p>   添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。<br></p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;
</code></pre><p>   <br>添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。<br></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>   <br>然后在dependencies中添加Web支持的starter pom。<br></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>   <br>spring-boot-starter-web会自动添加它所依赖的jar包<br><br>   <br>然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程<br></p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;fork&gt;true&lt;/fork&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre><h5 id="3、简单测试"><a href="#3、简单测试" class="headerlink" title="3、简单测试"></a>3、简单测试</h5><p>   新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法<br></p>
<pre><code>@SpringBootApplication
public class Chapter01Application {
    public static void main(String[] args){                                  
        SpringApplication.run(Chapter01Application.class, args);
    }
}
</code></pre><p><strong><em>注</em></strong>：<strong>@SpringBootApplication</strong>是一个组合注解，查看其源码，<strong>@SpringBootApplication</strong><br>组合了<strong>@SpringBootConfiguration</strong>，<strong>@EnableAutoConfiguration</strong>，<strong>@ComponentScan</strong>三个注解，<strong>@SpringBootConfiguration</strong>表示当前类是一个启动应用程序的入口；<strong>@EnableAutoConfiguration</strong>注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；<strong>@ComponentScan</strong>会以Application入口类所在目录为根目录，自动扫描工程中标注了<strong>@Component</strong>注解的类。</p>
<p>  然后新建目录controller，在其中新建一个HelloController测试类。</p>
<pre><code>@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String index() {
        return &quot;Hello, World!&quot;;
    }
}
</code></pre><p>  <strong>@RestController</strong>也是一个组合注解，组合了<strong>@Controller</strong>，<strong>@ResponseBody</strong>两个注解</p>
<h5 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h5><p>   使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>即可访问HelloController</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#Spring Boot入门</p>
<p></p><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义]]>
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot基础" scheme="/categories/Spring-Boot%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
