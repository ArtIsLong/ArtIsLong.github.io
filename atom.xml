<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ArtIsLong的博客</title>
  <icon>https://www.gravatar.com/avatar/47c1a368ad9177b591ba064133d38dbc</icon>
  <subtitle>好的程序猿都是野路子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2018-11-12T01:48:40.751Z</updated>
  <id>/</id>
  
  <author>
    <name>ArtIsLong的博客</name>
    <email>799418876@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Storm集群搭建</title>
    <link href="/2018/08/07/Storm%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>/2018/08/07/Storm集群搭建/</id>
    <published>2018-08-07T05:45:58.000Z</published>
    <updated>2018-11-12T01:48:40.751Z</updated>
    
    <content type="html"><![CDATA[<p>近来公司项目步入大数据的范畴，需要Spark、Storm方面的知识储备。在学习了Scala之后，进入正式的开发准备工作，接下来对Storm集群的搭建略作介绍。<a id="more"></a></p><p>Storm集群搭建方式，可参考<a href="http://storm.apache.org/releases/1.2.2/Setting-up-a-Storm-cluster.html" target="_blank" rel="noopener">Storm官方文档</a>搭建。</p><h2 id="基本配置详解"><a href="#基本配置详解" class="headerlink" title="基本配置详解"></a>基本配置详解</h2><table><thead><tr><th>配置项</th><th>配置说明</th></tr></thead><tbody><tr><td>storm.zookeeper.servers</td><td>ZooKeeper服务器列表</td></tr><tr><td>storm.zookeeper.port</td><td>ZooKeeper连接端口</td></tr><tr><td>storm.local.dir</td><td>storm使用的本地文件系统目录(必须存在并且storm进程可读写)</td></tr><tr><td>storm.cluster.mode</td><td>Storm集群运行模式([distributed\</td><td>local])</td></tr><tr><td>storm.local.mode.zmq</td><td>Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false</td></tr><tr><td>storm.zookeeper.root</td><td>ZooKeeper中Storm的根目录位置</td></tr><tr><td>storm.zookeeper.session.timeout</td><td>客户端连接ZooKeeper超时时间</td></tr><tr><td>storm.id</td><td>运行中拓扑的id,由storm name和一个唯一随机数组成。</td></tr><tr><td>nimbus.host</td><td>nimbus服务器地址</td></tr><tr><td>nimbus.thrift.port</td><td>nimbus的thrift监听端口</td></tr><tr><td>nimbus.childopts</td><td>通过storm-deploy项目部署时指定给nimbus进程的jvm选项</td></tr><tr><td>nimbus.task.timeout.secs</td><td>心跳超时时间，超时后nimbus会认为task死掉并重分配给另一个地址。</td></tr><tr><td>nimbus.monitor.freq.secs</td><td>nimbus检查心跳和重分配任务的时间间隔.注意如果是机器宕掉nimbus会立即接管并处理。</td></tr><tr><td>nimbus.supervisor.timeout.secs</td><td>supervisor的心跳超时时间,一旦超过nimbus会认为该supervisor已死并停止为它分发新任务.</td></tr><tr><td>nimbus.task.launch.secs</td><td>task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs.</td></tr><tr><td>nimbus.reassign</td><td>当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。</td></tr><tr><td>nimbus.file.copy.expiration.secs</td><td>nimbus判断上传/下载链接的超时时间，当空闲时间超过该设定时nimbus会认为链接死掉并主动断开</td></tr><tr><td>ui.port</td><td>Storm UI的服务端口</td></tr><tr><td>drpc.servers</td><td>DRPC服务器列表，以便DRPCSpout知道和谁通讯</td></tr><tr><td>drpc.port</td><td>Storm DRPC的服务端口</td></tr><tr><td>supervisor.slots.ports</td><td>supervisor上能够运行workers的端口列表.每个worker占用一个端口,且每个端口只运行一个worker.通过这项配置可以调整每台机器上运行的worker数.(调整slot数/每机)</td></tr><tr><td>supervisor.childopts</td><td>在storm-deploy项目中使用,用来配置supervisor守护进程的jvm选项</td></tr><tr><td>supervisor.worker.timeout.secs</td><td>supervisor中的worker心跳超时时间,一旦超时supervisor会尝试重启worker进程.</td></tr><tr><td>supervisor.worker.start.timeout.secs</td><td>supervisor初始启动时，worker的心跳超时时间，当超过该时间supervisor会尝试重启worker。因为JVM初始启动和配置会带来的额外消耗，从而使得第一次心跳会超过supervisor.worker.timeout.secs的设定</td></tr><tr><td>supervisor.enable</td><td>supervisor是否应当运行分配给他的workers.默认为true,该选项用来进行Storm的单元测试,一般不应修改.</td></tr><tr><td>supervisor.heartbeat.frequency.secs</td><td>supervisor心跳发送频率(多久发送一次)</td></tr><tr><td>supervisor.monitor.frequency.secs</td><td>supervisor检查worker心跳的频率</td></tr><tr><td>worker.childopts</td><td>supervisor启动worker时使用的jvm选项.所有的”%ID%”字串会被替换为对应worker的标识符</td></tr><tr><td>worker.heartbeat.frequency.secs</td><td>worker的心跳发送时间间隔</td></tr><tr><td>task.heartbeat.frequency.secs</td><td>task汇报状态心跳时间间隔</td></tr><tr><td>task.refresh.poll.secs</td><td>task与其他tasks之间链接同步的频率.(如果task被重分配,其他tasks向它发送消息需要刷新连接).一般来讲，重分配发生时其他tasks会理解得到通知。该配置仅仅为了防止未通知的情况。</td></tr><tr><td>topology.debug</td><td>如果设置成true，Storm将记录发射的每条信息。</td></tr><tr><td>topology.optimize</td><td>master是否在合适时机通过在单个线程内运行多个task以达到优化topologies的目的.</td></tr><tr><td>topology.workers</td><td>执行该topology集群中应当启动的进程数量.每个进程内部将以线程方式执行一定数目的tasks.topology的组件结合该参数和并行度提示来优化性能</td></tr><tr><td>topology.ackers</td><td>topology中启动的acker任务数.Acker保存由spout发送的tuples的记录，并探测tuple何时被完全处理.当Acker探测到tuple被处理完毕时会向spout发送确认信息.通常应当根据topology的吞吐量来确定acker的数目，但一般不需要太多.当设置为0时,相当于禁用了消息可靠性,storm会在spout发送tuples后立即进行确认.</td></tr><tr><td>topology.message.timeout.secs</td><td>topology中spout发送消息的最大处理超时时间.如果一条消息在该时间窗口内未被成功ack,Storm会告知spout这条消息失败。而部分spout实现了失败消息重播功能。</td></tr><tr><td>topology.kryo.register</td><td>注册到Kryo(Storm底层的序列化框架)的序列化方案列表.序列化方案可以是一个类名,或者是com.esotericsoftware.kryo.Serializer的实现.</td></tr><tr><td>topology.skip.missing.kryo.registrations</td><td>Storm是否应该跳过它不能识别的kryo序列化方案.如果设置为否task可能会装载失败或者在运行时抛出错误.</td></tr><tr><td>topology.max.task.parallelism</td><td>在一个topology中能够允许的最大组件并行度.该项配置主要用在本地模式中测试线程数限制.</td></tr><tr><td>topology.max.spout.pending</td><td>一个spout task中处于pending状态的最大的tuples数量.该配置应用于单个task,而不是整个spouts或topology.</td></tr><tr><td>topology.state.synchronization.timeout.secs</td><td>组件同步状态源的最大超时时间(保留选项,暂未使用)</td></tr><tr><td>topology.stats.sample.rate</td><td>用来产生task统计信息的tuples抽样百分比</td></tr><tr><td>topology.fall.back.on.java.serialization</td><td>topology中是否使用java的序列化方案</td></tr><tr><td>zmq.threads</td><td>每个worker进程内zeromq通讯用到的线程数</td></tr><tr><td>zmq.linger.millis</td><td>当连接关闭时,链接尝试重新发送消息到目标主机的持续时长.这是一个不常用的高级选项,基本上可以忽略.</td></tr><tr><td>java.library.path</td><td>JVM启动(如Nimbus,Supervisor和workers)时的java.library.path设置.该选项告诉JVM在哪些路径下定位本地库.</td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li><p>从<a href="http://storm.apache.org/downloads.html" target="_blank" rel="noopener">Storm官网</a>下载Storm安装包，本文使用的Storm版本为1.2.2 </p></li><li><p>从<a href="http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.10" target="_blank" rel="noopener">Zookeeper官网</a>下载Zookeeper安装包</p></li></ul><h2 id="开始安装配置"><a href="#开始安装配置" class="headerlink" title="开始安装配置"></a>开始安装配置</h2><p>由于Zookeeper和Storm都是以Java为基础开发的，所以需要Java环境，在Linux服务器上配置Java开发环境，此处不做累述，读者请自行百度。</p><h3 id="搭建Zookeeper集群"><a href="#搭建Zookeeper集群" class="headerlink" title="搭建Zookeeper集群"></a>搭建Zookeeper集群</h3><p>参考 Zookeeper集群搭建博客</p><h3 id="搭建Storm集群"><a href="#搭建Storm集群" class="headerlink" title="搭建Storm集群"></a>搭建Storm集群</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//www.apache.org/dyn/closer.<span class="keyword">lua</span>/storm/apache-storm-<span class="number">1.2</span>.<span class="number">2</span>/apache-storm-<span class="number">1.2</span>.<span class="number">2</span>.tar.gz</span><br><span class="line">tar -zxvf apache-storm-<span class="number">1.2</span>.<span class="number">2</span>.tar.gz</span><br><span class="line"><span class="keyword">cd</span> apache-storm-<span class="number">1.2</span>.<span class="number">2</span>/<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">vi</span> storm.yaml</span><br></pre></td></tr></table></figure><p>主要的配置项有一下几点：</p><ul><li><p>配置Storm集群的Zookeeper集群主机列表</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storm.zookeeper.servers:</span><br><span class="line">    -<span class="ruby"> <span class="string">"master"</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">"slave1"</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">"slave2"</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果Zookeeper集群使用的端口与默认端口不同，还需一下配置：</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm<span class="selector-class">.zookeeper</span><span class="selector-class">.port</span>: <span class="number">2182</span></span><br></pre></td></tr></table></figure><p>zookeeper集群的搭建可参考之前的zookeeper集群搭建的博客搭建。</p><ul><li>指定Storm数据存储目录</li></ul><p>Nimbus和Supervisor守护进程需要在本地磁盘上存储少量状态信息。需要我们手动在每台Supervisor机器上创建此目录，并授予适当的权限。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm<span class="selector-class">.local</span><span class="selector-class">.dir</span>: <span class="string">"/home/hadoop/storm/data"</span></span><br></pre></td></tr></table></figure><p>如果使用相对路径，可以相对于安装Storm的位置（STORM_HOME），或者使用默认值留空。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$STORM</span>_HOME/data</span></span><br></pre></td></tr></table></figure><ul><li>supervisor的worker数量配置</li></ul><p>以下配置指定supervisor的工作节点，可以运行的worker数量，每个worker占用一个端口来接收消息，最多分配5个；默认情况下每个节点可以运行4个worker，分别在6700、6701、6702、6703，此处定义几个端口，则就表示可以运行几个worker。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">supervisor.slots.ports:</span><br><span class="line">    -<span class="ruby"> <span class="number">6700</span></span></span><br><span class="line"><span class="ruby">    - <span class="number">6701</span></span></span><br><span class="line"><span class="ruby">    - <span class="number">6702</span></span></span><br><span class="line"><span class="ruby">    - <span class="number">6703</span></span></span><br></pre></td></tr></table></figure><p>此处为最基本的配置，若需其他对集群的优化配置，请查看官网Storm集群搭建教程，上面有详细的配置方式。（英语较差的童鞋，不要害怕英文文档，试着读，多读几遍，慢慢的大概意思也会了解了，有道是“书读百遍其义自见”）</p><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><ul><li>在Nimbus主机上启动nimbus</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm nimbus 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><ul><li>在每个Storm集群节点上启动supervisor</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm supervisor 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><ul><li>在Nimbus主机上启动Storm UI</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm ui 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>启动成功之后可在浏览器中，使用<a href="http://xxx.xxx.xxx.xxx:8080访问。" target="_blank" rel="noopener">http://xxx.xxx.xxx.xxx:8080访问。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来公司项目步入大数据的范畴，需要Spark、Storm方面的知识储备。在学习了Scala之后，进入正式的开发准备工作，接下来对Storm集群的搭建略作介绍。
    
    </summary>
    
      <category term="Storm" scheme="/categories/Storm/"/>
    
    
      <category term="Storm" scheme="/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Activiti 23张表及7大服务详解</title>
    <link href="/2018/07/28/Activiti-23%E5%BC%A0%E8%A1%A8%E5%8F%8A7%E5%A4%A7%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>/2018/07/28/Activiti-23张表及7大服务详解/</id>
    <published>2018-07-28T15:43:07.000Z</published>
    <updated>2018-10-30T10:21:17.861Z</updated>
    
    <content type="html"><![CDATA[<p>近来要做流程项目了，由于上大学的时候学过BPMN，现在重新入手Activiti，感觉还是比较容易的，此文先将Activiti6相关的服务接口及相关表略做记录，方便以后查看。<br><a id="more"></a></p><h3 id="7大服务介绍"><a href="#7大服务介绍" class="headerlink" title="7大服务介绍"></a>7大服务介绍</h3><table><thead><tr><th>服务名称</th><th>描述</th></tr></thead><tbody><tr><td>RepositoryService</td><td>Activiti 中每一个不同版本的业务流程的定义都需要使用一些定义文件，部署文件和支持数据 ( 例如 BPMN2.0 XML 文件，表单定义文件，流程定义图像文件等 )，这些文件都存储在 Activiti 内建的 Repository 中。Repository Service 提供了对 repository 的存取服务。</td></tr><tr><td>RuntimeService</td><td>在 Activiti 中，每当一个流程定义被启动一次之后，都会生成一个相应的流程对象实例。Runtime Service 提供了启动流程、查询流程实例、设置获取流程实例变量等功能。此外它还提供了对流程部署，流程定义和流程实例的存取服务。</td></tr><tr><td>TaskService</td><td>在 Activiti 中业务流程定义中的每一个执行节点被称为一个 Task，对流程中的数据存取，状态变更等操作均需要在 Task 中完成。Task Service 提供了对用户 Task 和 Form 相关的操作。它提供了运行时任务查询、领取、完成、删除以及变量设置等功能。</td></tr><tr><td>IdentityService</td><td>Activiti 中内置了用户以及组管理的功能，必须使用这些用户和组的信息才能获取到相应的 Task。Identity Service 提供了对 Activiti 系统中的用户和组的管理功能。</td></tr><tr><td>ManagementService</td><td>Management Service 提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。</td></tr><tr><td>HistoryService</td><td>History Service 用于获取正在运行或已经完成的流程实例的信息，与 Runtime Service 中获取的流程信息不同，历史信息包含已经持久化存储的永久信息，并已经被针对查询优化。</td></tr><tr><td>FormService</td><td>Activiti 中的流程和状态 Task 均可以关联业务相关的数据。通过使用 Form Service 可以存取启动和完成任务所需的表单数据并且根据需要来渲染表单。</td></tr></tbody></table><h3 id="23张表概览"><a href="#23张表概览" class="headerlink" title="23张表概览"></a>23张表概览</h3><p>Activiti使用到的表都是ACT_开头的。</p><ul><li><p>ACT_RE_*:</p><p>’RE’表示repository(存储)，RepositoryService接口所操作的表。带此前缀的表包含的是静态信息，如，流程定义，流程的资源（图片，规则等）。</p></li><li><p>ACT_RU_*:</p><p>‘RU’表示runtime，运行时表-RuntimeService。这是运行时的表存储着流程变量，用户任务，变量，职责（job）等运行时的数据。Activiti只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。</p></li><li><p>ACT_ID_*:</p><p>’ID’表示identity (组织机构)，IdentityService接口所操作的表。用户记录，流程中使用到的用户和组。这些表包含标识的信息，如用户，用户组，等等。</p></li><li><p>ACT_HI_*:</p><p>’HI’表示history，历史数据表，HistoryService。就是这些表包含着流程执行的历史相关数据，如结束的流程实例，变量，任务，等等</p></li><li><p>ACT_GE_*:</p><p>全局通用数据及设置(general)，各种情况都使用的数据。</p></li></ul><table><thead><tr><th>序号</th><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>act_ge_bytearray</td><td>二进制数据表</td></tr><tr><td>2</td><td>act_ge_property</td><td>属性数据表存储整个流程引擎级别的数据,初始化表结构时，会默认插入三条记录，</td></tr><tr><td>3</td><td>act_hi_actinst</td><td>历史节点表</td></tr><tr><td>4</td><td>act_hi_attachment</td><td>历史附件表</td></tr><tr><td>5</td><td>act_hi_comment</td><td>历史意见表</td></tr><tr><td>6</td><td>act_hi_identitylink</td><td>历史流程人员表</td></tr><tr><td>7</td><td>act_hi_detail</td><td>历史详情表，提供历史变量的查询</td></tr><tr><td>8</td><td>act_hi_procinst</td><td>历史流程实例表</td></tr><tr><td>9</td><td>act_hi_taskinst</td><td>历史任务实例表</td></tr><tr><td>10</td><td>act_hi_varinst</td><td>历史变量表</td></tr><tr><td>11</td><td>act_id_group</td><td>用户组信息表</td></tr><tr><td>12</td><td>act_id_info</td><td>用户扩展信息表</td></tr><tr><td>13</td><td>act_id_membership</td><td>用户与用户组对应信息表</td></tr><tr><td>14</td><td>act_id_user</td><td>用户信息表</td></tr><tr><td>15</td><td>act_re_deployment</td><td>部署信息表</td></tr><tr><td>16</td><td>act_re_model</td><td>流程设计模型部署表</td></tr><tr><td>17</td><td>act_re_procdef</td><td>流程定义数据表</td></tr><tr><td>18</td><td>act_ru_event_subscr</td><td>throwEvent、catchEvent时间监听信息表</td></tr><tr><td>19</td><td>act_ru_execution</td><td>运行时流程执行实例表</td></tr><tr><td>20</td><td>act_ru_identitylink</td><td>运行时流程人员表，主要存储任务节点与参与者的相关信息</td></tr><tr><td>21</td><td>act_ru_job</td><td>运行时定时任务数据表</td></tr><tr><td>22</td><td>act_ru_task</td><td>运行时任务节点表</td></tr><tr><td>23</td><td>act_ru_variable</td><td>运行时流程变量数据表</td></tr></tbody></table><h3 id="23张表详解"><a href="#23张表详解" class="headerlink" title="23张表详解"></a>23张表详解</h3><h4 id="二进制数据表（act-ge-bytearray）"><a href="#二进制数据表（act-ge-bytearray）" class="headerlink" title="二进制数据表（act_ge_bytearray）"></a>二进制数据表（act_ge_bytearray）</h4><p>保存流程定义图片和xml、Serializable(序列化)的变量,即保存所有二进制数据，特别注意类路径部署时候，不要把svn等隐藏文件或者其他与流程无关的文件也一起部署到该表中，会造成一些错误（可能导致流程定义无法删除）</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>Y</td><td></td><td>主键ID</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>Y</td><td>Version(版本)</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td>Y</td><td>部署的文件名称，如：leave.bpmn.png,leave.bpmn20.xml</td></tr><tr><td>DEPLOYMENT_ID_</td><td>部署ID</td><td>nvarchar(64)</td><td></td><td>Y</td><td>部署表ID</td></tr><tr><td>BYTES_</td><td>字节</td><td>varbinary(max)</td><td></td><td>Y</td><td>部署文件</td></tr><tr><td>GENERATED_</td><td>是否是引擎生成</td><td>tinyint</td><td></td><td>Y</td><td>0为用户生成，1为activiti生成</td></tr></tbody></table><h4 id="属性数据表-act-ge-property"><a href="#属性数据表-act-ge-property" class="headerlink" title="属性数据表(act_ge_property)"></a>属性数据表(act_ge_property)</h4><p>属性数据表。存储整个流程引擎级别的数据。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>NAME_</td><td>名称</td><td>nvarchar(64)</td><td>√</td><td></td><td>schema.versionschema.historynext.dbid</td></tr><tr><td>VALUE_</td><td>值</td><td>nvarchar(300)</td><td></td><td>√</td><td>5.<em>create(5.</em>)</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>version</td></tr></tbody></table><h4 id="历史节点表（act-hi-actinst）"><a href="#历史节点表（act-hi-actinst）" class="headerlink" title="历史节点表（act_hi_actinst）"></a>历史节点表（act_hi_actinst）</h4><p>历史活动信息。这里记录流程流转过的所有节点，与HI_TASKINST不同的是，taskinst只记录usertask内容</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td></td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td></td><td></td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td></td><td></td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td></td><td></td></tr><tr><td>ACT_ID_</td><td>节点ID</td><td>nvarchar(225)</td><td></td><td></td><td>节点定义ID</td></tr><tr><td>TASK_ID_</td><td>任务实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>任务实例ID 其他节点类型实例ID在这里为空</td></tr><tr><td>CALL_PROC_INST_ID_</td><td>调用外部的流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>调用外部流程的流程实例ID’</td></tr><tr><td>ACT_NAME_</td><td>节点名称</td><td>nvarchar(225)</td><td></td><td>√</td><td>节点定义名称</td></tr><tr><td>ACT_TYPE_</td><td>节点类型</td><td>nvarchar(225)</td><td></td><td></td><td>如startEvent、userTask</td></tr><tr><td>ASSIGNEE_</td><td>签收人</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点签收人</td></tr><tr><td>START_TIME_</td><td>开始时间</td><td>datetime</td><td></td><td></td><td>2013-09-15 11:30:00</td></tr><tr><td>END_TIME_</td><td>结束时间</td><td>datetime</td><td></td><td>√</td><td>2013-09-15 11:30:00</td></tr><tr><td>DURATION_</td><td>耗时</td><td>numeric(19,0)</td><td></td><td>√</td><td>毫秒值</td></tr></tbody></table><h4 id="历史附件表-act-hi-attachment"><a href="#历史附件表-act-hi-attachment" class="headerlink" title="历史附件表( act_hi_attachment )"></a>历史附件表( act_hi_attachment )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>REV_</td><td>乐观锁</td><td>integer</td><td></td><td>√</td><td>Version</td></tr><tr><td>USER_ID_</td><td>用户ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>用户ID</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>附件名称</td></tr><tr><td>DESCRIPTION_</td><td>描述</td><td>nvarchar(4000)</td><td></td><td>√</td><td>描述</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>附件类型</td></tr><tr><td>TASK_ID_</td><td>任务实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>URL_</td><td>URL_</td><td>nvarchar(4000)</td><td></td><td>√</td><td>附件地址</td></tr><tr><td>CONTENT_ID_</td><td>字节表的ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>ACT_GE_BYTEARRAY的ID</td></tr></tbody></table><h4 id="历史意见表-act-hi-comment"><a href="#历史意见表-act-hi-comment" class="headerlink" title="历史意见表( act_hi_comment )"></a>历史意见表( act_hi_comment )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>类型：event（事件）comment（意见）</td></tr><tr><td>TIME_</td><td>时间</td><td>datetime</td><td></td><td></td><td>填写时间’</td></tr><tr><td>USER_ID_</td><td>用户ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>填写人</td></tr><tr><td>TASK_ID_</td><td>节点任务ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>ACTION_</td><td>行为类型</td><td>nvarchar(64)</td><td></td><td>√</td><td>见备注1</td></tr><tr><td>MESSAGE_</td><td>基本内容</td><td>nvarchar(4000)</td><td></td><td>√</td><td>用于存放流程产生的信息，比如审批意见</td></tr><tr><td>FULL_MSG_</td><td>全部内容</td><td>varbinary(max)</td><td></td><td>√</td><td>附件地址</td></tr></tbody></table><h4 id="历史详情表-act-hi-detail"><a href="#历史详情表-act-hi-detail" class="headerlink" title="历史详情表( act_hi_detail )"></a>历史详情表( act_hi_detail )</h4><p>流程中产生的变量详细，包括控制流程流转的变量，业务表单中填写的流程需要用到的变量等。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td></td><td>见备注2</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>TASK_ID_</td><td>任务实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>任务实例ID</td></tr><tr><td>ACT_INST_ID_</td><td>节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>ACT_HI_ACTINST表的ID</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td></td><td>名称</td></tr><tr><td>VAR_TYPE_</td><td>参数类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>见备注3</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>Version</td></tr><tr><td>TIME_</td><td>时间戳</td><td>datetime</td><td></td><td></td><td>创建时间</td></tr><tr><td>BYTEARRAY_ID_</td><td>字节表ID</td><td>nvarchar</td><td></td><td>√</td><td>ACT_GE_BYTEARRAY表的ID</td></tr><tr><td>DOUBLE_</td><td>DOUBLE_</td><td>double precision</td><td></td><td>√</td><td>存储变量类型为Double</td></tr><tr><td>LONG_</td><td>LONG_</td><td>numeric</td><td></td><td>√</td><td>存储变量类型为long</td></tr><tr><td>TEXT_</td><td>TEXT_</td><td>nvarchar</td><td></td><td>√</td><td>存储变量值类型为String</td></tr><tr><td>TEXT2_</td><td>TEXT2_</td><td>nvarchar</td><td></td><td>√</td><td>此处存储的是JPA持久化对象时，才会有值。此值为对象ID</td></tr></tbody></table><h4 id="历史流程人员表-act-ru-identitylink"><a href="#历史流程人员表-act-ru-identitylink" class="headerlink" title="历史流程人员表( act_ru_identitylink )"></a>历史流程人员表( act_ru_identitylink )</h4><p>任务参与者数据表。主要存储历史节点参与者的信息</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>GROUP_ID_</td><td>组ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>组ID</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>备注4</td></tr><tr><td>USER_ID_</td><td>用户ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>用户ID</td></tr><tr><td>TASK_ID_</td><td>节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr></tbody></table><h4 id="历史流程实例表（act-hi-procinst）"><a href="#历史流程实例表（act-hi-procinst）" class="headerlink" title="历史流程实例表（act_hi_procinst）"></a>历史流程实例表（act_hi_procinst）</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td></td><td>流程实例ID</td></tr><tr><td>BUSINESS_KEY_</td><td>业务主键</td><td>nvarchar(255)</td><td></td><td>√</td><td>业务主键，业务表单的ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td></td><td>流程定义ID</td></tr><tr><td>START_TIME_</td><td>开始时间</td><td>datetime</td><td></td><td></td><td>开始时间</td></tr><tr><td>END_TIME_</td><td>结束时间</td><td>datetime</td><td></td><td>√</td><td>结束时间</td></tr><tr><td>DURATION_</td><td>耗时</td><td>Numeric(19)</td><td></td><td>√</td><td>耗时</td></tr><tr><td>START_USER_ID_</td><td>起草人</td><td>nvarchar(255)</td><td></td><td>√</td><td>起草人</td></tr><tr><td>START_ACT_ID_</td><td>开始节点ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>起草环节ID</td></tr><tr><td>END_ACT_ID_</td><td>结束节点ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>结束环节ID</td></tr><tr><td>SUPER_PROCESS_INSTANCE_ID_</td><td>父流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>父流程实例ID</td></tr><tr><td>DELETE_REASON_</td><td>删除原因</td><td>nvarchar(4000)</td><td></td><td>√</td><td>删除原因</td></tr></tbody></table><h4 id="历史任务实例表-act-hi-taskinst"><a href="#历史任务实例表-act-hi-taskinst" class="headerlink" title="历史任务实例表( act_hi_taskinst )"></a>历史任务实例表( act_hi_taskinst )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程定义ID</td></tr><tr><td>TASK_DEF_KEY_</td><td>节点定义ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>节点定义ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>NAME_</td><td>名称</td><td>varchar(255)</td><td></td><td>√</td><td>名称</td></tr><tr><td>PARENT_TASK_ID_</td><td>父节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>父节点实例ID</td></tr><tr><td>DESCRIPTION_</td><td>描述</td><td>nvarchar(400)</td><td></td><td>√</td><td>描述</td></tr><tr><td>OWNER_</td><td>实际签收人 任务的拥有者</td><td>nvarchar(255)</td><td></td><td>√</td><td>签收人（默认为空，只有在委托时才有值）</td></tr><tr><td>ASSIGNEE_</td><td>签收人或被委托</td><td>nvarchar(255)</td><td></td><td>√</td><td>签收人或被委托</td></tr><tr><td>START_TIME_</td><td>开始时间</td><td>datetime</td><td></td><td></td><td>开始时间</td></tr><tr><td>CLAIM_TIME_</td><td>提醒时间</td><td>datetime</td><td></td><td>√</td><td>提醒时间</td></tr><tr><td>END_TIME_</td><td>结束时间</td><td>datetime</td><td></td><td>√</td><td>结束时间</td></tr><tr><td>DURATION_</td><td>耗时</td><td>numeric(19)</td><td></td><td>√</td><td>耗时</td></tr><tr><td>DELETE_REASON_</td><td>删除原因</td><td>nvarchar(4000)</td><td></td><td>√</td><td>删除原因(completed,deleted)</td></tr><tr><td>PRIORITY_</td><td>优先级别</td><td>int</td><td></td><td>√</td><td>优先级别</td></tr><tr><td>DUE_DATE_</td><td>过期时间</td><td>datetime</td><td></td><td>√</td><td>过期时间，表明任务应在多长时间内完成</td></tr><tr><td>FORM_KEY_</td><td>节点定义的formkey</td><td>nvarchar(255)</td><td></td><td>√</td><td>desinger节点定义的form_key属性</td></tr></tbody></table><h4 id="历史变量表-act-hi-varinst"><a href="#历史变量表-act-hi-varinst" class="headerlink" title="历史变量表( act_hi_varinst )"></a>历史变量表( act_hi_varinst )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>TASK_ID_</td><td>任务实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>任务实例ID</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(64)</td><td></td><td></td><td>参数名称(英文)</td></tr><tr><td>VAR_TYPE_</td><td>参数类型</td><td>varchar(255)</td><td></td><td>√</td><td>备注5</td></tr><tr><td>REV_</td><td>乐观锁</td><td>nvarchar(64)</td><td></td><td>√</td><td>乐观锁 Version</td></tr><tr><td>BYTEARRAY_ID_</td><td>字节表ID</td><td>nvarchar(400)</td><td></td><td>√</td><td>ACT_GE_BYTEARRAY表的主键</td></tr><tr><td>DOUBLE_</td><td>DOUBLE_</td><td>nvarchar(255)</td><td></td><td>√</td><td>存储DoubleType类型的数据</td></tr><tr><td>LONG_</td><td>LONG_</td><td>nvarchar(255)</td><td></td><td>√</td><td>存储LongType类型的数据</td></tr><tr><td>TEXT_</td><td>TEXT_</td><td>datetime</td><td></td><td>√</td><td>备注6</td></tr><tr><td>TEXT2_</td><td>TEXT2_</td><td>datetime</td><td></td><td>√</td><td>此处存储的是JPA持久化对象时，才会有值。此值为对象ID</td></tr></tbody></table><h4 id="用户组信息表-act-id-group"><a href="#用户组信息表-act-id-group" class="headerlink" title="用户组信息表( act_id_group )"></a>用户组信息表( act_id_group )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁Version</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>组名称</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>类型</td></tr></tbody></table><h4 id="用户扩展信息表-act-id-info"><a href="#用户扩展信息表-act-id-info" class="headerlink" title="用户扩展信息表( act_id_info )"></a>用户扩展信息表( act_id_info )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁Version</td></tr><tr><td>USER_ID_</td><td>用户ID</td><td>nvarchar(64)</td><td></td><td>√</td><td></td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(64)</td><td></td><td>√</td><td></td></tr><tr><td>KEY_</td><td></td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>VALUE_</td><td></td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>PASSWORD_</td><td></td><td>Image</td><td></td><td>√</td><td></td></tr><tr><td>PARENT_ID_</td><td></td><td>nvarchar(255)</td><td></td><td>√</td></tr></tbody></table><h4 id="用户与分组对应信息表-act-id-membership"><a href="#用户与分组对应信息表-act-id-membership" class="headerlink" title="用户与分组对应信息表( act_id_membership )"></a>用户与分组对应信息表( act_id_membership )</h4><p>用来保存用户的分组信息。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>USER_ID</td><td>用户ID</td><td>nvarchar(64)</td><td>√</td><td></td><td></td></tr><tr><td>GROUP_ID</td><td>用户组ID</td><td>nvarchar(64)</td><td>√</td><td></td></tr></tbody></table><h4 id="用户信息表-act-id-user"><a href="#用户信息表-act-id-user" class="headerlink" title="用户信息表( act_id_user )"></a>用户信息表( act_id_user )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁Version</td></tr><tr><td>FIRST_</td><td>姓</td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>LAST_</td><td>名</td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>EMAIL_</td><td>EMAIL_</td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>PWD_</td><td>密码</td><td>nvarchar(255)</td><td></td><td>√</td><td></td></tr><tr><td>PICTURE_ID_</td><td>图片ID</td><td>nvarchar(64)</td><td></td><td>√</td></tr></tbody></table><h4 id="部署信息表-act-re-deployment"><a href="#部署信息表-act-re-deployment" class="headerlink" title="部署信息表( act_re_deployment )"></a>部署信息表( act_re_deployment )</h4><p>部署流程定义时需要被持久化保存下来的信息。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键ID</td></tr><tr><td>NAME_</td><td>部署名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>部署文件名</td></tr><tr><td>CATEGORY_</td><td>分类</td><td>nvarchar(255)</td><td></td><td>√</td><td>类别</td></tr><tr><td>DEPLOY_TIME_</td><td>部署时间</td><td>datetime</td><td></td><td>√</td><td>部署时间</td></tr></tbody></table><h4 id="流程设计模型部署表-act-re-model"><a href="#流程设计模型部署表-act-re-model" class="headerlink" title="流程设计模型部署表( act_re_model )"></a>流程设计模型部署表( act_re_model )</h4><p>流程设计器设计流程后，保存数据到该表。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>名称</td></tr><tr><td>KEY_</td><td>KEY_</td><td>nvarchar(255)</td><td></td><td>√</td><td>分类，例如：<a href="http://www.mossle.com/docs/activiti/" target="_blank" rel="noopener">http://www.mossle.com/docs/activiti/</a></td></tr><tr><td>CATEGORY_</td><td>分类</td><td>nvarchar(255)</td><td></td><td>√</td><td>分类</td></tr><tr><td>CREATE_TIME_</td><td>创建时间</td><td>datetime</td><td></td><td>√</td><td>创建时间</td></tr><tr><td>LAST_UPDATE_TIME_</td><td>最新修改时间</td><td>datetime</td><td></td><td>√</td><td>最新修改时间</td></tr><tr><td>VERSION_</td><td>版本</td><td>int</td><td></td><td>√</td><td>版本</td></tr><tr><td>META_INFO_</td><td>META_INFO_</td><td>nvarchar(255)</td><td></td><td>√</td><td>以json格式保存流程定义的信息</td></tr><tr><td>DEPLOYMENT_ID_</td><td>部署ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>部署ID</td></tr><tr><td>EDITOR_SOURCE_VALUE_ID_</td><td></td><td>datetime</td><td></td><td>√</td><td></td></tr><tr><td>EDITOR_SOURCE_EXTRA_VALUE_ID_</td><td></td><td>datetime</td><td></td><td>√</td></tr></tbody></table><h4 id="流程定义数据表-act-re-procdef"><a href="#流程定义数据表-act-re-procdef" class="headerlink" title="流程定义数据表( act_re_procdef )"></a>流程定义数据表( act_re_procdef )</h4><p>业务流程定义数据表。此表和ACT_RE_DEPLOYMENT是多对一的关系，即，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在ACT_REPROCDEF表内，每个流程定义的数据，都会对于ACT_GE_BYTEARRAY表内的一个资源文件和PNG图片文件。和ACT_GE_BYTEARRAY的关联是通过程序用ACT_GE_BYTEARRAY.NAME与ACT_RE_PROCDEF.NAME_完成的，在数据库表结构中没有体现。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>CATEGORY_</td><td>分类</td><td>nvarchar(255)</td><td></td><td>√</td><td>流程定义的Namespace就是类别</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>名称</td></tr><tr><td>KEY_</td><td>定义的KEY</td><td>nvarchar(255)</td><td></td><td></td><td>流程定义ID</td></tr><tr><td>VERSION_</td><td>版本</td><td>int</td><td></td><td></td><td>版本</td></tr><tr><td>DEPLOYMENT_ID_</td><td>部署表ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>部署表ID</td></tr><tr><td>RESOURCE_NAME_</td><td>bpmn文件名称</td><td>nvarchar(4000)</td><td></td><td>√</td><td>流程bpmn文件名称</td></tr><tr><td>DGRM_RESOURCE_NAME_</td><td>png图片名称</td><td>nvarchar(4000)</td><td></td><td>√</td><td>流程图片名称</td></tr><tr><td>DESCRIPTION_</td><td>描述</td><td>nvarchar(4000)</td><td></td><td>√</td><td>描述</td></tr><tr><td>HAS_START_FORM_KEY_</td><td>是否存在开始节点formKey</td><td>tinyint</td><td></td><td>√</td><td>start节点是否存在formKey 0否  1是</td></tr><tr><td>SUSPENSION_STATE_</td><td>是否挂起</td><td>tinyint</td><td></td><td>√</td><td>1 激活 2挂起</td></tr></tbody></table><h4 id="act-ru-event-subscr"><a href="#act-ru-event-subscr" class="headerlink" title="act_ru_event_subscr"></a>act_ru_event_subscr</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>事件ID</td><td>nvarchar(64)</td><td>√</td><td></td><td>事件ID</td></tr><tr><td>REV_</td><td>版本</td><td>int</td><td></td><td>√</td><td>乐观锁Version</td></tr><tr><td>EVENT_TYPE_</td><td>事件类型</td><td>nvarchar(255)</td><td></td><td></td><td>事件类型</td></tr><tr><td>EVENT_NAME_</td><td>事件名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>事件名称</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>ACTIVITY_ID_</td><td>活动实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>活动实例ID</td></tr><tr><td>CONFIGURATION_</td><td>配置</td><td>nvarchar(255)</td><td></td><td>√</td><td>配置</td></tr><tr><td>CREATED_</td><td>是否创建</td><td>datetime</td><td></td><td></td><td>默认值 当前系统时间戳CURRENT_TIMESTAMP</td></tr></tbody></table><h4 id="运行时流程执行实例表-act-ru-execution"><a href="#运行时流程执行实例表-act-ru-execution" class="headerlink" title="运行时流程执行实例表( act_ru_execution )"></a>运行时流程执行实例表( act_ru_execution )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td></td><td>流程实例ID</td></tr><tr><td>BUSINESS_KEY_</td><td>业务主键ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>业务主键ID</td></tr><tr><td>PARENT_ID_</td><td>父节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>父节点实例ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程定义ID</td></tr><tr><td>SUPER_EXEC_</td><td>SUPER_EXEC_</td><td>nvarchar(64)</td><td></td><td>√</td><td>SUPER_EXEC_</td></tr><tr><td>ACT_ID_</td><td>节点实例ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>节点实例ID即ACT_HI_ACTINST中ID</td></tr><tr><td>IS_ACTIVE_</td><td>是否存活</td><td>tinyint</td><td></td><td>√</td><td>是否存活</td></tr><tr><td>IS_CONCURRENT_</td><td>是否并行</td><td>tinyint</td><td></td><td>√</td><td>是否为并行(true/false）</td></tr><tr><td>IS_SCOPE_</td><td>IS_SCOPE_</td><td>tinyint</td><td></td><td>√</td><td>IS_SCOPE_</td></tr><tr><td>IS_EVENT_SCOPE_</td><td>IS_EVENT_SCOPE_</td><td>tinyint</td><td></td><td>√</td><td>IS_EVENT_SCOPE_</td></tr><tr><td>SUSPENSION_STATE_</td><td>是否挂起</td><td>tinyint</td><td></td><td>√</td><td>挂起状态   1激活 2挂起</td></tr><tr><td>CACHED_ENT_STATE_</td><td></td><td>int</td><td></td><td>√</td></tr></tbody></table><h4 id="运行时流程人员表-act-ru-identitylink"><a href="#运行时流程人员表-act-ru-identitylink" class="headerlink" title="运行时流程人员表( act_ru_identitylink )"></a>运行时流程人员表( act_ru_identitylink )</h4><p>任务参与者数据表。主要存储当前节点参与者的信息。</p><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>GROUP_ID_</td><td>组ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>组ID</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>备注7</td></tr><tr><td>USER_ID_</td><td>用户ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>用户ID</td></tr><tr><td>TASK_ID_</td><td>节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(255)</td><td></td><td>√</td><td>流程定义ID</td></tr></tbody></table><h4 id="运行时定时任务数据表-act-ru-job"><a href="#运行时定时任务数据表-act-ru-job" class="headerlink" title="运行时定时任务数据表( act_ru_job )"></a>运行时定时任务数据表( act_ru_job )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>标识</td><td>nvarchar(64)</td><td>√</td><td></td><td>标识</td></tr><tr><td>REV_</td><td>版本</td><td>int</td><td></td><td>√</td><td>版本</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td></td><td>类型</td></tr><tr><td>LOCK_EXP_TIME_</td><td>锁定释放时间</td><td>datetime</td><td></td><td>√</td><td>锁定释放时间</td></tr><tr><td>LOCK_OWNER_</td><td>挂起者</td><td>nvarchar(255)</td><td></td><td>√</td><td>挂起者</td></tr><tr><td>EXCLUSIVE_</td><td></td><td>bit</td><td></td><td>√</td><td></td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>PROCESS_INSTANCE_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程定义ID</td></tr><tr><td>RETRIES_</td><td></td><td>int</td><td></td><td>√</td><td></td></tr><tr><td>EXCEPTION_STACK_ID_</td><td>异常信息ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>异常信息ID</td></tr><tr><td>EXCEPTION_MSG_</td><td>异常信息</td><td>nvarchar(4000)</td><td></td><td>√</td><td>异常信息</td></tr><tr><td>DUEDATE_</td><td>到期时间</td><td>datetime</td><td></td><td>√</td><td>到期时间</td></tr><tr><td>REPEAT_</td><td>重复</td><td>nvarchar(255)</td><td></td><td>√</td><td>重复</td></tr><tr><td>HANDLER_TYPE_</td><td>处理类型</td><td>nvarchar(255)</td><td></td><td>√</td><td>处理类型</td></tr><tr><td>HANDLER_CFG_</td><td></td><td>nvarchar(4000)</td><td></td><td>√</td><td>标识</td></tr></tbody></table><h4 id="运行时任务节点表-act-ru-task"><a href="#运行时任务节点表-act-ru-task" class="headerlink" title="运行时任务节点表( act_ru_task )"></a>运行时任务节点表( act_ru_task )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>ID_</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行实例ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>PROC_DEF_ID_</td><td>流程定义ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程定义ID</td></tr><tr><td>NAME_</td><td>节点定义名称</td><td>nvarchar(255)</td><td></td><td>√</td><td>节点定义名称</td></tr><tr><td>PARENT_TASK_ID_</td><td>父节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>父节点实例ID</td></tr><tr><td>DESCRIPTION_</td><td>节点定义描述</td><td>nvarchar(4000)</td><td></td><td>√</td><td>节点定义描述</td></tr><tr><td>TASK_DEF_KEY_</td><td>节点定义的KEY</td><td>nvarchar(255)</td><td></td><td>√</td><td>任务定义的ID</td></tr><tr><td>OWNER_</td><td>实际签收人</td><td>nvarchar(255)</td><td></td><td>√</td><td>拥有者（一般情况下为空，只有在委托时才有值）</td></tr><tr><td>ASSIGNEE_</td><td>签收人或委托人</td><td>nvarchar(255)</td><td></td><td>√</td><td>签收人或委托人</td></tr><tr><td>DELEGATION_</td><td>委托类型</td><td>nvarchar(64)</td><td></td><td>√</td><td>备注8</td></tr><tr><td>PRIORITY_</td><td>优先级别</td><td>int</td><td></td><td>√</td><td>优先级别，默认为：50</td></tr><tr><td>CREATE_TIME_</td><td>创建时间</td><td>datetime</td><td></td><td>√</td><td>创建时间</td></tr><tr><td>DUE_DATE_</td><td>过期时间</td><td>datetime</td><td></td><td>√</td><td>耗时</td></tr><tr><td>SUSPENSION_STATE_</td><td>是否挂起</td><td>int</td><td></td><td>√</td><td>1代表激活 2代表挂起</td></tr></tbody></table><h4 id="运行时流程变量数据表-act-ru-variable"><a href="#运行时流程变量数据表-act-ru-variable" class="headerlink" title="运行时流程变量数据表( act_ru_variable )"></a>运行时流程变量数据表( act_ru_variable )</h4><table><thead><tr><th>字段名称</th><th>字段描述</th><th>数据类型</th><th>主键</th><th>为空</th><th>取值说明</th></tr></thead><tbody><tr><td>ID_</td><td>ID_</td><td>nvarchar(64)</td><td>√</td><td></td><td>主键标识</td></tr><tr><td>REV_</td><td>乐观锁</td><td>int</td><td></td><td>√</td><td>乐观锁</td></tr><tr><td>TYPE_</td><td>类型</td><td>nvarchar(255)</td><td></td><td></td><td>备注9</td></tr><tr><td>NAME_</td><td>名称</td><td>nvarchar(255)</td><td></td><td></td><td>变量名称</td></tr><tr><td>EXECUTION_ID_</td><td>执行实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>执行的ID</td></tr><tr><td>PROC_INST_ID_</td><td>流程实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>流程实例ID</td></tr><tr><td>TASK_ID_</td><td>节点实例ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>节点实例ID(Local）</td></tr><tr><td>BYTEARRAY_ID_</td><td>字节表ID</td><td>nvarchar(64)</td><td></td><td>√</td><td>字节表的ID（ACT_GE_BYTEARRAY）</td></tr><tr><td>DOUBLE_</td><td>DOUBLE_</td><td>float</td><td></td><td>√</td><td>存储变量类型为Double</td></tr><tr><td>LONG_</td><td>LONG_</td><td>numeric(19)</td><td></td><td>√</td><td>存储变量类型为long</td></tr><tr><td>TEXT_</td><td>TEXT_</td><td>nvarchar(4000)</td><td></td><td>√</td><td>‘存储变量值类型为String   如此处存储持久化对象时，值jpa对象的class</td></tr><tr><td>TEXT2_</td><td>TEXT2_</td><td>nvarchar(4000)</td><td></td><td>√</td><td>此处存储的是JPA持久化对象时，才会有值。此值为对象ID</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Activiti 23张表及7大服务详解
    
    </summary>
    
      <category term="工作流" scheme="/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
    
      <category term="工作流" scheme="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析之启动流程分析</title>
    <link href="/2018/03/21/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>/2018/03/21/Tomcat源码分析之启动流程分析/</id>
    <published>2018-03-21T15:43:07.000Z</published>
    <updated>2018-10-26T07:24:49.895Z</updated>
    
    <content type="html"><![CDATA[<p>前面的博客介绍了Tomcat的整个架构及各个配置文件及目录的作用，接下来就对Tomcat的源码进行分析了。<a id="more"></a></p><h3 id="Tomcat源码调试环境准备"><a href="#Tomcat源码调试环境准备" class="headerlink" title="Tomcat源码调试环境准备"></a>Tomcat源码调试环境准备</h3><p>首先下载Tomcat源码，读者可自行去<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat官网</a> 下载，若执行力差的同学也可直接从<a href="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src.git" target="_blank" rel="noopener">此处</a>pull。</p><p>Tomcat源码导入到开发工具中的方法有多种，笔者采用最直接的方式，解压源码包后直接导入到开发工具中，导入之后的源码并不能直接运行，还需要几个依赖包，读者可从<a href="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src.git" target="_blank" rel="noopener">此处</a>的lib目录下获取，也可自行搜集。</p><p>找好依赖包也并不能让Tomcat源码正常运行，还需要为Bootstrap这个启动类增加几个启动参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home=/Users/chenmin/GitHub/tomcat</span><br><span class="line">-Dcatalina.base=/Users/chenmin/GitHub/tomcat</span><br><span class="line">-Djava.endorsed.dirs=/Users/chenmin/GitHub/tomcat/endorsed</span><br><span class="line">-Djava.io.tmpdir=/Users/chenmin/GitHub/tomcat/temp</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file=/Users/chenmin/GitHub/tomcat/conf/logging.properties</span><br></pre></td></tr></table></figure><p>上面的参数具体代表的意思就不一一详述了，其实光看名字就知道都是干嘛用的了。</p><p>以上准备步骤做好之后，就可以直接运行Bootstrap类，运行Tomcat源码进行调试了。</p><h3 id="Tomcat-Server的组成"><a href="#Tomcat-Server的组成" class="headerlink" title="Tomcat Server的组成"></a>Tomcat Server的组成</h3><h4 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h4><p>在上面对配置文件的说明中，通过server.xml的解释，我们知道server.xml中最顶级的元素是server，而server.xml中的每一个元素我们都可以把它看做是Tomcat中的某一个部分。所以我们可以参照着server.xml来分析源码。</p><p>Tomcat最顶层的容器叫Server，它代表着整个Tomcat服务器。Server中至少要包含一个Service来提供服务。Service包含两部分：Connector和Container。Connector负责网络连接，request/response的创建，并对Socket和request、response进行转换等，Container用于封装和管理Servlet，并处理具体的request请求。</p><p>一个Tomcat中只有一个Server，一个Server可以有多个Service来提供服务，一个Service只有一个Container，但是可以有多个Connector（一个服务可以有多个连接）。</p><p><img src="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png?raw=true" alt="tomcat整体结构"></p><h4 id="各组件详解"><a href="#各组件详解" class="headerlink" title="各组件详解"></a>各组件详解</h4><p>可结合conf/配置文件说明中的server.xml的说明来看</p><ul><li><p>Server</p><p>Server代表整个Servlet容器</p></li><li><p>Service</p><p>Service是由一个或多个Connector以及一个Engine，负责处理所有Connector所获得的客户请求的集合。</p></li><li><p>Connector</p><p>Connector将在某个指定端口上侦听客户请求，并将获得的请求交给Engine来处理，从Engine处获得回应并返回给客户端。</p><p>Tomcat有两个默认的Connector，一个直接监听来自浏览器的http请求，一个监听来自其他WebServer的请求。</p><p>Coyote Http/1.1 Connector在端口8080上监听来自浏览器的http请求</p><p>Coyote AJP/1.3 Connector在端口8009上监听来自其他WebServer的servlet/jsp代理请求。</p></li><li><p>Engine</p><p>Engine下可以配置多个虚拟主机，每个虚拟主机都有一个域名，当Engine获得一个请求时，Engine会把该请求匹配到某个Host上，然后把该请求交给该Host来处理。</p><p>Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。</p></li><li><p>Host</p><p>代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配。每个虚拟主机下都可以部署一个或者多个WebApp，每个WebApp对应于一个Context，有一个ContextPath。当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。匹配的方法是“最长匹配”，所以一个path==“”的Context将成为该Host的默认Context，所有无法和其他Context的路径名匹配的请求都将最终和该默认Context匹配。</p></li><li><p>Context</p><p>一个Context对应于一个Web Application（Web应用），一个Web应用有一个或多个Servlet组成，Context在创建的时候将根据配置文件\$CATALINA_HOME/conf/web.xml和\$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。如果找到，则执行该类，获得请求的回应，并返回。</p><p>Tomcat各组件关系图(此图来此网上)</p><p><img src="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat-startup.gif?raw=true" alt="QQ截图20170913174040"></p></li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="启动总体流程"><a href="#启动总体流程" class="headerlink" title="启动总体流程"></a>启动总体流程</h4><p>Tomcat里的Server由org.apache.catalina.startup.Catalina来管理，Catalina是整个Tomcat的管理类，它里面的三个方法load，start，stop分别用来管理整个服务器的生命周期，load方法用于根据conf/server.xml文件创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器，start和stop方法在内部分别调用了Server的start和stop方法，load方法内部调用了Server的init方法，这三个方法都会按容器的结构逐层调用相应的方法，比如，Server的start方法中会调用所有的Service中的start方法，Service中的start方法又会调用所有的Service中的start方法，Service中的start方法又会调用所有包含的Connectors和Container的start方法，这样这个服务器就启动了，init和stop方法也一样，这就是整个Tomcat的生命周期的管理方式。Catalina还有个await方法，await方法直接调用了Server的await方法，这个方法的作用是进入一个循环，让主线程不退出。</p><p>Tomcat的启动入口上面说过，是org.apache.catalina.startup.Bootstrap，作用类似于一个CatalinaAdaptor，具体的处理过程还是使用Catalina来完成的，这么做的好处是可以把启动的入口和具体的管理类分开，从而可以很方便的创建出多种启动方式，每种启动方式只需要写一个相应的CatalinaAdaptor就可以了。</p><p><img src="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png?raw=true" alt="tomcat启动流程分析"></p><p><em>注：</em>图片比较模糊，如需查看清晰图片，请自行下载resources/images目录中的<strong>tomcat启动流程分析.png</strong> 或 resources/docs中的<strong>Tomcat源码分析.mdl</strong> ，使用Rational Rose等工具打开即可。</p><h4 id="启动流程详解"><a href="#启动流程详解" class="headerlink" title="启动流程详解"></a>启动流程详解</h4><p>正常情况下启动Tomcat，就是调用Bootstrap的main方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Don't set daemon until init() has completed</span></span><br><span class="line">            <span class="comment">// 初始化了ClassLoader，并用ClassLoader创建了Catalina实例，赋给catalinaDaemon变量</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bootstrap.init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleThrowable(t);</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            daemon = bootstrap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">            <span class="comment">// thread so make sure the correct class loader is used to prevent</span></span><br><span class="line">            <span class="comment">// a range of class not found exceptions.</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">"start"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">"startd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"start"</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stopd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"stop"</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"configtest"</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span>==daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"Bootstrap: command \""</span> + command + <span class="string">"\" does not exist."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main方法中，首先执行init方法初始化了Tomcat自己的类加载器，并通过类加载器创建Catalina实例，然后赋给catalinaDaemon变量，后续操作都使用catalinaDaemon来执行。</p><p>后面默认执行start命令，将调用setAwait(true)，load(args)和start()这三个方法，这三个方法内部都通过反射调用了Catalina的相应方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    await = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setAwait方法用于设置Server启动完成后是否进入等待状态的标志，如果为true则进入，否则不进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Start a new server instance.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file = configFile();</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"catalina.configFail"</span>, file), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don't bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">"server-embed.xml"</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource(getClass().getClassLoader().getResource(<span class="string">"server-embed.xml"</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,<span class="string">"server-embed.xml"</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span> || inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,getConfigFile() + <span class="string">"] or [server-embed.xml]"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">"Permissions incorrect, read permission is not allowed on the file."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> + spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">  getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">  getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line">  <span class="comment">// Stream redirection</span></span><br><span class="line">  initStreams();</span><br><span class="line">  <span class="comment">// Start the new server</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    getServer().init();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"Catalina.start"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">  <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">    log.info(<span class="string">"Initialization processed in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Catalina的load方法根据conf/server.xml创建了Server对象，并赋值给server属性（具体是通过开源项目Digester完成的），然后调用了server的init方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.startup.Catalina</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">load();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(<span class="string">"Cannot start server. Server instance is not configured."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(<span class="string">"Server startup in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register shutdown hook</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先判断Server是否已经存在了，如果不存在则调用load方法来初始化Server，然后调用Server的start方法来启动服务器，最后注册了关闭钩子并根据await属性判断是否进入等待状态，之前我们已经将这里的await属性设置为true，所以需要进入等待状态。进入等待状态会调用await和stop两个方法，await方法会直接调用Server的await方法，Server的await方法内部会执行一个while循环，这样程序就停到了await方法，当await方法里的while循环退出时，就会执行stop方法，从而关闭服务器。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.core.StandardServer</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Negative values - don't wait on port - tomcat is embedded or we just don't like ports</span></span><br><span class="line">    <span class="keyword">if</span>( port == -<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="comment">// undocumented yet - for embedding apps that are around, alive.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( port==-<span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            awaitThread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">while</span>(!stopAwait) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep( <span class="number">10000</span> );</span><br><span class="line">                &#125; <span class="keyword">catch</span>( InterruptedException ex ) &#123;</span><br><span class="line">                    <span class="comment">// continue and check the flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitThread = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set up a server socket to wait on</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        awaitSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>,InetAddress.getByName(address));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"StandardServer.await: create["</span> + address+ <span class="string">":"</span> + port+ <span class="string">"]: "</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        awaitThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// Loop waiting for a connection and a valid command</span></span><br><span class="line">        <span class="keyword">while</span> (!stopAwait) &#123;</span><br><span class="line">            ServerSocket serverSocket = awaitSocket;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Wait for the next connection</span></span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder command = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream stream;</span><br><span class="line">                <span class="keyword">long</span> acceptStartTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    socket.setSoTimeout(<span class="number">10</span> * <span class="number">1000</span>);  <span class="comment">// Ten seconds</span></span><br><span class="line">                    stream = socket.getInputStream();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException ste) &#123;</span><br><span class="line">                    <span class="comment">// This should never happen but bug 56684 suggests that</span></span><br><span class="line">                    <span class="comment">// it does.</span></span><br><span class="line">                    log.warn(sm.getString(<span class="string">"standardServer.accept.timeout"</span>,</span><br><span class="line">                                Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AccessControlException ace) &#123;</span><br><span class="line">                    log.warn(<span class="string">"StandardServer.accept security exception: "</span> + ace.getMessage(), ace);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stopAwait) &#123;</span><br><span class="line">                        <span class="comment">// Wait was aborted with socket.close()</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.error(<span class="string">"StandardServer.await: accept: "</span>, e);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Read a set of characters from the socket</span></span><br><span class="line">                <span class="keyword">int</span> expected = <span class="number">1024</span>; <span class="comment">// Cut off to avoid DoS attack</span></span><br><span class="line">                <span class="keyword">while</span> (expected &lt; shutdown.length()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (random == <span class="keyword">null</span>)</span><br><span class="line">                        random = <span class="keyword">new</span> Random();</span><br><span class="line">                    expected += (random.nextInt() % <span class="number">1024</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (expected &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ch = stream.read();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"StandardServer.await: read: "</span>, e);</span><br><span class="line">                        ch = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Control character or EOF (-1) terminates loop</span></span><br><span class="line">                    <span class="keyword">if</span> (ch &lt; <span class="number">32</span> || ch == <span class="number">127</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    command.append((<span class="keyword">char</span>) ch);</span><br><span class="line">                    expected--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Close the socket now that we are done with it</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Match against our command string</span></span><br><span class="line">            <span class="keyword">boolean</span> match = command.toString().equals(shutdown);</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;                            </span><br><span class="line">              log.info(sm.getString(<span class="string">"standardServer.shutdownViaPort"</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">                log.warn(<span class="string">"StandardServer.await: Invalid command '"</span> + command.toString() + <span class="string">"' received"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ServerSocket serverSocket = awaitSocket;</span><br><span class="line">        awaitThread = <span class="keyword">null</span>;</span><br><span class="line">        awaitSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Close the server socket and return</span></span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#### </p><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><blockquote><p> <a href="链接：http://pan.baidu.com/s/1o7Zp1Q6 密码：c87j">看透springMvc源代码分析与实践.pdf</a></p></blockquote><h2 id="推荐博客"><a href="#推荐博客" class="headerlink" title="推荐博客"></a>推荐博客</h2><blockquote><p><a href="http://www.jianshu.com/p/4cdc422b269b" target="_blank" rel="noopener">解析XML之Digester</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Tomcat源码分析之启动流程分析
    
    </summary>
    
      <category term="Tomcat" scheme="/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat架构介绍及配置分析</title>
    <link href="/2018/03/19/Tomcat%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90/"/>
    <id>/2018/03/19/Tomcat架构介绍及配置分析/</id>
    <published>2018-03-19T15:43:07.000Z</published>
    <updated>2018-10-26T07:35:46.367Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的项目中，需要对项目做集群，由于项目对系统的并发要求不大，所以就采取Session共享方式实现，虽然根据在网上找的资料完成了集群，但是对Tomcat的Session的共享的底层原理一直比较好奇，正好借此机会，调试一下Tomcat源码，略作分析。<a id="more"></a></p><ul><li><p>bin</p><p>存放启动和关闭Tomcat的脚本文件</p></li><li><p>conf</p><p>存放Tomcat的各种配置文件</p></li><li><p>lib</p><p>存放Tomcat的依赖jar包</p></li><li><p>logs</p><p>存放Tomcat的日志文件</p></li><li><p>temp</p><p>存放Tomcat运行中产生的临时文件</p></li><li><p>webapps</p><p>web应用所在目录，即供外界访问的web资源的存放目录</p></li><li><p>work</p><p>Tomcat的工作目录</p></li></ul><h2 id="1-conf-配置文件说明"><a href="#1-conf-配置文件说明" class="headerlink" title="1. conf/配置文件说明"></a>1. conf/配置文件说明</h2><h3 id="1-1-catalina-properties"><a href="#1-1-catalina-properties" class="headerlink" title="1.1 catalina.properties"></a>1.1 catalina.properties</h3><p>Tomcat的catalina.properties文件位于%CATALINA_HOME%/conf/目录下面，该文件主要配置tomcat的安全设置、类加载设置、不需要扫描的类设置、字符缓存设置四大块。</p><ul><li><p>安全设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package.access=sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.</span><br><span class="line">package.definition=sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.</span><br></pre></td></tr></table></figure></li><li><p>类加载设置</p><blockquote><p> tomcat的类加载顺序为：</p></blockquote><p>Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common</p><p>注: Common的配置是通过catalina.properties的commons.loader设置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span><br></pre></td></tr></table></figure><blockquote><p> 类加载顺序：</p></blockquote><p>${catalina.base}/lib  未打包的类和资源文件</p><p>${catalina.base}/lib/*.jar  JAR文件</p><p>${catalina.home}/lib  未打包的类和文件</p><p>${catalina.home}/lib/*.jar  JAR文件</p><blockquote><p> 默认情况下，会加载以下内容：</p></blockquote><ul><li><em>annotations-api.jar</em> — JavaEE注释类</li><li><em>catalina.jar</em> — 执行Tomcat的Catalina Servlet容器部分</li><li><em>catalina-ant.jar</em> — Tomcat Catalina Ant 任务</li><li><em>catalina-ha.jar</em> — 高可用包</li><li><em>catalina-tribes.jar</em> — 组通信包</li><li><em>ecj-\</em>.jar* — Eclipse JDT Java 编译器</li><li><em>el-api.jar</em> — EL 2.2 API.</li><li><em>jasper.jar</em> — JSP 运行时编译器</li><li><em>jasper-el.jar</em> — EL表达式的实现</li><li><em>jsp-api.jar</em> — JSP 2.2 API.</li><li><em>servlet-api.jar</em> — Servlet 3.0 API.</li><li><em>tomcat-api.jar</em> — 由Tomcat定义的几个接口</li><li><em>tomcat-coyote.jar</em> — Tomcat连接器和使用程序类</li><li><em>tomcat-dbcp.jar</em> — 基于Apache Commons Pool和Apache Commons DBCP的数据库连接池</li><li><em>tomcat-i18n-**.jar</em> — 包含其他语言的资源约束的可选JAR，默认捆绑包含在每个单独的应用中，如果不需要国际化，可以删除</li><li><em>tomcat-jdbc.jar</em> — Tomcat JDBC数据库连接池</li><li><em>tomcat-util.jar</em> — Tomcat的各种组件使用的常见类</li><li><em>tomcat7-websocket.jar</em> — WebSocket 1.1 实现</li><li><em>websocket-api.jar</em> — WebSocket 1.1 API</li></ul><p><em>注：</em> CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录，一个Tomcat可以通过配置CATALINA_BASE来增加多个工作目录，也就是增加多个实例。多个实例各自可以有自己的conf，logs，temp，webapps。</p><blockquote><p> server.loader和shared.loader</p></blockquote><p>在common.loader加载完毕后，tomcat启动程序会检查catalina.properties文件中配置的server.loader和shared.loader是否设置。如果设置，读取tomcat下对应的server和shared这两个目录的类库。server和shared是对应tomcat目录下的两个目录，在Tomcat中默认是没有，catalina.properties中默认也是没有设置其值。设置方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.loader=$&#123;catalina.base&#125;/server/classes,$&#123;catalina.base&#125;/server/lib/*.jar</span><br><span class="line">shared.loader=$&#123;catalina.base&#125;/shared/classes,$&#123;catalina.base&#125;/shared/lib/*.jar</span><br></pre></td></tr></table></figure><p>同时需要在tomcat目录下创建server和shared目录结构并将公用的、应用类放到里面。类加载顺序为：</p><p>Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common —&gt; Server —&gt; Shared</p></li><li><p>字符缓存设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># String cache configuration.</span><br><span class="line">tomcat.util.buf.StringCache.byte.enabled=true</span><br><span class="line">#tomcat.util.buf.StringCache.char.enabled=true</span><br><span class="line">#tomcat.util.buf.StringCache.trainThreshold=500000</span><br><span class="line">#tomcat.util.buf.StringCache.cacheSize=5000</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong> Tomcat可以通过catalina.properties的server和shared，为webapp提供公用类库。使一些公用的、不需要与webapp放在一起的设置信息单独保存，在更新webapp的war的时候无需更改webapp的设置。</p><h3 id="1-2-catalina-policy"><a href="#1-2-catalina-policy" class="headerlink" title="1.2 catalina.policy"></a>1.2 catalina.policy</h3><p>包含由Java Security Manager实现的安全策略声明，它替换了安装java时带有的java.policy文件。这个文件用来防止欺骗代码或JSP执行带有像System.exit(0)这样可能影响容器的破坏性代码，只有当Tomcat用-security命令行参数启动时这个文件才会被使用。</p><h3 id="1-3-context-xml"><a href="#1-3-context-xml" class="headerlink" title="1.3 context.xml"></a>1.3 context.xml</h3><p>这个通用context.xml可被所有的web应用程序使用，这个文件默认地可以设置到何处访问各web应用程序中的web.xml文件。context.xml文件的作用和server.xml中<context>标签作用相同。在tomcat5.5之后，对Context的配置不推荐在server.xml中进行配置，而是在/conf/context.xml中进行独立的配置。因为server.xml是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而context.xml文件则不然，tomcat服务器会定时去扫描这个文件。一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器。</context></p><p>默认的context.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>$&#123;catalina.base&#125;/conf/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下给出一个JNDI数据源的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc/mysql"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxActive</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxIdle</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxWait</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">username</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>context.xml的作用范围</p></blockquote><ul><li><p>tomcat server级别</p><p>在/conf/context.xml里配置</p></li><li><p>Host级别</p><p>在/conf/Catalina/${hostName}里添加context.xml，继而进行配置。</p></li><li><p>web app级别</p><p>在/conf/Catalina/\${hostName}里添加\${webappName}.xml，继而进行配置。</p></li></ul><h3 id="1-4-server-xml"><a href="#1-4-server-xml" class="headerlink" title="1.4 server.xml"></a>1.4 server.xml</h3><p>tomcat的主要配置文件，解析器用这个文件在启动时根据规范创建容器。</p><p>默认的server.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Server是顶级元素，代表一个Tomcat实例。可以包含一个或多个Service，每个Service都有自己的Engines和Connectors。</p><blockquote><p>Server元素</p></blockquote><ul><li><p>className</p><p>使用Java实现类的名称。这个类必须实现org.apache.catalina.Server接口。如果没有指定类名，将会使用标准实现。</p></li><li><p>address</p><p>server在这个TCP/IP地址上监听一个shutdown命令。如果没有指定地址，将会使用localhost。</p></li><li><p>port</p><p>server在这个端口上监听一个shutdown命令。设置为-1表示禁用shutdown命令。</p></li><li><p>shutdown</p><p>连接到指定端口的TCP/IP收到这个命令字符后，将会关闭Tomcat。</p></li></ul><blockquote><p>Listeners元素</p></blockquote><p>Server可以包含多个监听器。一个监听器监听指定事件，并对其作出响应。</p><p>GlobalResourcesLifecycleListener作用于全局资源，保证JNDI对资源的可达性，比如数据库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>SSLEngine</p><p>使用的SSLEngine名称。off：不适用<a href="https://baike.baidu.com/item/ssl/320778?fr=aladdin" target="_blank" rel="noopener">SSL</a>，on：使用<a href="https://baike.baidu.com/item/ssl/320778?fr=aladdin" target="_blank" rel="noopener">SSL</a>但不指定引擎。默认值是on。会初始化本地<a href="https://baike.baidu.com/item/ssl/320778?fr=aladdin" target="_blank" rel="noopener">SSL</a>引擎，对于使用SSLEnabled属性的APR/native connector来讲，该选项必须可用。</p></li><li><p>SSLRandomSeed</p><p>指定伪随机数生成器（PRNG）的随机数种子源，默认值为builtin。在开发环境下，可能要将其设置为/dev/urandom，以获得更快的启动速度。</p></li><li><p>FIPSMode</p><p>设置为on会请求OpenSSL进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会保留该模式）。该设置为enter会强制OpenSSl进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会产生一个错误）。设置为require要求OpenSSL已经处于FIPS模式（如果OpenSSL当前没有处于FIPS模式将会产生一个错误）。</p></li></ul><blockquote><p>GlobalNamingResources元素全局命名资源</p></blockquote><p>GlobalNamingResources元素定义了JNDI（Java命名和目录接口）资源，其允许Java软件客户端通过名称搜寻和查找数据。默认配置定义了一个名称为UserDatabase的JNDI，通过“conf/tomcat-users.xml”得到一个用于用户授权的内存数据库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以定义其他全句话JNDI资源来实现连接池，比如MySQL数据库。</p><blockquote><p>Services元素</p></blockquote><p>一个Service可以连接一个或多个Connectors到一个引擎。默认配置定义了一个名为“Catalina”的Service，连接了两个Connectors：HTTP和AJP到当前的引擎。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>className</p><p>该实现使用的Java类名称。这个类必须实现org.apache.catalina.Service接口。如果没有指定类名称，将会使用标准实现。</p></li><li><p>name</p><p>Service的显示名称，如果采用了标准的Catalina组件，将会包含日志信息。每个Service与某个特定的Server关联的名称必须是唯一的。</p></li></ul><blockquote><p>Connectors元素</p></blockquote><p>一个Connector关联一个TCP端口，负责处理Service与客户端之间的交互。默认配置定义了两个Connectors。</p><ul><li><p>HTTP/1.1</p><p>处理HTTP请求，使得Tomcat成为一个HTTP服务器。客户端可以通过Connector向服务器发送HTTP请求，接收服务器端的HTTP响应信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>与生产服务默认使用80端口不同，Tomcat HTTP服务默认在TCP端口8080上运行。可以选择1024到65535之间的任意数字作为端口号来运行Tomcat服务器，前提是该端口没有被任何其他应用使用。connectionTimeOut属性定义了这个connector在链接获得同意之后，获得请求URI line（请求信息）响应的最大等待时间毫秒数。默认为20秒。redirect属性会把<a href="https://baike.baidu.com/item/ssl/320778?fr=aladdin" target="_blank" rel="noopener">SSL</a>请求重定向到TCP的8443端口。</p></li></ul><ul><li><p>AJP/1.3</p><p>Apache JServ Protocol connector处理Tomcat服务器与Apache HTTP服务器之间的交互。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以将Tomcat和Apache HTTP服务运行在一起，Apache HTTP服务器处理静态请求和PHP；Tomcat服务器负责处理Java Servlet/JSP。</p></li></ul><blockquote><p>容器</p></blockquote><p>包含了Engine、Host、Context和Cluster的Tomcat称为容器。最高级的是Engine，最底层的是Context。某些组件，比如Realm和Value，也可以放在容器中。</p><blockquote><p>Engine引擎</p></blockquote><p>引擎是容器中最高级别的部分。可以包含一个或多个Host。Tomcat服务器可以配置为运行在多个主机名上，包括虚拟主机。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Catalina引擎从HTTP connector接收HTTP请求，并根据请求头部信息中主机名或IP地址重定向到正确的主机上。</p><ul><li><p>backgroundProcessorDelay</p><p>这个值表示了在这个引擎和它的子容器上调用backgroundProcess方法之间间隔的秒数，包括所有host和context。值为非负时不会调用子容器（意味着其使用自身的处理线程）。设置为正值会产生一个衍生线程。等待指定的时间之后，该线程会在这个引擎和它的所有子容器上调用backgroundProcess方法。如果没有指定，默认值为10，即会有10秒的延迟。</p></li><li><p>className</p><p>实现该引擎使用的Java类名。该类必须实现org.apache.catalina.Engine接口。如果没有指定，会使用标准值。</p></li><li><p>defaultHost</p><p>默认主机名，定义了处理指向该服务器的请求所在主机的名称，但名称不是在这个文件中配置。</p></li><li><p>jvmRoute</p><p>在负载均衡场景下必须定义该参数，来保证session affinity可用，对于集群中所有Tomcat服务器来讲定义的名称必须是唯一的，该名称将会被添加到生成的会话标示符中，因此，允许前端代理总是将特定会话转发到同一个Tomcat实例。</p></li><li><p>name</p><p>Engine的逻辑名称，用在日志和错误信息中。当在相同的Server中使用多个Service元素时，每个Engine必须制定一个唯一的名称。</p></li><li><p>startStopThreads</p><p>Engine在启动Host子元素时将会并发使用的线程数。如果设置为0，将会使用Runtime.getRuntime().availableProcessors()的值。设置为负数，将会使用Runtime.getRuntime().availableProcessors() + value的值，如果结果小于1，将会使用1个线程。如果没有指定，默认值为1。</p></li></ul><blockquote><p>Realm元素</p></blockquote><p>一个Realm（域）就是一个包含user、password和role认证（比如访问控制）的数据库。你可以在任何容器中定义Realm，例如Engine、Host、Context和Cluster。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认配置定义了一个Catalina Engine的Realm（UserDatabaseRealm），对用户访问engine的权限进行控制。其使用定义在GlobalNamingResources中，名字为UserDatabase的JNDI。</p><p>除了UserDatabaseRealm以外，还有：JDBCRealm（授权用户是否可以通过JDBC驱动连接到关系型数据库）；DataSourceRealm（通过JNDI连接到数据库）；JNDIRealm（连接到一个LDAP目录）；MemoryRealm（将XML文件加载到内存）。</p><ul><li><p>className</p><p>使用Java实现类的名称。这个类必须实现org.apache.catalina.Realm接口。</p></li></ul><blockquote><p>Hosts</p></blockquote><p>一个Host定义了在Engine下的一个虚拟机，反过来其又支持多个Context（web应用）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认配置定义了一个名为localhost的主机。appBase属性定义了所有webapp的根目录，在这种情况下是webapps。默认情况下，每一个webapp的URL和它所在的目录名称相同。例如，默认的Tomcat安装目录的webapps下提供了四个web应用：docs、examples、host-manager和manager。只有ROOT是个例外，它用一个空字符串定义。也就是说，它的URL是<a href="http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。" target="_blank" rel="noopener">http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。</a></p><ul><li><p>appBase</p><p>虚拟机应用的根目录。该目录是一个可能包含部署到虚拟机上web应用的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用webapps。</p></li><li><p>xmlBase</p><p>虚拟机XML根目录。该目录是一个可能包含部署到虚拟机上context XML描述符的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用conf/目录。</p></li><li><p>createDirs</p><p>如果设置为true，Tomcat将会在启动阶段，尝试创建一个由appBase和xmlBase属性定义的目录。默认值为true。如果设置为true，并且目录创建失败，将会打印出一个错误信息，但是不会终止启动过程。</p></li><li><p>autoDeploy</p><p>该属性的值指明了在Tomcat运行的时候，是否需要定义检查新的或者更新后的web应用。如果为true，Tomcat会定义检查appBase和xmlBase目录，并对找到的新web应用和context XML描述符进行部署。更新web应用或XML上下文描述符将会触发web应用的重载。默认值为true。</p></li><li><p>backgroundProcessorDeploy</p><p>表示在调用这台主机的backgroundProcess方法和它的子容器方法，包括所有的context，之间延迟的秒数。如果延迟值不是负数的话，不会调用子容器（意味着会使用它们自己的处理线程）。设置为正数会产生衍生线程。在等待指定的时间之后，线程将会在该host上调用backgroundProcess方法，包括它的所有子容器。host将会使用后台进程执行web应用部署相关的任务。如果没有指定，默认值为-1，意味着host将会依赖于它的父引擎的后台处理线程。</p></li><li><p>className</p><p>使用的Java实现类的名称。该类必须实现org.apache.catalina.Host接口。</p></li><li><p>deployIgnore</p><p>一个正则表达式，定义了在自动部署和启动时部署的情况下需要忽略的目录。这就允许我们在版本控制系统中保持自己的配置，例如，不会将.svn或者git文件夹部署到appBase目录下。该正则表达式是相对于appBase的。同时也是固定的，意味着是相对于整个文件或目录的名称进行的。因此，foo只会匹配名称为foo的文件或目录，而不会匹配foo.war等名称的文件或目录。如果想让“foo”匹配任意名称，可以使用“.*foo.*”。</p></li><li><p>deployOnStartup</p><p>指定在Tomcat启动时是否需要自动部署host下的web应用。默认值为true。</p></li><li><p>failCtxlfServletStartFails</p><p>设置为true时，如果它的任意一个load-on-startup &gt;= 0的servlet停止自身启动后，停止启动它的每一个子context。每一个子context可能覆盖这个属性。如果没有指定，将会使用默认值false。</p></li><li><p>name</p><p>通常是虚拟主机的网络名称，注册在你的域名服务器上。无论指定的主机名称是什么样的，Tomcat在内部都会将其转换为小写。嵌套在Engine内部的Host，其中必须有一个Host的名称匹配Engine的默认Host设置。</p></li><li><p>startStopThreads</p><p>Host在启动子Context元素时会并发使用的线程数。如果自动部署被使用的话将会使用该线程池部署新的Context。值为0时将会使用Runtime.getRuntime().availableProcessors()的值。值为负数时将会使用Runtime.getRuntime().availableProcessors()加上该值得和，小于1时将会使用1个线程。如果没有指定，会使用默认值1。</p></li><li><p>undeployOldVersion</p><p>该选项的值决定Tomcat，即自动部署进程部分，是否会检查并发部署的过时web应用，任何找到的应用都会被移除。只有在autoDeploy为true的情况下才会生效。如果没有指定将会使用默认值false。</p></li></ul><blockquote><p>Value</p></blockquote><p>Value（阀门）作为请求的前置处理程序，可以在请求发送到应用之前拦截HTTP请求。可以定义在任何容器中，比如Engine、Host、Context和Cluster。默认配置中，AccessLogValue会拦截HTTP请求，并在日志文件中创建一个切入点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>className</p><p>设置为org.apache.catalina.ha.tcp.ReplicationValue</p></li><li><p>filter</p><p>对于已知文件扩展名或url，可以在请求中使用Value通知cluster没有修改session，对于本次变化cluster没有必要通知session管理者。如果请求匹配该过滤器模型，cluster会假设session没有发生变化。一个filter样例大概是这样的filter=“.*.gif|.*.js|.*.jpeg|.*.jpg|.*.png|.*.htm|.*.html|.*.css|.*.txt”。filter使用java.util.regex的正则表达式。</p></li><li><p>primaryIndicator</p><p>布尔值，如果为true，replication value将会把primaryIndicatorName属性定义的名称插入到request属性中，该值无论是Boolean.TRUE或者Boolean.FALSE，都会被放入request属性中。</p></li><li><p>primaryIndicatorName</p><p>默认值为org.apache.catalina.ha.tcp.isPrimarySession，这个值定义了一个request属性的名称，值是一个布尔值，表示会话所在的服务器是否为主服务器。</p></li><li><p>statistics</p><p>布尔值，如果想让value手机请求的统计数据，设置为true，默认值为false。</p></li><li><p>RemoteAddrValue</p><p>阻截来自特定IP地址的请求。</p></li><li><p>RemoteHostValue</p><p>阻截基于主机名称的请求。</p></li><li><p>RequestDumperValue</p><p>记录了请求的详细信息。</p></li><li><p>SingleSignOnValue</p><p>当置于a下时，允许单点登录到该主机下的所有应用上。</p><p>​</p></li></ul><h3 id="1-5-tomcat-users-xml"><a href="#1-5-tomcat-users-xml" class="headerlink" title="1.5 tomcat-users.xml"></a>1.5 tomcat-users.xml</h3><p>用于访问tomcat管理应用程序时的安全性设置，用server.xml中引用的默认的用户数据库域（UserDatabase Realm）使用它，所有的凭证默认都是被注释的，如需授权和访问控制，或配置角色，可参考以下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"admin"</span> <span class="attr">roles</span>=<span class="string">"admin-gui,admin,manager-gui,manager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样tomcat7首页上的Server Status、Manager App、Host Manager就都可以点击登录进去。</p><p>tomcat6配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"admin"</span> <span class="attr">roles</span>=<span class="string">"admin,manager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-web-xml"><a href="#1-6-web-xml" class="headerlink" title="1.6 web.xml"></a>1.6 web.xml</h3><p>默认的web.xml文件可被所有的web应用程序使用，这个web.xml文件会设置jspservlet以支持应用程序处理jsps，并设置一个默认的servlet来处理静态资源和html文件，它还设置默认的回话超时以及像index.jsp，index.html这类欢迎文件，并且它为最通用的扩展文件设置默认的<a href="http://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">MIME</a>类型。</p><p>一般在Java工程中，web.xml用来初始化工程配置信息，比如welcome页面，filter，listener，servlet，servlet-mapping，启动加载级别等等。</p><p>当应用程序被部署到tomcat时，它会用[engine name]/[host name]/[context-path name].xml创建与context.xml等效的文件，如用户也在\$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml.default文件，在这个文件中特定主机下的所有web应用程序将对主机器虚拟环境采用一系列默认设置。</p><p>下面就详细介绍一下web.xml中常用的标签及其功能。</p><blockquote><p> \&lt;description>，\&lt;display-name>，\&lt;icon></p></blockquote><ul><li><p>\&lt;description></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>项目描述<span class="tag">&lt;/<span class="name">description</span>&gt;</span> <span class="comment">&lt;!--对项目作出描述--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>\&lt;display-name></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>项目名称<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span> <span class="comment">&lt;!--定义项目的名称--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>\&lt;icon>及\&lt;small-icon>，\&lt;large-icon></p><p>\&lt;icon> icon元素包含small-icon和large-icon两个子元素，用来指定web站台中小图标和大图标的路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--small-icon元素应指向web站台中某个小图标的路径，大小为16X 16 pixel，但是图像文件必须为GIF或JPEG格式，扩展名必须为.git或.jpg--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small-icon</span>&gt;</span>/路径/smallicon.gif<span class="tag">&lt;/<span class="name">small-icon</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--large-icon元素应指向web站台中某个大图标路径，大小为32X 32pixel，但是图像文件必须为GIF或JPEG的格式，扩展名必须为.git或.jpg--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">large-icon</span>&gt;</span>/路径/largeicon.jpg<span class="tag">&lt;/<span class="name">large-icon</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Demo Example<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JSP 2.0 Demo Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small-icon</span>&gt;</span>/images/small.gif<span class="tag">&lt;/<span class="name">small-icon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">large-icon</span>&gt;</span>/images/large.gif<span class="tag">&lt;/<span class="name">large-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>\&lt;context-param></p></blockquote><p>\&lt;context-param>元素含有一对参数名和参数值，用作应用的servlet上下文初始化参数。参数名在整个web应用中必须是唯一的。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处设定的参数，在JSP页面可以使用\${initParam.name}来获取。</p><p>在Servlet中可以使用下列方式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = getServletContext().getInitParamter(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>\&lt;filter></p></blockquote><p>filter元素用于指定web容器中的过滤器。</p><p>在请求和响应对象被servlet处理之前或之后，可以使用过滤器对这两个对象进行操作。通过filter-mapping元素，过滤器被映射到一个servlet或一个URL模式。这个过滤器的filter元素和filter-mapping元素必须具有相同的名称。</p><p>filter元素用来声明filter的相关设定，filter元素除了下面介绍的子元素之外，还包括&lt;icon>，\&lt;display-name>，\&lt;description>，\&lt;init-param>，其用途一样。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;filter-mapping></p></blockquote><p>filter-mapping元素用来声明web应用中的过滤器映射。过滤器可被映射到一个servlet或一个URL模式。将过滤器映射到一个servlet中会造成过滤器作用于servlet上。将过滤器映射到一个URL模式中则可以将过滤器应用于任何资源，只要该资源的URL与URL模式匹配。过滤是按照部署描述符的filter-mapping元素出现的顺序执行的。</p><p>filter-mapping元素的两个主要子元素filter-name和url-pattern用来定义Filter对应的URL。还有servlet-name和dispatcher子元素，不是很常用。</p><p>特别说明一下dispatcher，设置Filter对应的请求方式，有：REQUEST,INCLUDE,FORWAR,ERROR四种，默认为REQUEST。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;servlet></p></blockquote><p>在web.xml中完成一个最常见的任务是对servlet或JSP页面给出名称和定制的URL。用servlet元素分配名称，使用servlet-mapping元素将定制的URL与刚分配的名称相关联。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;servlet-mapping></p></blockquote><p>servlet-mapping元素包含两个子元素servlet-name和url-pattern，用来定义servlet所对应的URL。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;listener></p></blockquote><p>listener元素用来注册一个监听器类，可以在web应用中包含该类。使用listener元素，可以收到事件什么时候发生以及用什么作为响应的通知。</p><p>listener元素用来定义Listener接口，它的主要子元素为\&lt;listener-class></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.gnd.web.listener.TestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;session-config></p></blockquote><p>session-config包含一个子元素session-timeout，定义web应用中session的有效期限。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>900<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;mime-mapping></p></blockquote><p>mime-mapping包含两个子元素extension和mime-type，定义某个扩展名和某一MIME Type做对应。</p><p>\&lt;extension>扩展名名称\&lt;/extension></p><p>\&lt;mime-type>MIME格式\&lt;/mime-type></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extension</span>&gt;</span>doc<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>application/vnd.ms-word<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extension</span>&gt;</span>xls<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>application/vnd.ms-excel<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">extension</span>&gt;</span>ppt<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>application/vnd.ms-powerpoint<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;welcome-file-list></p></blockquote><p>welcome-file-list包含一个子元素welcome-file，用来定义首页列表。</p><p>welcome-file用来指定首页文件名称，服务器会按照设定的顺序来找首页。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;error-page></p></blockquote><p>error-page元素包含三个子元素error-code，exception-type和location。</p><p>将错误代码后异常的种类对应到web应用资源路径。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>error404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>error404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;jsp-config></p></blockquote><p>jsp-config元素主要用来设定jsp的相关配置，jsp-config包括taglib和jsp-property-group两个子元素，其中taglib元素在JSP1.2时就已经存在，而jsp-property-group是JSP2.0新增的元素。</p><p>\&lt;taglib></p><p>taglib元素包含两个子元素taglib-uri和taglib-location，用来设定JSP网页用到的TagLibrary路径。</p><p>\&lt;taglib-uri>URI\&lt;/taglib-uri></p><p>taglib-uri定义TLD文件的URI，JSP网页的taglib指令可以经由这个URI存取到TLD文件。</p><p>\&lt;taglib-location>/WEB-INF/lib/xxx.tld\&lt;/taglib-location></p><p>TLD文件对应web应用的存放位置。</p><p>\&lt;jsp-property-group></p><p>jsp-property-group元素包含8个子元素，分别为：</p><p>\&lt;description>Description\&lt;/description> 此设定的说明</p><p>\&lt;display-name>Name\&lt;/display-name>  此设定的名称</p><p>\&lt;url-pattern>URL\&lt;/url-pattern>  设定值所影响的范围，如*.jsp</p><p>\<el-ignored>true/false\&lt;/el-ignored>  是否支持EL语法</el-ignored></p><p>\&lt;scripting-invalid>true/false\&lt;/scripting-invalid>  是否支持java代码片段&lt;%…%&gt;</p><p>\&lt;page-encoding>UTF-8\&lt;/page-encoding> 设置JSP页面的编码</p><p>\&lt;include-prelude>.jspf\&lt;/include-prelude> 设置JSP页面的抬头，扩展名为.jspf</p><p>\<include-coda>.jspf\</include-coda> 设置JSP页面的结尾，扩展名为.jspf</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">taglib</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">taglib-uri</span>&gt;</span>Taglib<span class="tag">&lt;/<span class="name">taglib-uri</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">taglib-location</span>&gt;</span>/WEB-INF/tlds/MyTaglib.tld<span class="tag">&lt;/<span class="name">taglib-location</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">description</span>&gt;</span>Configuration JSP example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JspConfig<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scripting-invalid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>\&lt;resource-ref></p></blockquote><p>resource-ref元素包含五个子元素description，res-ref-name，res-type，res-auth，res-sharing-scope，利用JNDI取得应用可利用资源。</p><p>\&lt;res-auth>Application/Container\&lt;/res-auth> 资源由Application或Container来许可。</p><p>\<res-sharing-scope>Shareable|Unshareable\<res-sharing-scope> 资源是否可以共享，默认值为Shareable</res-sharing-scope></res-sharing-scope></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>jdbc/Druid<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>com.alibaba.druid.pool.DruidDataSource<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">res-auth</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">res-auth</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-loggin-properties"><a href="#1-7-loggin-properties" class="headerlink" title="1.7 loggin.properties"></a>1.7 loggin.properties</h3><p>JULI记录器使用默认日志配置，它默认地使用ConsoleHandler和fileHandler设置应用程序或者程序包的日志级别。</p><h2 id="2-启动流程分析"><a href="#2-启动流程分析" class="headerlink" title="2. 启动流程分析"></a>2. 启动流程分析</h2><h3 id="2-1-Idea调试Tomcat源码环境搭建"><a href="#2-1-Idea调试Tomcat源码环境搭建" class="headerlink" title="2.1 Idea调试Tomcat源码环境搭建"></a>2.1 Idea调试Tomcat源码环境搭建</h3><p>首先下载Tomcat源码，读者可自行去<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat官网</a> 下载，若执行力差的同学也可直接从此处pull。</p><p>Tomcat源码导入到开发工具中的方法有多种，笔者采用最直接的方式，解压源码包后直接导入到开发工具中，导入之后的源码并不能直接运行，还需要几个依赖包，读者可从此处的lib目录下获取，也可自行搜集。</p><p>找好依赖包也并不能让Tomcat源码正常运行，还需要为Bootstrap这个启动类增加几个启动参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home=/Users/chenmin/GitHub/tomcat</span><br><span class="line">-Dcatalina.base=/Users/chenmin/GitHub/tomcat</span><br><span class="line">-Djava.endorsed.dirs=/Users/chenmin/GitHub/tomcat/endorsed</span><br><span class="line">-Djava.io.tmpdir=/Users/chenmin/GitHub/tomcat/temp</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file=/Users/chenmin/GitHub/tomcat/conf/logging.properties</span><br></pre></td></tr></table></figure><p>上面的参数具体代表的意思就不一一详述了，其实光看名字就知道都是干嘛用的了。</p><p>以上准备步骤做好之后，就可以直接运行Bootstrap类，运行Tomcat源码进行调试了。</p><h3 id="2-2-Tomcat-Server的组成"><a href="#2-2-Tomcat-Server的组成" class="headerlink" title="2.2 Tomcat Server的组成"></a>2.2 Tomcat Server的组成</h3><h4 id="2-2-1-整体说明"><a href="#2-2-1-整体说明" class="headerlink" title="2.2.1 整体说明"></a>2.2.1 整体说明</h4><p>在上面对配置文件的说明中，通过server.xml的解释，我们知道server.xml中最顶级的元素是server，而server.xml中的每一个元素我们都可以把它看做是Tomcat中的某一个部分。所以我们可以参照着server.xml来分析源码。</p><p>Tomcat最顶层的容器叫Server，它代表着整个Tomcat服务器。Server中至少要包含一个Service来提供服务。Service包含两部分：Connector和Container。Connector负责网络连接，request/response的创建，并对Socket和request、response进行转换等，Container用于封装和管理Servlet，并处理具体的request请求。</p><p>一个Tomcat中只有一个Server，一个Server可以有多个Service来提供服务，一个Service只有一个Container，但是可以有多个Connector（一个服务可以有多个连接）。</p><p><img src="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png?raw=true" alt="tomcat整体结构"></p><h4 id="2-2-2-各组件详解"><a href="#2-2-2-各组件详解" class="headerlink" title="2.2.2 各组件详解"></a>2.2.2 各组件详解</h4><p>可结合conf/配置文件说明中的server.xml的说明来看</p><ul><li><p>Server</p><p>Server代表整个Servlet容器</p></li><li><p>Service</p><p>Service是由一个或多个Connector以及一个Engine，负责处理所有Connector所获得的客户请求的集合。</p></li><li><p>Connector</p><p>Connector将在某个指定端口上侦听客户请求，并将获得的请求交给Engine来处理，从Engine处获得回应并返回给客户端。</p><p>Tomcat有两个默认的Connector，一个直接监听来自浏览器的http请求，一个监听来自其他WebServer的请求。</p><p>Coyote Http/1.1 Connector在端口8080上监听来自浏览器的http请求</p><p>Coyote AJP/1.3 Connector在端口8009上监听来自其他WebServer的servlet/jsp代理请求。</p></li><li><p>Engine</p><p>Engine下可以配置多个虚拟主机，每个虚拟主机都有一个域名，当Engine获得一个请求时，Engine会把该请求匹配到某个Host上，然后把该请求交给该Host来处理。</p><p>Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。</p></li><li><p>Host</p><p>代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配。每个虚拟主机下都可以部署一个或者多个WebApp，每个WebApp对应于一个Context，有一个ContextPath。当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。匹配的方法是“最长匹配”，所以一个path==“”的Context将成为该Host的默认Context，所有无法和其他Context的路径名匹配的请求都将最终和该默认Context匹配。</p></li><li><p>Context</p><p>一个Context对应于一个Web Application（Web应用），一个Web应用有一个或多个Servlet组成，Context在创建的时候将根据配置文件\$CATALINA_HOME/conf/web.xml和\$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。如果找到，则执行该类，获得请求的回应，并返回。</p><p>Tomcat各组件关系图(此图来此网上)</p><p><img src="https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat-startup.gif?raw=true" alt="QQ截图20170913174040"></p></li></ul>]]></content>
    
    <summary type="html">
    
      Tomcat架构介绍及配置分析
    
    </summary>
    
      <category term="Tomcat" scheme="/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>对前后台分离的思考</title>
    <link href="/2018/03/05/%E5%AF%B9%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%86%E7%A6%BB%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>/2018/03/05/对前后台分离的思考/</id>
    <published>2018-03-05T03:17:33.000Z</published>
    <updated>2018-10-26T07:31:45.557Z</updated>
    
    <content type="html"><![CDATA[<p>在为期一年多的前后端分离项目的开发中，对这种新型的项目开发模式也算是有了一定的了解，此文对这种开发模式的感悟略作记录。<a id="more"></a></p><p>传统的javaweb项目，在开发的过程中，没有明确的分工，后台人员即要写后台，也要做数据库，更要写页面，而且传统的javaweb项目，大多都是jsp，有时候没有明确的规范，jsp页面加入大量的java代码，导致项目前后台杂乱不堪。</p><p>随着时代的发展，各种前后台框架的出现，前段知识大量增加，如果还保持着传统项目架构，后端人员工作量大大增加，需要学习的知识也同步增加，最终造成的结果就是啥都懂一点，啥都不精。</p><p>慢慢的，前后端分离架构出现了，前端人员专心研究前端的事，后端人员专心提高后端的事，正所谓术业有专攻。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>前后端分离，大体上就是前端页面和后端的交互只通过json。页面的跳转等都由前端控制，后端只负责为页面提供数据。</p><p>在公司为期将近一年的开发中，各种新项目，老项目都渐渐的采用前后端分离架构，对这种架构模式也有了一点初步的认识，接下来就说说我在项目中对前后端分离的各种体会。</p><p>首先，先说说在开发中，因为前后端分离产生的一些问题。</p><p>在开发中，因为基本上前端都是那种特别纯粹的前端人员，也就是只懂前端，不了解java，不了解oracle，不了解业务，不了解网络协议等等各种基础知识即特性，在开发中出现了各种问题，比如请求中cookie丢失不知如何处理，功能开发完成之后不知如何测试，不懂业务导致不知道自己做出的页面到底对不对等等各种问题，而且由于后台只提供数据，不做页面跳转，所以在和传统项目做SSO单点登录的时候更麻烦。</p><p>当然，前后台分离也并不是没有好处。</p><ol><li>开发人员的职能划分更加明确，前后端人员各自考虑自己职能范围内的事，比如前端人员可以专心提高页面的用户体验，而后端人员则专注于接口开发和后台性能</li><li>前后端能够同步进行，事先定义好接口，前后端同步进行，到后面只需要进行对接联调即可</li><li>前台基本上采用静态页面，响应速度快</li><li>前后端分离了，可以分开部署，也可以分开做负载处理</li></ol><h3 id="针对前后端分离架构的项目准备工作"><a href="#针对前后端分离架构的项目准备工作" class="headerlink" title="针对前后端分离架构的项目准备工作"></a>针对前后端分离架构的项目准备工作</h3><p>由于前后端分离，前后端由不同的人员去开发，所以项目的准备工作一定要做到位。</p><ol><li>项目必须要有详细的API，并且能够测试数据，以便前端人员能够在最短的时间内拿到正确的API，swagger就挺不错的，后端API有改动时，能够实时反映出来。</li><li>对于页面功能，最好有明确的模型图</li><li>在项目开始时，前后端人员必须都对业务有所了解，“脱离业务的项目架构都是耍流氓”，忘记出自哪里了。</li></ol><p>目前大概只有这些体会了，后面有更深的理解，会继续补充。</p>]]></content>
    
    <summary type="html">
    
      前后台分离架构的认识与思考
    
    </summary>
    
      <category term="思考" scheme="/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="项目架构" scheme="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
      <category term="前后端分离" scheme="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群搭建</title>
    <link href="/2018/02/08/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>/2018/02/08/Redis集群搭建/</id>
    <published>2018-02-08T14:51:33.000Z</published>
    <updated>2018-10-31T01:30:03.634Z</updated>
    
    <content type="html"><![CDATA[<p>此文将对Redis的各种集群搭建方式稍作介绍<a id="more"></a></p><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>此处使用 4.0.2 的版本，搭建一主两从的Redis集群。</p><blockquote><p>环境准备</p></blockquote><p>从<a href="http://download.redis.io/releases/redis-4.0.2.tar.gz" target="_blank" rel="noopener">此处</a>下载redis-4.0.2.tar.gz，解压之后，编译源码进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf redis-4.0.2.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-4.0.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><p>在用户家目录下新建redis相关目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir slave</span></span><br></pre></td></tr></table></figure><p>然后拷贝redis-4.0.2目录中的redis.conf配置文件到master，修改为redis_master.conf，slave中拷贝两份，分别命名为redis_slave1.conf，redis_slave2.conf。</p><p>接下来修改配置文件内容（只贴出关键几个点，其他辅助内容请读者自行修改）：redis_master.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>redis_slave1.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">slaveof localhost 7000</span><br></pre></td></tr></table></figure><p>redis_slave2.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 7002</span><br><span class="line">daemonize yes</span><br><span class="line">slaveof localhost 7000</span><br></pre></td></tr></table></figure><p>分别启动三个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./master/redis_master.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./slave/redis_slave1.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./slave/redis_slave2.conf</span></span><br></pre></td></tr></table></figure><p>登录进master节点，查看主从模式是否正常启动(主节点上能显示出两个从节点即可)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-cli</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> info replication</span></span><br></pre></td></tr></table></figure><h3 id="三主三从三哨兵集群模式"><a href="#三主三从三哨兵集群模式" class="headerlink" title="三主三从三哨兵集群模式"></a>三主三从三哨兵集群模式</h3><p>redis编译安装和上面一样</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>master</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6380</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6381</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6382</span></span><br></pre></td></tr></table></figure><p>slave</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6383</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6384</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:6385</span></span><br></pre></td></tr></table></figure><p>sentinel</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:26380</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:26381</span>,192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.100</span><span class="selector-pseudo">:26382</span></span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>手动在服务器上新建6380,6381,6382,6383,6384,6385几个目录，将redis.conf配置文件每个目录拷贝一份（批量拷贝文件时，最好参考linux中xargs命令；当然，也可以cp多执行几次）。</p><p>redis.conf配置文件修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 端口分别为6380,6381,6382,6383,6384,6385</span><br><span class="line">port 6380</span><br><span class="line"># 默认端口为127.0.0.1，改为本机地址则为任意服务器都可以访问，若只指定服务器访问，则改为指定服务器ip即可，由于当前是一台服务器上的伪集群，所以配置本机ip地址。</span><br><span class="line">bind 192.168.10.100</span><br><span class="line"># Redis后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"># pidfile文件对应存放目录(redis节点进程号)</span><br><span class="line">pidfile /home/admin/redis/cluster/6380/redis.pid</span><br><span class="line"># 操作日志</span><br><span class="line">logfile &quot;/home/admin/redis/cluster/6380/redis.log&quot;</span><br><span class="line"># 数据文件存放目录</span><br><span class="line">dir /home/admin/redis/cluster/6380/</span><br><span class="line"># 是否开启集群(重点)</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群节点配置，集群首次启动自动生成</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"># 集群节点连接超时时间</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"># aof日志开启，可做为日志记录，也可借此恢复数据</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>其他节点类似。</p><p>然后启动每一个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7000/redis.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7001/redis.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7002/redis.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7003/redis.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7004/redis.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-server ./cluster/7005/redis.conf</span></span><br></pre></td></tr></table></figure><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><p>这里创建集群借助于redis自己提供的一个集群创建工具redis-trib.rb（依赖于ruby环境），Redis 5.*的集群构建工具依赖于g++环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-trib.rb create --replicas 1 192.168.10.100:6380 192.168.10.100:6381 192.168.10.100:6382 192.168.10.100:6383 192.168.10.100:6384 192.168.10.100:6385</span></span><br></pre></td></tr></table></figure><p>根据提示完成集群创建</p><p>接下来验证集群是否搭建成功，连接其中一个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 6380</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster nodes</span></span><br><span class="line">dcebbc47abd482363f221020dd1be714a498b841 192.168.10.110:6382 master - 0</span><br><span class="line">1524568524063 3 connected 10923-16383</span><br><span class="line">33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 192.168.10.110:6380 myself,master - 0 0 1</span><br><span class="line">connected 0-5460</span><br><span class="line">51ed0849bf29de0221eb3b9b4ccbebfd341593ad 192.168.10.110:6384 slave</span><br><span class="line">409b146c1fc86acfd6198c491cf77eaf8c8c7c04 0 1524568525066 5 connected</span><br><span class="line">e29d4537e924f0e29f5155536a636b35a44a8c24 192.168.10.110:6383 slave</span><br><span class="line">33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 0 1524568523562 4 connected</span><br><span class="line">dc4f070c42f9002e1c54bb6019ee4c34331570cc 192.168.10.110:6385 slave</span><br><span class="line">dcebbc47abd482363f221020dd1be714a498b841 0 1524568523062 6 connected</span><br><span class="line">409b146c1fc86acfd6198c491cf77eaf8c8c7c04 192.168.10.110:6381 master - 0</span><br><span class="line">1524568524063 2 connected 5461-10922</span><br></pre></td></tr></table></figure><p>输入info replication可查看节点信息。</p><h4 id="哨兵搭建"><a href="#哨兵搭建" class="headerlink" title="哨兵搭建"></a>哨兵搭建</h4><p>新建sentinel/26380,26381,26382目录，将redis家目录下的sentinel.conf文件拷贝到每个目录中</p><p>sentinel.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.10.100</span><br><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/home/admin/redis/cluster/sentinel/26380&quot;</span><br><span class="line"># 故障转移配置</span><br><span class="line"># 表示哨兵集群中，至少有两个节点认为Redis节点挂掉，则将节点从集群中剔除</span><br><span class="line">sentinel monitor mymaster 192.168.10.100 6380 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br></pre></td></tr></table></figure><p>其他的类似</p><p>启动哨兵</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26380/sentinel.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26381/sentinel.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26382/sentinel.conf</span></span><br></pre></td></tr></table></figure><p>查看哨兵节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 26380</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> info Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=cpicmaster,status=ok,address=192.168.10.110:6380,slaves=1,sentinels=3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文将对Redis的各种集群搭建方式稍作介绍
    
    </summary>
    
      <category term="Redis" scheme="/categories/Redis/"/>
    
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础配置</title>
    <link href="/2018/02/08/Redis%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>/2018/02/08/Redis基础配置/</id>
    <published>2018-02-08T14:51:33.000Z</published>
    <updated>2018-10-31T01:29:54.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><blockquote><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当Redis以守护进程方式运行时，Redis会默认把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure><blockquote><p>指定Redis监听端口，默认端口为6379</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure><blockquote><p>绑定主机地址</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure><blockquote><p>当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure><blockquote><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel verbose</span><br></pre></td></tr></table></figure><blockquote><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile stdout</span><br></pre></td></tr></table></figure><blockquote><p>设置数据库的数量，默认数据库有16个（0-15），默认使用0，可以使用SELECT \&lt;dbid> 命令在连接上指定数据库id</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure><blockquote><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Redis默认配置文件中提供了三个条件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改</p><blockquote><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但是会导致数据库文件变大</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><blockquote><p>指定本地数据库文件名，默认值为dump.rdb</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><blockquote><p>指定本地数据库存放目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure><blockquote><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当master服务设置了密码保护时，slav服务连接master的密码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果配置了连接密码，客户端在链接Redis时需要通过AUTH \&lt;password>命令提供密码，默认关闭</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure><blockquote><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不做限制。当客户端连接数达到限制时，Redis会关闭新的连接并像客户端返回max number of clients reached错误信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 128</span><br></pre></td></tr></table></figure><blockquote><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然达到最大内存限制，将无法再进行写操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放到swap区</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure><blockquote><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件同步的，所以有的数据会在一段时间内只存在于内存中，默认为no</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure><blockquote><p>指定更新日志文件名，默认为appendonly.aof</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><blockquote><p>指定更新日志条件，共有3个可选值</p></blockquote><p>no：表示等操作系统进行数据缓存同步到磁盘（快）</p><p>always：表示每次更新操作后手动调用fsync() 将数据写到磁盘（慢，安全）</p><p>everysec：表示每次同步一次（折衷，默认值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><blockquote><p>指定是否启用虚拟内存机制，默认值为no，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动缓存到内存中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-enabled no</span><br></pre></td></tr></table></figure><blockquote><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-swap-file /tmp/redis.swap</span><br></pre></td></tr></table></figure><blockquote><p>将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-max-memory 0</span><br></pre></td></tr></table></figure><blockquote><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，如果存储很多小对象，page大小最好设置为32或者64bytes，如果存储很多的大对象，则可以使用更大的page，如果不确定，就使用默认值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-page-size 32</span><br></pre></td></tr></table></figure><blockquote><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-pages 134217728</span><br></pre></td></tr></table></figure><blockquote><p>设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure><blockquote><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glueoutputbuf yes</span><br></pre></td></tr></table></figure><blockquote><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure><blockquote><p>指定是否激活重置哈希，默认为开启</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure><h2 id="常用操作（高级）"><a href="#常用操作（高级）" class="headerlink" title="常用操作（高级）"></a>常用操作（高级）</h2><p><a href="https://redis.io/commands" target="_blank" rel="noopener">Redis官网命令详解</a></p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>Redis的事务也有两种，乐观锁和悲观锁。</p><p>悲观锁，直接给这个key加锁，这个key只能当前连接可以操作。</p><p>乐观锁，给这个key加锁，只要这个key的值没有更改就可以了。</p><p>Redis的事务中，默认启用的是乐观锁，只负责监测key有没有变动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch key1 key2  监听key有没有变化，如果有变化，则事务取消，在multi之前使用</span><br><span class="line">unwatch key1 key2  不加具体key时，取消所有key的监听。</span><br><span class="line">multi  开启事务</span><br><span class="line">...</span><br><span class="line">discard/exec  取消事务/提交事务</span><br></pre></td></tr></table></figure><p>注意：如果在exec时，命令语法有问题，这时所有的语句都得不到执行。如果语法本身没问题，但是适用的对象有问题，exec之后，会执行正确的语句，并跳过有问题的语句。</p><h3 id="消息的发布与订阅"><a href="#消息的发布与订阅" class="headerlink" title="消息的发布与订阅"></a>消息的发布与订阅</h3><p>使用办法：</p><p>订阅端：subscribe  频道名称</p><p>psubscribe 支持表达式匹配的频道</p><p>返回值为订阅到消息的客户端数量</p><p>发布端：publish  频道名称  发布内容</p><h3 id="Redis持久化配置"><a href="#Redis持久化配置" class="headerlink" title="Redis持久化配置"></a>Redis持久化配置</h3><blockquote><p>持久化</p></blockquote><p>把数据存储于断电后不会丢失的设备中，通常是硬盘</p><blockquote><p>常见的持久化方式</p></blockquote><p>主从：通过主服务器往内存中写，从服务器做保存和持久化</p><p>日志：操作生成相关日志，并通过日志来恢复数据，couchDB对于数据内容，不修改，只追加，则文件本身就是日志，不会丢失数据。</p><h4 id="rdb快照持久化"><a href="#rdb快照持久化" class="headerlink" title="rdb快照持久化"></a>rdb快照持久化</h4><blockquote><p>rdb工作原理</p></blockquote><p>每隔N分钟或N次写操作后，从内存dump数据形成rdb文件，压缩放在备份目录</p><blockquote><p>rdb快照相关参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 #刷新快照到磁盘中，必须满足两者要求才会触发，即900秒之内至少1个关键字发生变化</span><br><span class="line">save 300 10 #必须是300秒之内至少10个关键字发生变化</span><br><span class="line">save 60 10000 #必须是60秒之内至少10000个关键字发生变化</span><br><span class="line">stop-writes-on-bgsave-error yes #后台存储错误停止写rdb</span><br><span class="line">rdbcompression yes #使用LZF压缩rdb文件</span><br><span class="line">rdbchecksum yes #导入rdb恢复时数据时，要不要校验rdb的完整性</span><br><span class="line">dbfilename dump.rdb #设置rdb文件名</span><br><span class="line">dir ./ #设置工作目录，rdb文件会写入该目录</span><br></pre></td></tr></table></figure><blockquote><p>rdb的缺陷</p></blockquote><p>在上一个保存点刚结束，下个保存点还没到时如果断电，将会丢失1-N分钟的数据</p><blockquote><p>rdb的优势</p></blockquote><p>由于导出的是一个内存的二进制文件，所以rdb文件的恢复速度超级快</p><h4 id="aof日志持久化"><a href="#aof日志持久化" class="headerlink" title="aof日志持久化"></a>aof日志持久化</h4><blockquote><p>aof工作原理</p></blockquote><p>redis客户端连接redis服务器后所进行的每一条命令的操作都逐条记录到aof日志中，在恢复数据时，只需要将日志中记录的命令都依次执行一遍即可。</p><blockquote><p>aof配置参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes #是否打开aof日志功能</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  #设置aof文件名</span><br><span class="line">appendfsync everysec #折衷方案，每秒写一次</span><br><span class="line">appendfsync no #写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof，同步频率低，速度快</span><br><span class="line">appendfsync always #每一个命令都立即同步到aof，安全，速度慢</span><br><span class="line">no-appendfsync-on-rewrite no #正在到处rbd快照的过程中，要不要停止同步aof</span><br><span class="line">auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小，增长率100%时进行重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb  #aof文件，至少超过64M时进行重写</span><br><span class="line"># 上面两个aof重写规则同时满足aof才会进行重写</span><br></pre></td></tr></table></figure><blockquote><p>aof的缺陷</p></blockquote><p>由于项目使用redis，就是图redis的读写速度快，但是如果频繁写磁盘，也会拉低效率的，而且越往后，aof日志文件会越来越大的。</p><blockquote><p>aof的优势</p></blockquote><p>使用日志记录操作，能有效的保证数据的完整性，就算太巧合了，在刚执行了命令还没来得及同步aof时断电了，那也只会丢失当前的一条命令。</p><blockquote><p>aof重写</p></blockquote><p>把内存中的数据，逆化成命令写到aof日志里，以解决aof日志过大的问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、在dump过程中，aof如果停止同步，数据不会丢失，因为所有的操作会缓存在队列里，dump完成后，统一操作</p><p>2、如果rdb和aof文件都存在，它会采用谁优先就用谁来恢复数据，也就是会用aof</p><p>3、对于rdb和aof两种持久化方式，没有绝对的谁好谁坏，所以可以两者同时用，效果更优</p><p>4、rdb和aof相比，rdb的数据恢复更快，因为rdb的数据是内存映射，可以直接载入到内存，而aof是一条条的命令，需要逐条执行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="/categories/Redis/"/>
    
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>针对SpringBoot封装的Quartz starter模块</title>
    <link href="/2018/01/04/%E9%92%88%E5%AF%B9SpringBoot%E5%B0%81%E8%A3%85%E7%9A%84Quartz-starter%E6%A8%A1%E5%9D%97/"/>
    <id>/2018/01/04/针对SpringBoot封装的Quartz-starter模块/</id>
    <published>2018-01-04T03:17:33.000Z</published>
    <updated>2018-10-26T07:31:18.358Z</updated>
    
    <content type="html"><![CDATA[<p>针对公司业务要求，针对springboot，对quartz做了简单的封装，将其做成SpringBoot的一个Starter模块。主要功能有：</p><ol><li>任务配置动态更新，增加，停止，立即执行</li><li>任务立即执行</li><li>quartz集群节点是否开启实现可配置化<a id="more"></a></li></ol><p>后续功能继续增加中。。。</p><p>以下是在项目中具体使用方法:</p><h2 id="1、导入spring-boot-starter-quartz包"><a href="#1、导入spring-boot-starter-quartz包" class="headerlink" title="1、导入spring-boot-starter-quartz包"></a>1、导入spring-boot-starter-quartz包</h2><ul><li>maven</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.quartz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>gradle</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.github.quartz:spring-boot-starter-quartz:1.0'</span>)</span><br></pre></td></tr></table></figure><h2 id="2、开启Quartz自动配置"><a href="#2、开启Quartz自动配置" class="headerlink" title="2、开启Quartz自动配置"></a>2、开启Quartz自动配置</h2><p>目前提供了@EnableQuartz，@EnableQuartzBean，@EnableQuartzDataBase三个开启自动配置注解。</p><p>@EnableQuartz：开启所有的自动配置</p><p>@EnableQuartzBean：开启quartz远程调用客户端配置</p><p>@EnableQuartzDataBase：开启quartz远程调用客户端及quartz相关基础Bean的配置</p><h2 id="3、任务配置表"><a href="#3、任务配置表" class="headerlink" title="3、任务配置表"></a>3、任务配置表</h2><p>脚本可在发布包的根目录中获得</p><p>Quartz集群的相关表可在Quartz的发布包org.quartz.impl.jdbcjobstore目录下找到相关SQL。</p><p>Quartz官方源码地址：【<a href="https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore】" target="_blank" rel="noopener">https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore】</a></p><ul><li>以下以Oracle的脚本为例</li></ul><blockquote><p> 任务配置表（QRTZ_TIMED_TASK）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_TIMED_TASK</span><br><span class="line">(</span><br><span class="line">  TASK_NAME   VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  TASK_DESC   VARCHAR2(<span class="number">500</span>),</span><br><span class="line">  TASK_EXPRES VARCHAR2(<span class="number">100</span>),</span><br><span class="line">  TASK_METHOD VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  TASK_CLASS  VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  TASK_GROUP  VARCHAR2(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">STATUS</span>      VARCHAR2(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'U'</span>,</span><br><span class="line">  CREATE_TIME <span class="built_in">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">SYSDATE</span>,</span><br><span class="line">  CREATER     VARCHAR2(<span class="number">200</span>),</span><br><span class="line">  MODIFY_TIME <span class="built_in">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">SYSDATE</span>,</span><br><span class="line">  MODIFIER    VARCHAR2(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- ADD COMMENTS TO THE COLUMNS</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_NAME</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务名称'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_DESC</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务描述'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_EXPRES</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务执行表达式'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_METHOD</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务执行方法'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_CLASS</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务接口路径'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.TASK_GROUP</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务分组'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.STATUS</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务状态'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.CREATE_TIME</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'创建时间'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.CREATER</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'创建人员'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.MODIFY_TIME</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'修改时间'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK.MODIFIER</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'修改人员'</span>;</span><br><span class="line"><span class="comment">-- CREATE/RECREATE PRIMARY, UNIQUE AND FOREIGN KEY CONSTRAINTS</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> QRTZ_TIMED_TASK</span><br><span class="line">  <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (TASK_NAME)</span><br><span class="line">  <span class="keyword">USING</span> <span class="keyword">INDEX</span></span><br><span class="line">  PCTFREE <span class="number">10</span></span><br><span class="line">  <span class="keyword">INITRANS</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">MAXTRANS</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">STORAGE</span></span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">INITIAL</span> <span class="number">64</span>K</span><br><span class="line">  <span class="keyword">NEXT</span> <span class="number">1</span>M</span><br><span class="line">  <span class="keyword">MINEXTENTS</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment">-- CREATE INDEX</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_TIMED_STATUS <span class="keyword">ON</span> QRTZ_TIMED_TASK (<span class="keyword">STATUS</span>)</span><br><span class="line">  PCTFREE <span class="number">10</span></span><br><span class="line">  <span class="keyword">INITRANS</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">MAXTRANS</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">STORAGE</span> (</span><br><span class="line">    <span class="keyword">INITIAL</span> <span class="number">64</span>K</span><br><span class="line">    <span class="keyword">NEXT</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">MINEXTENTS</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><blockquote><p>任务参数配置表（QRTZ_TIMED_TASK_PARAM）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_TIMED_TASK_PARAM</span><br><span class="line">(</span><br><span class="line">  PARAM_KEY   VARCHAR2(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PARAM_VALUE VARCHAR2(<span class="number">1000</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PARAM_TYPE  VARCHAR2(<span class="number">100</span>),</span><br><span class="line">  PARAM_DESC  VARCHAR2(<span class="number">1000</span>),</span><br><span class="line">  TASK_NAME   VARCHAR2(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  SORT_ID     <span class="built_in">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- ADD COMMENTS TO THE COLUMNS</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.PARAM_KEY</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'参数代码'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.PARAM_VALUE</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'参数值'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.PARAM_TYPE</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'参数类型(不填默认为STRING类型)'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.PARAM_DESC</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'参数描述'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.TASK_NAME</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'任务名称'</span>;</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> QRTZ_TIMED_TASK_PARAM.SORT_ID</span><br><span class="line"><span class="keyword">IS</span> <span class="string">'参数顺序'</span>;</span><br><span class="line"><span class="comment">-- CREATE/RECREATE PRIMARY, UNIQUE AND FOREIGN KEY CONSTRAINTS</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> QRTZ_TIMED_TASK_PARAM</span><br><span class="line">  <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (PARAM_KEY, TASK_NAME)</span><br><span class="line">  <span class="keyword">USING</span> <span class="keyword">INDEX</span></span><br><span class="line">  PCTFREE <span class="number">10</span></span><br><span class="line">  <span class="keyword">INITRANS</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">MAXTRANS</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">STORAGE</span></span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">INITIAL</span> <span class="number">64</span>K</span><br><span class="line">  <span class="keyword">NEXT</span> <span class="number">1</span>M</span><br><span class="line">  <span class="keyword">MINEXTENTS</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment">-- CREATE INDEX</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_TIMED_TASK_PARAM_NAME <span class="keyword">ON</span> QRTZ_TIMED_TASK_PARAM (TASK_NAME)</span><br><span class="line">  PCTFREE <span class="number">10</span></span><br><span class="line">  <span class="keyword">INITRANS</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">MAXTRANS</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">STORAGE</span> (</span><br><span class="line">    <span class="keyword">INITIAL</span> <span class="number">64</span>K</span><br><span class="line">    <span class="keyword">NEXT</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">MINEXTENTS</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>QRTZ_TIMED_TASK.TASK_NAME : 任务名称，任务在调度工厂中的唯一标识，再配合参数表的配置，可实现一个接口，配置多个任务的功能</li><li>QRTZ_TIMED_TASK.STATUS : 表示任务状态，分为四种状态，U表示有效运行，即此任务在工程启动之后即可正常运行；E表示无效任务，即此任务无效，不会自动运行；D表示此任务要删除，调度工厂删除任务后，任务状态改为E；S表示将启动此任务，任务启动成功后，状态改为U</li><li>QRTZ_TIMED_TASK.TASK_CLASS : 任务类路径，类必须加入到Spring上下文中，可支持配置接口，实现类，或者普通类。</li><li>QRTZ_TIMED_TASK_PARAM.SORT_ID : 参数顺序，默认使用LinkedHashMap存储，可通过参数顺序，实现通用接口，不同参数配置而实现一个接口多任务配置</li></ol><h2 id="4、开发任务接口"><a href="#4、开发任务接口" class="headerlink" title="4、开发任务接口"></a>4、开发任务接口</h2><p>任务的开发需按照以下标准开发：</p><ul><li>任务接口需大写 I 开头，大写 SV 结尾</li><li>接口实现类需去掉接口的 I 开头，然后在 SV 后加 Impl</li><li>接口方法参数必须为Map</li></ul><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloSV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(Map param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSVImpl</span> <span class="keyword">implements</span> <span class="title">IHelloSV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Map param)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、任务配置"><a href="#5、任务配置" class="headerlink" title="5、任务配置"></a>5、任务配置</h2><p>在配置任务时，按照以下要求配置：</p><ul><li>优先配置接口类</li><li>如需配置接口参数，在参数表中指定参数名，参数值，并指定task_name</li><li>参数配置时，参数类型可为空，默认使用Map\&lt;String, String>  接收，当指定参数类型时，<br>  使用Map\&lt;String, Object> 接收，在代码中可使用强制类型转换</li><li>参数类型只支持基本类型，配置时使用全路径 </li></ul><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_TIMED_TASK (TASK_NAME, TASK_DESC, TASK_EXPRES, TASK_METHOD, TASK_CLASS, TASK_GROUP, <span class="keyword">STATUS</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'hello1'</span>, <span class="string">'测试1'</span>, <span class="string">'0/10 * * * * ?'</span>, <span class="string">'hello'</span>, <span class="string">'com.IHelloSV'</span>, <span class="string">'hello'</span>, <span class="string">'U'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_TIMED_TASK (TASK_NAME, TASK_DESC, TASK_EXPRES, TASK_METHOD, TASK_CLASS, TASK_GROUP, <span class="keyword">STATUS</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'hello2'</span>, <span class="string">'测试2'</span>, <span class="string">'0/10 * * * * ?'</span>, <span class="string">'hello'</span>, <span class="string">'com.IHelloSV'</span>, <span class="string">'hello'</span>, <span class="string">'U'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_TIMED_TASK_PARAM (PARAM_KEY, PARAM_VALUE, PARAM_TYPE, PARAM_DESC, TASK_NAME)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'name'</span>, <span class="string">'admin'</span>, <span class="string">'java.lang.String'</span>, <span class="string">'测试参数'</span>, <span class="string">'hello2'</span>);</span><br></pre></td></tr></table></figure><h2 id="6、quartz配置"><a href="#6、quartz配置" class="headerlink" title="6、quartz配置"></a>6、quartz配置</h2><p>此项目默认采用quartz单机配置方式。具体配置可在发布包根目录下的quartz.properties中查看。<br>如需使用集群配置，可在自己项目的classpath下新建quartz.properties文件进行配置。</p><h2 id="7、任务动态更新"><a href="#7、任务动态更新" class="headerlink" title="7、任务动态更新"></a>7、任务动态更新</h2><ul><li>新增任务</li></ul><p>在QRTZ_TIMED_TASK表中新增任务配置之后，将STATUS字段改为S即可。</p><ul><li>删除任务</li></ul><p>将QRTZ_TIMED_TASK表要删除的数据的STATUS字段改为D即可。</p><ul><li>修改任务</li></ul><p>任务只支持修改以下几项：</p><p>QRTZ_TIMED_TASK.TASK_EXPRES,<br>QRTZ_TIMED_TASK_PARAM.PARAM_KEY,<br>QRTZ_TIMED_TASK_PARAM.PARAM_VALUE,<br>QRTZ_TIMED_TASK_PARAM.PARAM_TYPE,<br>QRTZ_TIMED_TASK_PARAM.PARAM_DESC,</p><p><strong>注：</strong> 当只修改了QRTZ_TIMED_TASK时，只有TASK_EXPRES生效；修改了QRTZ_TIMED_TASK_PARAM配置之后，QRTZ_TIMED_TASK的其他配置都是可以修改的。</p><h2 id="8、Quartz集群相关表介绍"><a href="#8、Quartz集群相关表介绍" class="headerlink" title="8、Quartz集群相关表介绍"></a>8、Quartz集群相关表介绍</h2><blockquote><p>qrtz_fired_triggers</p></blockquote><p>触发器与任务关联表,存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息。</p><blockquote><p>qrtz_simple_triggers</p></blockquote><p>存储简单的Trigger，包括重复次数，间隔，以及已触发的次数</p><blockquote><p>qrtz_simprop_triggers</p></blockquote><blockquote><p>qrtz_cron_triggers</p></blockquote><p>存储CronTrigger，包括Cron表达式和时区信息</p><blockquote><p>qrtz_blob_triggers</p></blockquote><p>Trigger作为Blob类型存储(用于Quartz用户用JDBC创建他们自己定制的Trigger类型，JobStore 并不知道如何存储实例的时候)</p><blockquote><p>qrtz_triggers</p></blockquote><p>存储已配置的 Trigger的信息</p><blockquote><p>qrtz_job_details</p></blockquote><p>存储每一个已配置的Job的详细信息</p><blockquote><p>qrtz_calendars</p></blockquote><p>以Blob类型存储Quartz的Calendar日历信息， quartz可配置一个日历来指定一个时间范围</p><blockquote><p>qrtz_paused_trigger_grps</p></blockquote><p>存储已暂停的Trigger组的信息</p><blockquote><p>qrtz_locks</p></blockquote><p>存储程序的非观锁的信息(假如使用了悲观锁)</p><blockquote><p>qrtz_scheduler_state</p></blockquote><p>存储少量的有关 Scheduler的状态信息，和别的 Scheduler 实例(假如是用于一个集群中)</p><h2 id="9、quartz时间表达式"><a href="#9、quartz时间表达式" class="headerlink" title="9、quartz时间表达式"></a>9、quartz时间表达式</h2><p>时间格式：s&gt;m&gt;h&gt;d&gt;m&gt;w(?)&gt;y(?)  对应：秒&gt;分&gt;小时&gt;日&gt;月&gt;周&gt;年</p><ul><li>Cron表达式的符号、格式</li></ul><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">＊</td><td style="text-align:left">匹配所有的值。如：＊在分钟的字段域里表示 每分钟</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">只在日期域和星期域中使用。它被用来指定“非明确的值”</td></tr><tr><td style="text-align:center">-</td><td style="text-align:left">指定一个范围。如：“10-12”在小时域意味着“在10点到12点之间”</td></tr><tr><td style="text-align:center">,</td><td style="text-align:left">指定几个可选值。如：“MON,WED,FRI”在星期域里表示“星期一、星期三、星期五”</td></tr><tr><td style="text-align:center">/</td><td style="text-align:left">指定增量。如：“0/15”在秒域表示在每分钟的第0秒开始，每15秒执行一次。符号“*”在“/”前面等价于0在“/”前面</td></tr><tr><td style="text-align:center">L</td><td style="text-align:left">表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of-month域中表示一个月的最后一天。如果在day-of-week域表示“7”或者“SAT”，如果在day-of-week域中前面加上数字，表示一个月的最后几天，例如“6L”就表示一个月的最后一个星期五</td></tr><tr><td style="text-align:center">W</td><td style="text-align:left">只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写“15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15刚好是周日，则任务会在周一也就是16号触发。如果是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能跨月份的。字符“W”只能配合一个单独的数值使用，不能够是一个数字段，如：1-15W是错误的</td></tr><tr><td style="text-align:center">LW</td><td style="text-align:left">L和W可以在日期域中联合使用，LW表示这个月最后一周的工作日</td></tr><tr><td style="text-align:center">#</td><td style="text-align:left">只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三</td></tr><tr><td style="text-align:center">C</td><td style="text-align:left">允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）</td></tr></tbody></table><ul><li>Cron表达式特殊字符意义对应表</li></ul><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>月内日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>月</td><td>1-12或JAN-DEC</td><td>, - * /</td></tr><tr><td>周内日期</td><td>1-7或SUN-SAT</td><td>, - * ? / L C #</td></tr><tr><td>年（可选）</td><td>留空，1970-2099</td><td>, - * /</td></tr></tbody></table><p>时间表达式在线生成器：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>]]></content>
    
    <summary type="html">
    
      针对SpringBoot封装的Quartz starter模块
    
    </summary>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
      <category term="Quartz" scheme="/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动原理分析</title>
    <link href="/2017/12/09/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>/2017/12/09/SpringBoot启动原理分析/</id>
    <published>2017-12-09T14:30:56.000Z</published>
    <updated>2018-10-08T08:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。</p><p>此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="核心注解-SpringBootApplication"><a href="#核心注解-SpringBootApplication" class="headerlink" title="核心注解@SpringBootApplication"></a>核心注解@SpringBootApplication</h3><p>每个SpringBoot应用，都有一个入口类，标注@SpringBootApplication注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点开@SpringBootApplication的源码，可以看到这个注解其实包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。</p><p>下面对这三个注解简单解释解释。</p><ul><li><p>@SpringBootConfiguration</p><p>对于这个注解不做解释，将这个注解点进去，发现还有@Configuration注解，对于@Configuration注解，用过Spring或SpringBoot的基本上都不陌生，标注了@Configuration的类相当于Spring中的配置XML，不过SpringBoot社区推荐使用JavaConfig，所以@Configuration就构建出了一个基础JavaConfig的Ioc容器。</p></li><li><p>@EnableAutoConfiguration</p><p>Spring中有很多Enable*的注解，表示开启某项东西，如@EnableSchuduling。所以看这个注解的名字就知道是开启自动配置。这是一个复合注解，其中最主要的还是@Import，借助于EnableAutoConfigurationImportSelector，将所有符合自动配置条件的Bean加载到Ioc容器里。</p><p>SpringBoot加载自动配置的方式有两种（目前我知道的）：</p><ul><li><p>在classpath下新建META-INF/spring.factories文件，将标注了@Configuration的类的全路径配置到此文件中，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line"> com.quartz.config.QuartzBeanConfiguration,\</span><br><span class="line"> com.quartz.config.QuartzAutoConfiguration</span><br></pre></td></tr></table></figure><p>在启动时，通过SpringFactoriesLoader工具类，将所有META-INF目录下的spring.factories文件中的配置类加载到Ioc容器里。</p></li><li><p>使用@Import，将配置类加载到Ioc容器里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;QuartzAutoConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableQuartz &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Import导入的类必须满足以下任意一个要求：</p><ol><li>导入的类使用@Configuration进行标注</li><li>导入的类中至少有一个使用@Bean标准的方法</li><li>导入的类实现了ImportSelector接口</li><li>导入的类实现了ImportBeanDefinitionRegistrar接口</li></ol></li></ul></li><li><p>@ComponentScan</p><p>看到这个注解，可以回想一下以前使用SpringMVC时，xml配置文件里的一个标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>不过这个注解一般不需要手动指定扫描的包路径，它默认会从标注了@ComponentScan的类所在包往下查找，将标注了如@Component，@Service等Bean加载到Ioc容器里。</p></li></ul><h3 id="自动配置核心类SpringFactoriesLoader"><a href="#自动配置核心类SpringFactoriesLoader" class="headerlink" title="自动配置核心类SpringFactoriesLoader"></a>自动配置核心类SpringFactoriesLoader</h3><p>上面在说@EnableAutoConfiguration的时候有说META-INF下的spring.factories文件，那么这个文件是怎么被spring加载到的呢，其实就是SpringFactoriesLoader类。</p><p>SpringFactoriesLoader是一个供Spring内部使用的通用工厂装载器，SpringFactoriesLoader里有两个方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载工厂类并实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 加载工厂类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在这个SpringBoot应用启动过程中，SpringFactoriesLoader做了以下几件事：</p><ol><li>加载所有META-INF/spring.factories中的Initializer</li><li>加载所有META-INF/spring.factories中的Listener</li><li>加载EnvironmentPostProcessor（允许在Spring应用构建之前定制环境配置）</li><li>接下来加载Properties和YAML的PropertySourceLoader（针对SpringBoot的两种配置文件的加载器）</li><li>各种异常情况的FailureAnalyzer（异常解释器）</li><li>加载SpringBoot内部实现的各种AutoConfiguration</li><li>模板引擎TemplateAvailabilityProvider（如Freemarker、Thymeleaf、Jsp、Velocity等）</li></ol><p>总得来说，SpringFactoriesLoader和@EnableAutoConfiguration配合起来，整体功能就是查找spring.factories文件，加载自动配置类。</p><h2 id="整体启动流程"><a href="#整体启动流程" class="headerlink" title="整体启动流程"></a>整体启动流程</h2><p>在我们执行入口类的main方法之后，运行SpringApplication.run，后面new了一个SpringApplication对象，然后执行它的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(sources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化SpringApplication类"><a href="#初始化SpringApplication类" class="headerlink" title="初始化SpringApplication类"></a>初始化SpringApplication类</h3><p>创建一个SpringApplication对象时，会调用它自己的initialize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 根据标志类javax.servlet.Servlet,org.springframework.web.context.ConfigurableWebApplicationContext是否存在，判断是否是web环境</span></span><br><span class="line"><span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">  <span class="comment">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationContextInitializer，并实例化</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">  <span class="comment">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationListener，并实例化</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="comment">// 获取执行当前main方法的类，也就是启动类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注 ：</strong> 各方法内部执行逻辑就不做说明了，比较简单，需要的读者可自行点进源码查看</p><h3 id="执行核心run方法"><a href="#执行核心run方法" class="headerlink" title="执行核心run方法"></a>执行核心run方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 启动任务执行的时间监听器</span></span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">  </span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 设置系统java.awt.headless属性，确定是否开启headless模式(默认开启headless模式)</span></span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">// 开始广播启动</span></span><br><span class="line">listeners.started();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建SpringBoot默认启动参数对象</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 根据启动参数创建并配置Environment(所有有效的配置，如Profile)，并遍历所有的listeners，广播启动环境已准备</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);</span><br><span class="line">        <span class="comment">// 打印启动图案</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// 根据标志类(上面有提到过)，创建对应类型的ApplicationContext</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line">        <span class="comment">// 创建异常解析器(当启动失败时，由此解析器处理失败结果)</span></span><br><span class="line">analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">        <span class="comment">// 准备Spring上下文环境</span></span><br><span class="line">        <span class="comment">// 在这个方法中，主要完成了以下几件事：</span></span><br><span class="line">        <span class="comment">// 1、设置SpringBoot的环境配置(Environment)</span></span><br><span class="line">        <span class="comment">// 2、注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader</span></span><br><span class="line">        <span class="comment">//3、加载ApplicationContextInitializer初始化器，并进行初始化</span></span><br><span class="line">        <span class="comment">//4、统一将上面的Environment、BeanNameGenerator、ResourceLoader使用默认的Bean注册器进行注册</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br><span class="line">        <span class="comment">// 注册一个关闭Spring容器的钩子</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">        <span class="comment">// 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法</span></span><br><span class="line">        <span class="comment">// ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组</span></span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 通知所有listener，Spring容器启动完成</span></span><br><span class="line">listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 停止时间监听器</span></span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 启动有异常时，调用异常解析器解析异常信息，根据异常级别，判断是否退出Spring容器</span></span><br><span class="line">handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run方法整体执行流程总结"><a href="#run方法整体执行流程总结" class="headerlink" title="run方法整体执行流程总结"></a>run方法整体执行流程总结</h4><ul><li>获取所有的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。&lt;/p&gt;
&lt;p&gt;此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。
    
    </summary>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Docker高级应用</title>
    <link href="/2017/10/11/Docker%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <id>/2017/10/11/Docker高级应用/</id>
    <published>2017-10-11T12:45:22.000Z</published>
    <updated>2018-10-26T08:05:16.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>Linux内核从2.4.19开始引入namespace的概念，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace中的进程看起来拥有它们自己的隔离的全局系统资源实例。<a id="more"></a></p><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离内容</th><th>在容器语境下的隔离效果</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>每个容器可以有自己的hostname和domainname</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td><td>每个容器有其自己的System V IPC和POSIX消息队列文件系统，因此，只有在同一个IPC的进程之间才能互相通信</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td><td>每个PID中的namespace中的进程可以有其独立的PID；每个容器可以有其PID为1的root进程；也使得容器可以在不同的host之间迁移，因为namespace中的进程ID和host无关了。这也使得容器中的每个进程有两个PID：容器中的PID和host上的PID</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备、网络栈、端口等</td><td>每个容器都有其独立的网络设备，IP地址，IP路由表，/proc/net目录，端口号等。这也使得多个容器内的同一个应用都绑定在各自容器的80端口上</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点（文件系统）</td><td>每个容器能看到不同的文件系统层次结构</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和组ID空间</td><td>在User中的进程的用户和组ID可以和在host上不通。每个container可以有不同的user和group id；一个host上的非特权用户可以成为User中的特权用户</td></tr></tbody></table><p>Docker的资源隔离也是通过这六种方式实现的，在容器启动时，Docker会创建这六种namespace实例，然后把容器中的所有进程放到这些namespace中，使得Docker容器中只能看到隔离的系统资源。</p><h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p>docker目前支持四种网络工作的方式，分别为host，container，none，bridge。下面简单介绍下这几种网络模式。</p><ul><li><p>host模式</p><p>Docker使用了Linux的Namespaces技术来进行资源隔离，如网卡、路由、进程等。如果启动容器的时候使用host模式，那么容器不会自己去创建一个独立的Network Namespace，而是与主机共用一个Network Namespace。容器也不会虚拟出自己的网卡、IP等，而是使用宿主机的IP和端口。</p></li><li><p>container模式</p><p>container模式指定创建的新的容器和已经存在的一个容器共享一个Network Namespace。container模式通过-net=container:NAME_OR_ID指定共享的容器。</p></li><li><p>none模式</p><p>在这种模式下，容器拥有自己的Network Namespace，但是不做任何网络配置，需要我们自己给容器添加网卡、IP等。</p></li><li><p>bridge模式</p><p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到虚拟网桥上，实现容器和容器的主机的互连。​</p></li></ul>]]></content>
    
    <summary type="html">
    
      在实际应用中，因为一些问题而对Docker做了更深层次的了解，下面将列举一些Docker容器及Linux操作系统相关的知识。
    
    </summary>
    
      <category term="Docker" scheme="/categories/Docker/"/>
    
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Lombok常用注解</title>
    <link href="/2017/09/07/Lombok%E4%BD%BF%E7%94%A8/"/>
    <id>/2017/09/07/Lombok使用/</id>
    <published>2017-09-07T15:43:12.000Z</published>
    <updated>2018-10-31T01:29:44.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projectlombok.org/" target="_blank" rel="noopener">Project Lombok</a> is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as <code>val</code>, and much more.</p><p>这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。<a id="more"></a></p><p>下面简单介绍一些在开发中常用的注解。</p><h2 id="Lombok常用注解"><a href="#Lombok常用注解" class="headerlink" title="Lombok常用注解"></a>Lombok常用注解</h2><h3 id="Getter"><a href="#Getter" class="headerlink" title="@Getter"></a>@Getter</h3><p>可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。</p><h3 id="Setter"><a href="#Setter" class="headerlink" title="@Setter"></a>@Setter</h3><p>和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>只能标注到类上，相当于是重写此类的toString方法。</p><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>只能标注到类上，相当于是重写此类的hashCode和equals方法。</p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>只能标注到类上，生成无参的构造方法。</p><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。</p><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"passwd"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码编译后对应下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">passwd</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User buildUser = User.builder().password(<span class="string">"haha"</span>).username(<span class="string">"gaga"</span>).build();</span><br></pre></td></tr></table></figure><p>可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及<a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a>的<code>com.google.common.collect</code> 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;String&gt; projects;</span><br><span class="line">        UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">username</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">password</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">project</span><span class="params">(String project)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.projects == <span class="keyword">null</span>) <span class="keyword">this</span>.projects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">this</span>.projects.add(project);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">projects</span><span class="params">(Collection&lt;? extends String&gt; projects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.projects == <span class="keyword">null</span>) <span class="keyword">this</span>.projects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">this</span>.projects.addAll(projects);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">clearProjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.projects != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.projects.clear();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Set&lt;String&gt; projects;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.projects == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.projects.size()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    projects = java.util.Collections.emptySet();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    projects = java.util.Collections.singleton(<span class="keyword">this</span>.projects.get(<span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    projects = <span class="keyword">new</span> java.util.LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.projects.size() &lt; <span class="number">1073741824</span> ? <span class="number">1</span> + <span class="keyword">this</span>.projects.size() + (<span class="keyword">this</span>.projects.size() - <span class="number">3</span>) / <span class="number">3</span> : Integer.MAX_VALUE);</span><br><span class="line">                    projects.addAll(<span class="keyword">this</span>.projects);</span><br><span class="line">                    projects = java.util.Collections.unmodifiableSet(projects);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(username, password, projects);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User.UserBuilder(username="</span> + <span class="keyword">this</span>.username + <span class="string">", password="</span> + <span class="keyword">this</span>.password + <span class="string">", projects="</span> + <span class="keyword">this</span>.projects + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h3><p>可标注在类或属性上，当然最实用的功能还是标注到类上。</p><p><strong>标注到类上</strong>，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> User().setPassword(<span class="string">"gaga"</span>).setUsername(<span class="string">"haha"</span>);</span><br></pre></td></tr></table></figure><p>fluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User().password(<span class="string">"gaga"</span>).username(<span class="string">"haha"</span>);</span><br><span class="line">String password = user.password();</span><br><span class="line">String username = user.username();</span><br></pre></td></tr></table></figure><p><strong>标注到属性上</strong>，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors</span>(prefix = <span class="string">"a"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">private</span> String aUsername = <span class="string">"gaga"</span>;</span><br></pre></td></tr></table></figure><p>编译之后为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> aUsername;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String aUsername)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.aUsername = aUsername;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Project Lombok&lt;/a&gt; is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as &lt;code&gt;val&lt;/code&gt;, and much more.&lt;/p&gt;
&lt;p&gt;这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。
    
    </summary>
    
      <category term="开发工具框架" scheme="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="开发工具框架" scheme="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="/2017/06/18/Dockerfile%E5%9F%BA%E7%A1%80/"/>
    <id>/2017/06/18/Dockerfile基础/</id>
    <published>2017-06-18T15:21:34.000Z</published>
    <updated>2018-10-26T08:07:14.754Z</updated>
    
    <content type="html"><![CDATA[<p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。<a id="more"></a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。</p><p>一般Dockerfile文件分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author:docker_user</span></span><br><span class="line"><span class="comment"># Command format: Instruction [arguments / command] ..</span></span><br><span class="line"><span class="comment"># 第一行必须制定基于的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user docker_user@email.com</span><br><span class="line"><span class="comment"># 镜像的操作指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"deb http://archive.ubuntu.com/ubuntu/ raring main universe"</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"\ndaemon off;"</span> &gt;&gt; /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="bash"><span class="comment"># 容器启动时执行指令</span></span></span><br><span class="line"><span class="bash">CMD /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure><p>Dockerfile文件编写时，一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息</p><p>后面则是镜像操作指令，例如RUN指令，镜像增加新的一层，并提交。最后是CMD指令，来指定运行容器时的操作命令。</p><p>以下有两个摘自书上的Dockerfile例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ngnix</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># VERSION 0.0.1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> Victor Vieux &lt;victor@docker.com&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></span><br></pre></td></tr></table></figure><p>此Dockerfile文件是在ubuntu父镜像基础上安装inotify-tools、nginx、apache2、openssh-server软件，从而创建一个新的Nginx镜像</p><p><strong>注</strong> ：inotify-tools是为linux下inotify文件监控工具提供的一套c的开发接口库函数，同时还提供了一系列的命令行工具，这些工具可以用来监控文件系统的事件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Firefox over VNC</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># VERSION 0.3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="comment"># Install vnc, xvfb in order to reate a 'fake' display and firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefox</span></span><br><span class="line"><span class="bash">RUN mkdir /.vnc</span></span><br><span class="line"><span class="bash"><span class="comment"># Setup a password</span></span></span><br><span class="line"><span class="bash">RUN xllvnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class="line"><span class="bash"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></span></span><br><span class="line"><span class="bash">RUN bash -c <span class="string">'echo "firefox" &gt;&gt; /.bashrc'</span></span></span><br><span class="line"><span class="bash">EXPOSE 5900</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"xllvnc"</span>, <span class="string">"-forever"</span>, <span class="string">"-usepw"</span>, <span class="string">"-create"</span>]</span></span><br></pre></td></tr></table></figure><p>此Dockerfile基于ubuntu父镜像，安装filefox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。</p><p>Dockerfile指令说明</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">FROM</td><td style="text-align:center">指定所创建镜像的基础镜像</td></tr><tr><td style="text-align:center">MAINTAINER</td><td style="text-align:center">指定维护者信息</td></tr><tr><td style="text-align:center">RUN</td><td style="text-align:center">运行命令</td></tr><tr><td style="text-align:center">CMD</td><td style="text-align:center">指定启动容器时默认执行的命令</td></tr><tr><td style="text-align:center">LABEL</td><td style="text-align:center">指定生成镜像的元数据标签信息</td></tr><tr><td style="text-align:center">EXPOSE</td><td style="text-align:center">声明镜像内服务所监听的端口</td></tr><tr><td style="text-align:center">ENV</td><td style="text-align:center">指定容器环境变量</td></tr><tr><td style="text-align:center">ADD</td><td style="text-align:center">复制指定的 \&lt;src> 路径下的内容到容器中的 \&lt;dest> 路径下，\&lt;src> 可以为URL；如果为tar文件，会自动解压到 \&lt;dest> 路径下</td></tr><tr><td style="text-align:center">COPY</td><td style="text-align:center">复制本地主机的 \&lt;src> 路径下的内容到镜像中的 \&lt;dest> 路径下；一般情况下推荐使用COPY而不是ADD</td></tr><tr><td style="text-align:center">ENTRYPOINT</td><td style="text-align:center">指定镜像的默认入口</td></tr><tr><td style="text-align:center">VOLUME</td><td style="text-align:center">创建数据卷挂载点</td></tr><tr><td style="text-align:center">USER</td><td style="text-align:center">指定运行容器时的用户名或UID</td></tr><tr><td style="text-align:center">WORKDIR</td><td style="text-align:center">配置工作目录</td></tr><tr><td style="text-align:center">ARG</td><td style="text-align:center">指定镜像内使用的参数 （例如版本号信息等）</td></tr><tr><td style="text-align:center">ONBUILD</td><td style="text-align:center">配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令</td></tr><tr><td style="text-align:center">STOPSIGNAL</td><td style="text-align:center">容器退出的信号值</td></tr><tr><td style="text-align:center">HEALTHCHECK</td><td style="text-align:center">如何进行健康检查</td></tr><tr><td style="text-align:center">SHELL</td><td style="text-align:center">指定使用shell时的默认shell类型</td></tr></tbody></table><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">FROM</span> &lt;image&gt; 或<span class="keyword">FROM</span>&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">MAINTAINER</span> &lt;name&gt;, 指定维护者信息</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt; 或 RUN [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure><p>RUN <command> 将在shell终端中运行命令，即 /bin/sh -c</p><p>RUN [“executable”, “param1”, “param2”]则使用exec执行。</p><p>指定使用其他终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”, “echo hello”]。</p><p>每条RUN指令将在当前镜像基础上执行指令命令，并提交为新的镜像。当命令较长时可以用 \ 来换行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>支持三种格式</p><ul><li><p>使用exec执行，推荐方式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>在/bin/sh中执行，提供给需要交互的应用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure></li><li><p>提供给ENTRYPOINT的默认参数</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure></li></ul><p>指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>例如：EXPOSE 22 80 8443</p><p>就是告诉Docker服务器容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P或者-p来指定端口映射。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...</span></span><br><span class="line"><span class="bash">ENV PATH /usr/<span class="built_in">local</span>/postgres-<span class="variable">$PG_MAJOR</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">ADD</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>该命令将复制指定的<src>到容器中的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</src></dest></src></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">COPY</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>复制本地主机的<src>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<dest>。目标路径不存在时，会自动创建。</dest></src></p><p>当使用本地目录为源目录时，推荐使用COPY</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li><p>使用exec执行，推荐方式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>在shell中执行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure></li></ul><p>配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖</p><p>每个Dockerfile中只能有一个ENTRYPOINT，当制定多个ENTRYPOINT时，只有最后一个生效。</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br></pre></td></tr></table></figure><p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">USER</span> daemon</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或UID，后续的RUN也会使用指定的用户。</p><p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span></span><br></pre></td></tr></table></figure><p>要临时获取管理员权限可以使用gosu，不推荐sudo</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><p>为后续RUN、CMD、ENTRYPOINT指令配置工作目录。</p><p>可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="bash">WORKDIR b</span></span><br><span class="line"><span class="bash">WORKDIR c</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>上面指令最终结果为：/a/b/c</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="bash">ONBUILD RUN /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line"><span class="bash">[...]</span></span><br></pre></td></tr></table></figure><p>Dockerfile使用上面的内容创建了镜像image-A，如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在Dockerfile后面添加了两条指令，如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> image-A</span><br><span class="line"><span class="comment"># Automatically run the following</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="bash">RUN /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br></pre></td></tr></table></figure><p>使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。
    
    </summary>
    
      <category term="Docker" scheme="/categories/Docker/"/>
    
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="/2017/06/16/Docker%E5%85%A5%E9%97%A8/"/>
    <id>/2017/06/16/Docker入门/</id>
    <published>2017-06-16T11:24:41.000Z</published>
    <updated>2018-10-26T08:07:01.414Z</updated>
    
    <content type="html"><![CDATA[<p>一直听说虚拟化、Docker这些概念，但是一直没有机会，刚好公司项目要使用Docker部署，公司也没有这方面的人员了解，花几天时间突击一下这方面知识。<a id="more"></a></p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="http://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从Apache2.0协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。<br><!--more--></p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布</li><li>在服务型环境中部署和调整数据库或其他的后台应用</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境</li></ul><h2 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h2><ul><li>简化程序</li></ul><p>Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。过去需要数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。</p><ul><li>避免选择恐惧症</li></ul><p>Docker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个镜像部署。</p><ul><li>节省开支</li></ul><p>云计算时代的到来，使开发者不必为了追求效果而配置高额的硬件，Docker改变了高性能必然高价格的思维定势。Docker与云的结合，让云空间得到更充分的利用，不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p><h2 id="Centos的Docker安装与启动"><a href="#Centos的Docker安装与启动" class="headerlink" title="Centos的Docker安装与启动"></a>Centos的Docker安装与启动</h2><ul><li>检查Linux版本</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>uname -r</span><br></pre></td></tr></table></figure><p>Docker要求Centos系统的内核版本高于3.10</p><ul><li>安装Docker</li></ul><p>切换到root用户，更新系统</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum update</span></span><br></pre></td></tr></table></figure><p>安装Docker</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum -y install docker</span></span><br></pre></td></tr></table></figure><p>Docker软件包和依赖包已经包含在默认的Centos-Extras软件源里了。</p><p>如果这种方式不能安装，也可使用下面的命令进行安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl -fsSL http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>执行这个脚本后会添加docker.repo源并安装Docker</p><p>注：若安装失败，重新使用上面命令安装时有时会报错，只需要去家目录下的.docker目录中将docker的相关文件删除，然后重新执行命令下载即可。</p><ul><li>启动Docker服务</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#<span class="built_in"> service </span>docker start</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> hello-world</span><br></pre></td></tr></table></figure><p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器中运行</p><blockquote><p>Docker的基本使用</p></blockquote><ul><li>查看Docker常用命令</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker --help</span><br></pre></td></tr></table></figure><p>如我们需要查看其中某个命令的使用方法，可使用以下命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><ul><li>运行一个web应用</li></ul><p>我们在Docker容器中运行一个Python Flask应用来运行一个web应用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure><p>我们先来看看之前执行docker run –help命令后的结果吧</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="string">[OPTIONS]</span> IMAGE <span class="string">[COMMAND]</span> <span class="string">[ARG...]</span></span><br></pre></td></tr></table></figure><p>OPTIONS: 代表run命令的一些参数</p><p>IMAGE: 镜像名</p><p>COMMAND: 运行镜像之后要执行的命令</p><p>ARG…: 命令需要的一些参数</p><p>好了，我们现在来看看刚刚我们运行一个web应用的命令</p><p>-d, –detach=false          Run container in background and print container ID</p><p>让容器在后台运行，默认是关闭的</p><p>-P, –publish-all=false     Publish all exposed ports to random ports</p><p>让容器内部使用的网络端口映射到我们使用的主机上，默认是关闭的</p><p>注意: 我们这里用的是大写的-P</p><p>小写的-p手动将容器端口映射到宿主机上的端口，如</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> -d -p <span class="number">5000</span>:<span class="number">5000</span> training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看WEB应用容器"><a href="#查看WEB应用容器" class="headerlink" title="查看WEB应用容器"></a>查看WEB应用容器</h3><h4 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">f5d5071807a8        training/webapp     <span class="string">"python app.py"</span>     <span class="number">13</span> seconds ago      Up <span class="number">12</span> seconds       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp   prickly_davinci</span><br></pre></td></tr></table></figure><h4 id="查看所有已构建的容器"><a href="#查看所有已构建的容器" class="headerlink" title="查看所有已构建的容器"></a>查看所有已构建的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>包括正在运行，已停止的等多个容器。</p><p>结果中有容器ID，镜像名，端口，容器名等信息，其中端口显示了prickly_davinci容器端口的映射情况，此时映射的端口是容器自动做的映射，如果我们运行时没使用-P，而是使用-p手动映射，此处则显示手动指定的端口。其次容器名称此处为容器自动指定的，我们可以通过–name来手动指定，如</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker <span class="built_in">run</span> -d -p <span class="number">5000</span>:<span class="number">5000</span> <span class="comment">--name webapp training/webapp python app.py</span></span><br></pre></td></tr></table></figure><p>上面默认都是绑定tcp端口，如果要绑定UDP端口，可以在端口后面加上/udp</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker <span class="built_in">run</span> -d -p <span class="number">5000</span>:<span class="number">5000</span>/udp <span class="comment">--name webapp training/webapp python app.py</span></span><br></pre></td></tr></table></figure><h4 id="查看容器端口映射"><a href="#查看容器端口映射" class="headerlink" title="查看容器端口映射"></a>查看容器端口映射</h4><ul><li>使用容器ID查看容器端口映射情况</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker<span class="built_in"> port </span>f5d5071807a8</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure><ul><li>使用容器名称查看端口映射情况</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker<span class="built_in"> port </span>prickly_davinci</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure><ul><li>查看具体某个端口的映射情况</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost docker]$ docker<span class="built_in"> port </span>tomcat 8080</span><br><span class="line">0.0.0.0:8080</span><br></pre></td></tr></table></figure><p><strong>接下来凡是使用容器标识操作的都使用容器名称，并且容器ID也支持相同的命令操</strong></p><h4 id="查看WEB应用程序日志"><a href="#查看WEB应用程序日志" class="headerlink" title="查看WEB应用程序日志"></a>查看WEB应用程序日志</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker logs -f modest_banach</span><br></pre></td></tr></table></figure><p>-f: 让docker logs像使用tail -f一样来输出容器内部的标准输出</p><h4 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker top modest_banach</span><br></pre></td></tr></table></figure><h4 id="检查WEB应用程序"><a href="#检查WEB应用程序" class="headerlink" title="检查WEB应用程序"></a>检查WEB应用程序</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker inspect modest_banach</span><br></pre></td></tr></table></figure><h4 id="停止WEB应用程序"><a href="#停止WEB应用程序" class="headerlink" title="停止WEB应用程序"></a>停止WEB应用程序</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker stop modest_banach</span><br></pre></td></tr></table></figure><h4 id="启动WEB应用容器"><a href="#启动WEB应用容器" class="headerlink" title="启动WEB应用容器"></a>启动WEB应用容器</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker start modest_banach</span><br></pre></td></tr></table></figure><h4 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker restart modest_banach</span><br></pre></td></tr></table></figure><p><strong>注</strong>：正在运行的容器我们可以使用restart来重启</p><h4 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker rm modest_banach</span><br></pre></td></tr></table></figure><p><strong>注：</strong>移除容器时，容器必须是停止状态。</p><h2 id="Docker镜像的使用"><a href="#Docker镜像的使用" class="headerlink" title="Docker镜像的使用"></a>Docker镜像的使用</h2><h3 id="查看本地镜像列表"><a href="#查看本地镜像列表" class="headerlink" title="查看本地镜像列表"></a>查看本地镜像列表</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost ~]$ docker images</span><br><span class="line">REPOSITORY          <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             VIRTUAL SIZE</span><br></pre></td></tr></table></figure><p>各个选项说明：</p><ul><li>REPOSITORY: 表示镜像的仓库源</li><li>TAG: 镜像的标签</li><li>IMAGE ID: 镜像ID</li><li>CREATED: 镜像创建时间</li><li>SIZE: 镜像大小</li></ul><p>同一个仓库源可以有多个TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10,14.04等多个不同的版本，我们可以使用REPOSITORY:TAG来定义不同的镜像，如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="meta">@localhost</span> ~]$ docker run -t -i <span class="string">ubuntu:</span><span class="number">15.10</span> <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure><p>如果不指定镜像的版本标签，docker将默认使用latest镜像</p><h3 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull <span class="symbol">ubuntu:</span><span class="number">15.10</span></span><br></pre></td></tr></table></figure><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker search httpd</span><br><span class="line">NAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br></pre></td></tr></table></figure><p>NAME: 镜像仓库源的名称</p><p>DESCRIPTION: 镜像的描述</p><p>OFFICIAL: 是否是docker官方发布</p><h3 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull httpd</span><br></pre></td></tr></table></figure><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="symbol">@localhost</span> ~]$ docker <span class="built_in">run</span> httpd</span><br></pre></td></tr></table></figure><h3 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h3><h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：</p><p>1、从已经创建的容器中更新镜像，并且提交这个镜像</p><p>2、使用Dockerfile指令来创建一个新的镜像</p><h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>在更新镜像之前，我们先用以下命令启动容器，在容器中使用apt-get update命令更新，完成操作后使用exit退出容器。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker run -t -i <span class="symbol">ubuntu:</span><span class="number">15.10</span> /bin/bash</span><br><span class="line">root<span class="variable">@2d60a31b8bdf</span><span class="symbol">:/</span><span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure><h4 id="提交容器副本"><a href="#提交容器副本" class="headerlink" title="提交容器副本"></a>提交容器副本</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker commit -m=<span class="string">"has update"</span> -a=<span class="string">"ubuntu/update"</span> <span class="number">2</span>d60a31b8bdf <span class="symbol">ubuntu:</span>v2</span><br><span class="line">ea547a1aa6de52e24092ff3ca13ae7ae58cd35123e2e58e6f3d784208af7ef5e</span><br></pre></td></tr></table></figure><p>-m: 提交的描述信息</p><p>-a: 指定镜像作者</p><p>2d60a31b8bdf: 容器ID</p><p>runoob/ubuntu:v2: 指定要创建的目标镜像名</p><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>创建Dockerfile，使用docker build命令来创建一个新的镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost docker]$ cat Dockerfile</span><br><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">"artislong@haha.com"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span></span><br><span class="line"><span class="bash">RUN     useradd docker</span></span><br><span class="line"><span class="bash">RUN     /bin/<span class="built_in">echo</span> <span class="string">'docker:123456'</span> |chpasswd</span></span><br><span class="line"><span class="bash">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">"LANG=\"en_US.UTF-8\""</span> &gt;/etc/default/<span class="built_in">local</span></span></span><br><span class="line"><span class="bash">EXPOSE  22</span></span><br><span class="line"><span class="bash">EXPOSE  80</span></span><br><span class="line"><span class="bash">CMD     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure><p>Dockerfile是一个文本格式的配置文件，它由一行行命令语句（指令）组成，并且支持以#开头的注释行</p><p>每个指令都会在镜像上创建一个新的层，每个指令的前缀都必须大写。</p><p>第一条FROM，指定使用哪个镜像源</p><p>RUN指令告诉docker在镜像内执行命令，安装了什么。。。</p><p>然后我们通过Dockerfile文件来构建一个镜像</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> docker]<span class="variable">$ </span>docker build -t runoob/<span class="symbol">centos:</span><span class="number">6.7</span> .</span><br></pre></td></tr></table></figure><p>千万不要忽略最后面的 “.”，它表示使用当前目录下的Dockerfile文件</p><p>-t: 指定要创建的目标镜像名</p><p>​</p><p>我们可以使用新的镜像来创建容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost docker]$ docker <span class="builtin-name">run</span> -t -i runoob/centos:6.7 /bin/bash</span><br><span class="line">[root@ebd742bf9af0 /]# id docker</span><br><span class="line"><span class="attribute">uid</span>=500(docker) <span class="attribute">gid</span>=500(docker) <span class="attribute">groups</span>=500(docker)</span><br></pre></td></tr></table></figure><p>从上面看到新镜像已经包含了我们创建的用户docker</p><h4 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost docker]$ docker <span class="keyword">tag</span> <span class="title">f38a8f197ee4</span> runoob/centos:dev</span><br></pre></td></tr></table></figure><p>docker tag 镜像ID，镜像源名和新的标签名</p><h2 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h2><h3 id="创建Nginx目录，用于存放后面相关文件"><a href="#创建Nginx目录，用于存放后面相关文件" class="headerlink" title="创建Nginx目录，用于存放后面相关文件"></a>创建Nginx目录，用于存放后面相关文件</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>mkdir -p ~<span class="regexp">/nginx/www</span> ~<span class="regexp">/nginx/logs</span> ~<span class="regexp">/nginx/conf</span></span><br></pre></td></tr></table></figure><p>www目录将映射为nginx容器配置的虚拟目录</p><p>logs目录将映射为nginx容器的日志目录</p><p>conf目录里的配置文件将映射为nginx容器的配置文件</p><h3 id="查找Docker-Hub上的nginx镜像"><a href="#查找Docker-Hub上的nginx镜像" class="headerlink" title="查找Docker Hub上的nginx镜像"></a>查找Docker Hub上的nginx镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker search nginx</span><br></pre></td></tr></table></figure><h3 id="拉取官方nginx镜像"><a href="#拉取官方nginx镜像" class="headerlink" title="拉取官方nginx镜像"></a>拉取官方nginx镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="查看nginx本地镜像"><a href="#查看nginx本地镜像" class="headerlink" title="查看nginx本地镜像"></a>查看nginx本地镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker images nginx</span><br></pre></td></tr></table></figure><h3 id="使用nginx镜像"><a href="#使用nginx镜像" class="headerlink" title="使用nginx镜像"></a>使用nginx镜像</h3><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost nginx]$ docker run -<span class="selector-tag">i</span> -t -d -<span class="selector-tag">p</span> <span class="number">80</span>:<span class="number">8081</span> --name nginx -v <span class="variable">$PWD</span>/www:/www -v <span class="variable">$PWD</span>/conf/nginx<span class="selector-class">.conf</span>:/etc/nginx/nginx<span class="selector-class">.conf</span> -v <span class="variable">$PWD</span>/logs:/wwwlogs  -d nginx</span><br></pre></td></tr></table></figure><p>-p 80:8081: 将容器的80端口映射到宿主机的8081端口</p><p>-name nginx: 将容器命名为nginx</p><p>-v $PWD/www:/www: 将主机中当前目录下的www目录挂载到容器的/www</p><p>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf: 将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</p><p>-v $PWD/logs:/wwwlogs: 将主机中当前目录下的logs挂载到容器的/wwwlogs</p><h4 id="查看容器启动情况"><a href="#查看容器启动情况" class="headerlink" title="查看容器启动情况"></a>查看容器启动情况</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> nginx]<span class="variable">$ </span>docker ps</span><br></pre></td></tr></table></figure><h4 id="通过浏览器访问"><a href="#通过浏览器访问" class="headerlink" title="通过浏览器访问"></a>通过浏览器访问</h4><p>访问路径为: http://主机ip:8081/ ，就可访问nginx</p><h2 id="Docker安装Tomcat"><a href="#Docker安装Tomcat" class="headerlink" title="Docker安装Tomcat"></a>Docker安装Tomcat</h2><h3 id="创建tomcat的相关目录"><a href="#创建tomcat的相关目录" class="headerlink" title="创建tomcat的相关目录"></a>创建tomcat的相关目录</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>mkdir -p ~<span class="regexp">/tomcat/webapps</span> ~<span class="regexp">/tomcat/logs</span> ~<span class="regexp">/tomcat/conf</span></span><br></pre></td></tr></table></figure><h3 id="查找Docker-Hub上的tomcat镜像"><a href="#查找Docker-Hub上的tomcat镜像" class="headerlink" title="查找Docker Hub上的tomcat镜像"></a>查找Docker Hub上的tomcat镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker search tomcat</span><br></pre></td></tr></table></figure><h3 id="拉取官方tomcat镜像"><a href="#拉取官方tomcat镜像" class="headerlink" title="拉取官方tomcat镜像"></a>拉取官方tomcat镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> ~]<span class="variable">$ </span>docker pull tomcat</span><br></pre></td></tr></table></figure><h3 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h3><ul><li><p>在~/tomcat/webapps目录下创建test目录</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> webapps]<span class="variable">$ </span>mkdir test</span><br></pre></td></tr></table></figure></li><li><p>进入test目录，编写测试页面</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker<span class="variable">@localhost</span> test]<span class="variable">$ </span>vi index.html</span><br></pre></td></tr></table></figure><p>index.html文件内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>docker中的tomcat测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                Hello, World! <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                哈哈哈哈，运行成功啦啦啦啦啦</span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行tomcat容器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[docker@localhost tomcat]$ docker <span class="keyword">run</span><span class="bash"> --name tomcat -p 8080:8080 -v <span class="variable">$PWD</span>/webapps/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span> -d tomcat</span></span><br></pre></td></tr></table></figure><p>命令说明：</p><p>-v $PWD/webapps/test:/usr/local/tomcat/webapps/test: 将主机中当前目录下的test挂载到容器的/test</p><p>启动成功后，在浏览器访问：http://主机ip:8080/test/index.html即可访问刚才编写的测试页面</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直听说虚拟化、Docker这些概念，但是一直没有机会，刚好公司项目要使用Docker部署，公司也没有这方面的人员了解，花几天时间突击一下这方面知识。
    
    </summary>
    
      <category term="Docker" scheme="/categories/Docker/"/>
    
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置</title>
    <link href="/2017/06/07/Nginx%E9%85%8D%E7%BD%AE/"/>
    <id>/2017/06/07/Nginx配置/</id>
    <published>2017-06-07T13:35:33.000Z</published>
    <updated>2018-10-26T07:58:48.526Z</updated>
    
    <content type="html"><![CDATA[<p>在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了）<a id="more"></a></p><p>Nginx的配置文件在安装目录下的conf目录中，一些默认配置都在这个目录下。</p><p>nginx.conf 的注释符号为 #</p><p>打开nginx.conf文件，可以大概浏览一下，配置文件基本可以分为几个模块</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.              #全局块</span><br><span class="line">events &#123;         #events块</span><br><span class="line">   <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span>.   #http全局块</span><br><span class="line">   <span class="built_in"> server </span>       #server块</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">..</span>.       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">..</span>.</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">..</span>.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">..</span>.</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">..</span>.     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局块<br>  配置影像nginx的全局指令。一般有nginx的进程数，错误日志文件路径，nginx的主进程号等</li><li>events块<br>  配置Nginx的工作模式，每个进程的最大连接数等</li><li>http块<br>  可以嵌套多个server，配置代理，缓存，日志等功能以及第三方模块的配置。如文件引入，mime-type定义，连接超时时间，单连接请求数等等</li><li>server块<br>  配置虚拟主机的相关参数，一个http中可以有多个server</li><li>location块<br>  配置请求的路由，以及各种页面的处理情况</li></ul><p>附上一个比较完整的Nginx配置文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"><span class="attribute">user</span> www www;</span><br><span class="line"><span class="comment">#nginx进程数，建议设置为等于CPU总核心数。</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">info</span>;</span><br><span class="line"><span class="comment">#进程文件</span></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"><span class="comment">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types; <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream; <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#charset utf-8; #默认编码</span></span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>; <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>; <span class="comment">#上传文件大小限制</span></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>; <span class="comment">#设定请求缓</span></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>; <span class="comment">#设定请求缓</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>; <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>; <span class="comment">#防止网络阻塞</span></span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>; <span class="comment">#防止网络阻塞</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">120</span>; <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#gzip模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>; <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>; <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>; <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>; <span class="comment">#压缩等级</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    <span class="comment">#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span></span><br><span class="line"> </span><br><span class="line">    <span class="attribute">upstream</span> blog.test.com &#123;</span><br><span class="line">        <span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.121:80</span> weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.122:80</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.123:80</span> weight=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        <span class="attribute">server_name</span> www.test.com test.com;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">root</span> /data/www/test;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(php|php5)?$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#JS和CSS缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="attribute">log_format</span> access <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">        <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$http_user_agent</span>" <span class="variable">$http_x_forwarded_for</span>'</span>;</span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="attribute">access_log</span> /var/log/nginx/testaccess.log access;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#对 "/" 启用反向代理</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:88;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">10m</span>; <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>; <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>; <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">90</span>; <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">90</span>; <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="attribute">proxy_buffer_size</span> <span class="number">4k</span>; <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">32k</span>; <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class="line">            <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>; <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">            <span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#设定查看Nginx状态的地址</span></span><br><span class="line">        <span class="attribute">location</span> /NginxStatus &#123;</span><br><span class="line">            <span class="attribute">stub_status</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">auth_basic</span> <span class="string">"NginxStatus"</span>;</span><br><span class="line">            <span class="attribute">auth_basic_user_file</span> conf/htpasswd;</span><br><span class="line">            <span class="comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#所有静态文件由nginx直接读取不经过tomcat或resin</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$</span> &#123; </span><br><span class="line">            <span class="attribute">expires</span> <span class="number">15d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(js|css)?$</span> &#123; </span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：配置中的IP读者可改为自己实际的IP地址</p><p>接下来附上在实际应用中积累的一些配置</p><ul><li>请求体缓存目录</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_body_temp_path /app/appdata/temp<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>请求体缓存大小</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size <span class="number">1000</span>M<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>代理缓存目录</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_path /app/appdata/proxy_temp<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>代理连接超时时间</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout <span class="number">180</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>代理读数据超时时间</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout <span class="number">180</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>代理发送数据超时时间</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_send_timeout <span class="number">180</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>代理缓存大小</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffers <span class="number">4</span> <span class="number">1024</span>M;</span><br><span class="line">proxy_buffer_size <span class="number">128</span>M;</span><br><span class="line">proxy_busy_buffers_size <span class="number">2048</span>M;</span><br><span class="line">proxy_temp_file_write_size <span class="number">2048</span>M;</span><br></pre></td></tr></table></figure><ul><li>关闭nginx版本号显示</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure><ul><li>cookie丢失配置</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location <span class="meta-keyword">/apps/</span><span class="class">ajax </span>&#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//localhost:8081/payplatform;</span></span><br><span class="line">    proxy_cookie_path  /payplatform  <span class="meta-keyword">/apps/</span>ajax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>: 此种方式只适应于请求直接转发到实地址的方式，不适用转发到upstream模式。</p><ul><li>配置Nginx文件管理服务</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8088</span>;</span><br><span class="line">    <span class="attribute">server_name</span> file;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>    /Users/admin/share;</span><br><span class="line">        <span class="attribute">add_header</span> Cache-Control <span class="string">"no-cache, must-revalidate"</span>;</span><br><span class="line">        <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: red; font-size: 18px">在配置部分，强调一个重要的问题，Nginx配置文件中，空格很重要。</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了）
    
    </summary>
    
      <category term="Nginx" scheme="/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Tomcat+Redis实现Session共享</title>
    <link href="/2017/06/07/Session%E5%85%B1%E4%BA%AB/"/>
    <id>/2017/06/07/Session共享/</id>
    <published>2017-06-07T06:43:12.000Z</published>
    <updated>2018-10-31T01:24:08.463Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。<a id="more"></a></p><p>经过查资料，找到了几种解决session共享的方案。</p><ul><li><p>不适用session，换作cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能把session改成cookie，就能避开session的一些弊端，也有资料表明在集群系统中不能使用session。但是博主思考再三，公司项目的session中存储一些比较重要的信息，在以后的业务中也会使用session中的数据，所以直接使用cookie这种方案果断舍弃。</span><br></pre></td></tr></table></figure></li><li><p>应用服务器自行实现共享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让服务器自行实现session共享，就需要提供一个后端服务器都能访问的公共容器来存储session，比如redis或者memcache，当系统需要获取session时，直接从redis或memcache中获取即可。</span><br></pre></td></tr></table></figure><p>以上两种方式都与Nginx没多大关系了。下面说说使用nginx如何处理</p></li><li><p>ip_hash</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">之前的博客中对upstream的几种方式做了介绍，相信大家还记得ip_hash的介绍吧，每个请求按访问<span class="built_in">ip</span>的hash结果分配，这样每个访问固定访问一个后端服务器。</span><br><span class="line">这样一来这个<span class="built_in">ip</span>下的某个客户端和某个后端服务器就能建立稳固的session。这样每个客户端都只对应一个服务器，那就不存在需要共享session的需要了，不过只用<span class="built_in">ip</span>这个因子来分配后端，所以还是存在一些缺陷，不能在以下情况下使用：</span><br><span class="line"><span class="number">1</span>、nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx就得不到正确的<span class="built_in">ip</span>，也就不能根据<span class="built_in">ip</span>来分配后端了。比如squid(一个高性能的代理缓存服务器)作为最前端，那么nginx只能获取到squid所在服务器的<span class="built_in">ip</span>地址，这种分流方式肯定会混乱的。</span><br><span class="line"><span class="number">2</span>、nginx的后端还有其他方式的负载均衡。如果nginx后端又有其他的负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台服务器上。</span><br></pre></td></tr></table></figure></li><li><p>upstream_hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块大多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享；</span><br><span class="line">这种方式不是很理解，就不做累述了，以后再慢慢研究。读者可自行查找资料学习。</span><br></pre></td></tr></table></figure></li></ul><p>来自于网络上的方案介绍完了，接下来说说博主项目中的实际操作。</p><p>博主最初的打算是使用redis来缓存系统数据，刚好也可以实现session共享。可惜，客户公司方面服务器资源不够，不让使用redis，上面第二种方案瞬间被阉割掉了，有点不爽。这里必须吐槽吐槽客户公司。</p><p>由于不让使用redis，所以只能使用第三种方式了，这里就不做太多的累述了，比较简单，配置nginx负载均衡的时候将upstream的方式配置为ip_hash即可，具体配置方式在上篇“Nginx负载均衡配置”中已有例子，可做参考。</p><p>简单的解释一下公司项目架构，公司项目采用前后台分离的架构，前端页面使用angularJS实现一种单页面应用，后台服务则使用SpringBoot为前端提供数据服务，后台开发者只需要关注后端逻辑，然后将前端需要的数据转为json传给前端，而不需要去考虑页面的跳转等，而前端人员也不需要关注后台逻辑，可以全身心的提供前端的用户体验度，最主要的是前后台分离后，系统开发职责划分的更加清晰。</p><p>关于前后台分离方案，这个<a href="http://web.jobbole.com/82637/" target="_blank" rel="noopener">博客</a>讲的比较好，读者可做参考。 </p><p>这样就完了？没有，这就完了这篇博客也太水了，虽然客户公司不让使用redis，但是博主还是自己抽时间使用nginx+tomcat+redis来自己实现session共享。</p><p>——————————————————————这是一个分隔线——————————————————————-</p><h4 id="1、软件准备"><a href="#1、软件准备" class="headerlink" title="1、软件准备"></a>1、软件准备</h4><p>因为是自己玩，所以直接在windows上开工了。</p><p>nginx-1.11.5，apache-tomcat-7.0.55，redis-2.6.12(windows版)</p><p>读者可从<a href="https://github.com/ArtIsLong/documentation/blob/master/resources/nginx_redis_tomcat.zip" target="_blank" rel="noopener">这里</a>下载。其中有三个jar包最为重要：</p><p>commons-pool-1.6.jar，jedis-2.1.0.jar，tomcat-redis-session-manager-tomcat7.jar，在软件包中的tomcat的lib目录下可找到。</p><h4 id="2、配置tomcat"><a href="#2、配置tomcat" class="headerlink" title="2、配置tomcat"></a>2、配置tomcat</h4><p>在tomcat中的context.xml文件中加入以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span>  <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">host</span>=<span class="string">"localhost"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">port</span>=<span class="string">"6379"</span></span></span><br><span class="line"><span class="tag"><span class="attr">database</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>将配置好的tomcat三份，分别命名为apache-tomcat-7.0.55-1，apache-tomcat-7.0.55-2，apache-tomcat-7.0.55-3，然后去将每个tomcat的端口改掉，分别改为8081，8082，8083</p><h4 id="3、配置Nginx"><a href="#3、配置Nginx" class="headerlink" title="3、配置Nginx"></a>3、配置Nginx</h4><p>将三个tomcat服务器用nginx代理，</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span>  localhost   &#123;</span><br><span class="line"><span class="attribute">server</span>   localhost:<span class="number">8081</span> weight=<span class="number">1</span>;  </span><br><span class="line"><span class="attribute">server</span>   localhost:<span class="number">8082</span> weight=<span class="number">1</span>;  </span><br><span class="line"><span class="attribute">server</span>   localhost:<span class="number">8083</span> weight=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、测试页面"><a href="#4、测试页面" class="headerlink" title="4、测试页面"></a>4、测试页面</h4><p>在tomcat的webapp目录下新建test目录，在test中新建index.jsp，然后给三个tomcat都拷贝一份</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh-CN"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">out.println(request.getSession().getId());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这可能是可与Hello，World媲美的页面了。</p><h4 id="5、启动测试"><a href="#5、启动测试" class="headerlink" title="5、启动测试"></a>5、启动测试</h4><p>先启动redis，在启动三个tomcat，最后再启动nginx，然后访问页面。</p><p>有两种访问方式：</p><ul><li>直接访问三个tomcat，【<a href="http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。" target="_blank" rel="noopener">http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。</a></li><li>多次访问nginx，【<a href="http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致" target="_blank" rel="noopener">http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致</a></li></ul><p>好了，这种session共享完成。</p><p>这种Session共享是基于Tomcat完成的，不会侵入项目。当前还有一种实现Session共享的方式，Spring全家桶中，Spring Session框架就是专门做Session管控的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Session" scheme="/tags/Session/"/>
    
      <category term="集群" scheme="/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="/2017/06/06/Nginx%E5%85%A5%E9%97%A8/"/>
    <id>/2017/06/06/Nginx入门/</id>
    <published>2017-06-06T14:50:56.000Z</published>
    <updated>2018-10-25T15:59:33.776Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<a id="more"></a><br>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h3 id="Nginx服务器的安装"><a href="#Nginx服务器的安装" class="headerlink" title="Nginx服务器的安装"></a>Nginx服务器的安装</h3><p>windowns版Nginx下载地址：<a href="http://nginx.org/en/docs/windows.html" target="_blank" rel="noopener">http://nginx.org/en/docs/windows.html</a></p><blockquote><p>windows上安装Nginx比较简单，Nginx官方已经提供了打包好的.exe的运行文件，不需要用户自己去编译运行。直接打开上面的地址，下载好windows版的nginx，解压后双击nginx.exe或者在命令窗口运行nginx.exe即可。</p></blockquote><blockquote><p>因为Nginx默认端口是80端口，所以启动成功之后在浏览器地址栏输入localhost就可以看到Nginx的欢迎页面。</p></blockquote><p>linux版的Nginx下载地址：<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></p><blockquote><p>下载nginx之前，请确保自己的linux系统已经安装了g++，gcc。因为nginx是纯C语言编写，在linux下安装时需要去编译源码安装。</p></blockquote><ul><li><p>解压Nginx源码包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">nginx-1</span><span class="selector-class">.11</span><span class="selector-class">.5</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure></li><li><p>设置一下nginx配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> chmod -R 755 nginx-1.11.5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> nginx-1.11.5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/nginx  <span class="comment">#此处设置prefix，是设置nginx的安装路径，可通过./configure --help查看其它参数项</span></span></span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">make</span> | <span class="built_in">make</span> install <span class="meta">#将源码文件编译成可执行文件和各种库文件，并将其复制到上面设置的安装目录中</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>编译安装中的常见问题</li></ul><blockquote><p>缺少Nginx组件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://www.openssl.org/<span class="built_in">source</span>/openssl-fips-2.0.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar zxvf openssl-fips-2.0.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> openssl-fips-2.0.10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./config &amp;&amp; make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://zlib.net/zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar zxvf zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> zlib-1.2.11</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure &amp;&amp; make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar zxvf pcre-8.40.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> pcre-8.40</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure &amp;&amp; make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><blockquote><p>缺少g++环境</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install gcc-c++</span></span><br></pre></td></tr></table></figure><blockquote><p>报错了，error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> whereis libpcre.so.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/lib/libpcre.so.1 /lib64</span></span><br></pre></td></tr></table></figure><ul><li><p>启动nginx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这一步可以不指定nginx配置文件(nginx.conf文件在默认目录下时可不指定)</span></span><br><span class="line">&gt; <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx -c /u</span>sr<span class="regexp">/local/</span>nginx<span class="regexp">/conf/</span>nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>还有最重要的一步，打开Nginx的防火墙端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> vi /etc/sysconfig/iptables</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 添加端口，如： -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /etc/init.d/iptables restart <span class="comment">#重启防火墙，让修改生效</span></span></span><br></pre></td></tr></table></figure></li><li><p>在自己本机的浏览器中输入localhost就可以看到Nginx的欢迎页面。</p></li></ul><h3 id="Nginx其他常用参数"><a href="#Nginx其他常用参数" class="headerlink" title="Nginx其他常用参数"></a>Nginx其他常用参数</h3><ul><li>校验配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> nginx -t</span></span><br></pre></td></tr></table></figure><ul><li>重启</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> nginx -s reload</span></span><br></pre></td></tr></table></figure><ul><li>安全停止</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> nginx -s quit</span></span><br></pre></td></tr></table></figure><p>其他参数可使用’man nginx’命令查看，就不一一列举了。</p><p><strong>注</strong>: Nginx停止也可以通过杀死Nginx进程的方式停止，Nginx默认会启动两个进程，master和worker，直接杀死进程时需要kill这两个进程。<br>master和worker的区别在以后的文章中再做说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。
    
    </summary>
    
      <category term="Nginx" scheme="/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡配置</title>
    <link href="/2017/06/05/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/"/>
    <id>/2017/06/05/Nginx负载均衡配置/</id>
    <published>2017-06-05T15:56:34.000Z</published>
    <updated>2018-10-26T08:09:51.332Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx的负载均衡是通过upstream实现的，在前面也有介绍过，下面对Nginx常用的upstream方式<a id="more"></a></p><ul><li>nginx的upstream的几种方式</li></ul><blockquote><p>轮询（默认）</p></blockquote><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器冗机，能自动剔除。</p><blockquote><p>ip_hash</p></blockquote><p>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。</p><blockquote><p>weight</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>fair(第三方)</p></blockquote><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><blockquote><p>url_hash(第三方)</p></blockquote><p>按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。</p><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream blog.test.com &#123;</span><br><span class="line">    #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">   <span class="built_in"> server </span>192.168.80.121:80 <span class="attribute">weight</span>=3;</span><br><span class="line">   <span class="built_in"> server </span>192.168.80.122:80 <span class="attribute">weight</span>=2;</span><br><span class="line">   <span class="built_in"> server </span>192.168.80.123:80 <span class="attribute">weight</span>=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，负载均衡简单的理解其实可以看做是用户请求Nginx，Nginx将用户的请求URL按照配置的方式截取，然后按照配置的upstream的方式请求后端服务器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx的负载均衡是通过upstream实现的，在前面也有介绍过，下面对Nginx常用的upstream方式
    
    </summary>
    
      <category term="Nginx" scheme="/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot动态数据源切换</title>
    <link href="/2017/06/01/SpringBoot%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    <id>/2017/06/01/SpringBoot动态数据源切换/</id>
    <published>2017-06-01T13:30:56.000Z</published>
    <updated>2018-10-26T07:27:05.609Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。<a id="more"></a></p><hr><ul><li>1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve the current target DataSource. Determines the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #determineCurrentLookupKey() current lookup key&#125;, performs</span></span><br><span class="line"><span class="comment"> * a lookup in the &#123;<span class="doctag">@link</span> #setTargetDataSources targetDataSources&#125; map,</span></span><br><span class="line"><span class="comment"> * falls back to the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setDefaultTargetDataSource default target DataSource&#125; if necessary.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #determineCurrentLookupKey()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the current lookup key. This will typically be</span></span><br><span class="line"><span class="comment"> * implemented to check a thread-bound transaction context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Allows for arbitrary keys. The returned key needs</span></span><br><span class="line"><span class="comment"> * to match the stored lookup key type, as resolved by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #resolveSpecifiedLookupKey&#125; method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的）</p><p>所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。</p><ul><li>2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * DynamicDataSourceContextHolder代码中使用setDataSource</span></span><br><span class="line"><span class="comment">         * 设置当前的数据源，在路由类中使用getDataSource进行获取，</span></span><br><span class="line"><span class="comment">         * 交给AbstractRoutingDataSource进行注入使用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> DynamicDataSourceContextHolder.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、创建统一数据源管理类DynamicDataSourceContextHolder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程本地环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dataSources = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 管理所有的数据源Id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; dataSourceIds = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line">        dataSources.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSources.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSources.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断指定的DataSource当前是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsDataSource</span><span class="params">(String dataSourceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSourceIds.contains(dataSourceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、重点来了，创建动态数据源注册器DynamicDataSourceRegister</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceRegister</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认数据连接池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DATASOURCE_TYPE_DEFAULT = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; dataSourceType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认数据源</span></span><br><span class="line">    <span class="keyword">private</span> DataSource defaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DataSource&gt; dataSourceMaps = <span class="keyword">new</span> HashMap&lt;String, DataSource&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载多数据源配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        initDefaultDataSource(environment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化默认数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDefaultDataSource</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        RelaxedPropertyResolver propertyResolver = <span class="keyword">new</span> RelaxedPropertyResolver(environment, <span class="string">"spring.datasource."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(propertyResolver.getProperty(<span class="string">"type"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(<span class="string">"type"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建数据源</span></span><br><span class="line">        String jndiName = propertyResolver.getProperty(<span class="string">"jndi-name"</span>);</span><br><span class="line">        String[] jndiNames = jndiName.split(<span class="string">","</span>);</span><br><span class="line">        defaultDataSource = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        dataSourceMaps.put(<span class="string">"AAA"</span>, defaultDataSource);</span><br><span class="line">        DataSource dataSource1 = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">1</span>]);</span><br><span class="line">        dataSourceMaps.put(<span class="string">"BBB"</span>, dataSource1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 将主数据源添加到更多数据源中</span></span><br><span class="line">        targetDataSources.put(<span class="string">"dataSource"</span>, defaultDataSource);</span><br><span class="line">        DynamicDataSourceContextHolder.dataSourceIds.add(<span class="string">"dataSource"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加更多数据源</span></span><br><span class="line">        targetDataSources.putAll(dataSourceMaps);</span><br><span class="line">        <span class="keyword">for</span>(String key : dataSourceMaps.keySet()) &#123;</span><br><span class="line">            DynamicDataSourceContextHolder.dataSourceIds.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建DynamicDataSource</span></span><br><span class="line">        GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(DynamicDataSource.class);</span><br><span class="line">        beanDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"defaultTargetDataSource"</span>, defaultDataSource);</span><br><span class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"targetDataSources"</span>, targetDataSources);</span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"dataSource"</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释&gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中&gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。</code></pre><p>5、将动态数据源注册器导入到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DynamicDataSourceRegister.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件：</p></blockquote><ol><li>导入的类使用@Configuration进行标注</li><li>导入的类中至少有一个使用@Bean标准的方法</li><li>导入的类实现了ImportSelector接口</li><li>导入的类实现了ImportBeanDefinitionRegistrar接口</li></ol><p>到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础</p><ul><li>6、新建一个TargetDataSource注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetDataSource &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。</p><ul><li>7、新建数据源切换AOP切面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(-<span class="number">1</span>)  <span class="comment">//保证此AOP在@Transactional之前执行</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过注解切换数据源（细粒度）</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(targetDataSource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">changeDataSource</span><span class="params">(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        String dataSourceId = targetDataSource.value();</span><br><span class="line">        <span class="keyword">if</span>(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123;</span><br><span class="line">            logger.info(<span class="string">"系统将使用&#123;&#125;数据源"</span>, dataSourceId);</span><br><span class="line">            DynamicDataSourceContextHolder.setDataSource(dataSourceId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;"</span>, dataSourceId, joinPoint.getSignature());</span><br><span class="line">        &#125;</span><br><span class="line">        object=joinPoint.proceed();</span><br><span class="line">        DynamicDataSourceContextHolder.clearDataSource();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。</p><p>最后附一下JNDI数据源在application.properties文件中的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name=java:comp/env/jdbc/AAA,java:comp/env/jdbc/BBB</span><br></pre></td></tr></table></figure><p>其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。</p><p>————————————————华丽的分割线—————————————————-</p><p>在项目的进展中，此数据源切换已被改造，增加了<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="noopener">Druid数据源</a>加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。
    
    </summary>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
      <category term="多数据源" scheme="/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>java基本数据类型缓存解析</title>
    <link href="/2016/12/22/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    <id>/2016/12/22/Java基本数据类型缓存解析/</id>
    <published>2016-12-21T16:46:28.000Z</published>
    <updated>2018-11-01T13:01:19.508Z</updated>
    
    <content type="html"><![CDATA[<p>此文对Jdk的常用基础类的缓存机制进行简单分析。<a id="more"></a></p><h2 id="基本类型缓存解析"><a href="#基本类型缓存解析" class="headerlink" title="基本类型缓存解析"></a>基本类型缓存解析</h2><h3 id="Integer缓存解析："><a href="#Integer缓存解析：" class="headerlink" title="Integer缓存解析："></a>Integer缓存解析：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="comment">// high value may be configured by property</span></span><br><span class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">           String integerCacheHighPropValue =</span><br><span class="line">               sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">               i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">               <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">               h = Math.min(i, Integer.MAX_VALUE - (-low));</span><br><span class="line">           &#125;</span><br><span class="line">           high = h;</span><br><span class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> j = low;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。</p><p><br>2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。</p><p><br>3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。</p><p></p><p>所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false</p><p><br><strong><strong>注意</strong></strong>：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=<size>参数即可。</size></p><h3 id="Long及Byte、Character缓存解析"><a href="#Long及Byte、Character缓存解析" class="headerlink" title="Long及Byte、Character缓存解析"></a>Long及Byte、Character缓存解析</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> LongCache()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Long</span> cache[] = <span class="keyword">new</span> <span class="keyword">Long</span>[-(<span class="number">-128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="keyword">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Long</span> valueOf(<span class="keyword">long</span> l) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">-128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文对Jdk的常用基础类的缓存机制进行简单分析。
    
    </summary>
    
      <category term="Java基础" scheme="/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot核心</title>
    <link href="/2016/12/18/Spring-Boot%E6%A0%B8%E5%BF%83/"/>
    <id>/2016/12/18/Spring-Boot核心/</id>
    <published>2016-12-18T12:26:36.000Z</published>
    <updated>2018-05-12T16:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot基本配置"><a href="#一、Spring-Boot基本配置" class="headerlink" title="一、Spring Boot基本配置"></a>一、Spring Boot基本配置</h2><p></p><p></p><h4 id="1、入口类和-SpringBootApplication"><a href="#1、入口类和-SpringBootApplication" class="headerlink" title="1、入口类和@SpringBootApplication"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),<a id="more"></a>启动Spring Boot应用项目。</p><h4 id="2、关闭特定的自动配置"><a href="#2、关闭特定的自动配置" class="headerlink" title="2、关闭特定的自动配置"></a>2、关闭特定的自动配置</h4><p>通过<strong>@SpringBootApplication</strong>源码可以看出，关闭特定的自动配置应该使用<strong>@SpringBootApplication</strong>注解的exclude参数，例如:<br>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p><h4 id="3、定制Banner"><a href="#3、定制Banner" class="headerlink" title="3、定制Banner"></a>3、定制Banner</h4><p>在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。<br>1）我们在src/main/resources下新建一个banner.txt<br>2）通过<a href="http://patorjk.com/software/taag" target="_blank" rel="noopener">http://patorjk.com/software/taag</a>网站生成字符，将生成的字符复制到banner.txt文件中<br>3）自动程序，这时控制台图案将变成刚才生成的图案</p><h4 id="4、关闭banner"><a href="#4、关闭banner" class="headerlink" title="4、关闭banner"></a>4、关闭banner</h4><p>在main方法中修改为(Spring Boot:1.4.0)：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication <span class="built_in">application</span> = new SpringApplication(Chapter1Application.<span class="built_in">class</span>);</span><br><span class="line">   <span class="built_in">application</span>.setBannerMode(Mode.OFF);</span><br><span class="line">   <span class="built_in">application</span>.<span class="built_in">run</span>(args);</span><br></pre></td></tr></table></figure><p>  或者</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">new</span> <span class="title">SpringApplicationBuilder</span>(<span class="type">Chapter1Application</span>.class) <span class="comment">//</span></span></span><br><span class="line"><span class="function">               .<span class="title">bannerMode</span>(<span class="type">Mode</span>.<span class="type">OFF</span>) <span class="comment">//</span></span></span><br><span class="line"><span class="function">.<span class="title">run</span>(args);</span></span><br></pre></td></tr></table></figure><h4 id="5、Spring-Boot配置文件"><a href="#5、Spring-Boot配置文件" class="headerlink" title="5、Spring Boot配置文件"></a>5、Spring Boot配置文件</h4><p>Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。</p><p><br>Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p><br>Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。<br><br>例如：<br><br>修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在<br>application.properties中添加：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="attribute">port</span>=9090</span><br><span class="line">   server.<span class="attribute">context-path</span>=/helloBoot</span><br></pre></td></tr></table></figure><h4 id="6、官方starter-pom"><a href="#6、官方starter-pom" class="headerlink" title="6、官方starter pom"></a>6、官方starter pom</h4><p><div style="color:gray"><br>spring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持<br><br>spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  准生产特性，用来监控和管理应用<br><br>spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  提供基于ssh协议的监控和管理<br><br>spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用spring-rabbit来支持AMQP<br><br>spring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成<br><br>spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Batch的支持<br><br>spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Cache抽象的支持<br><br>spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法<br><br>spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-elasticsearch对Elasticsearch的支持<br><br>spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-gemfire对分布式存储GenFile的支持<br><br>spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对JPA的支持，包含spring-data-jpa，spring-orm和Hibernate<br><br>spring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-mongodb，对MongoDB进行支持<br><br>spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务<br><br>spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-solr对Apache Solr数据检索平台的支持<br><br>spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对FreeMarker模板引擎的支持<br><br>spring-boot-starter-groovy-templates  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持<br><br>spring-boot-starter-hateoas  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas  通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持<br><br>spring-boot-starter-hornetq  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持<br><br>spring-boot-starter-integration  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持<br><br>spring-boot-starter-jdbc  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持<br><br>spring-boot-starter-jersey  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持<br><br>spring-boot-starter-jta-atomikos  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持<br><br>spring-boot-starter-jta-bitronix  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持<br><br>spring-boot-starter-mail  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持<br><br>spring-boot-starter-mobile  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持<br><br>spring-boot-starter-mustache  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持<br><br>spring-boot-starter-redis  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reids<br><br>spring-boot-starter-security  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持<br><br>spring-boot-starter-social-faceboot  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持<br><br>spring-boot-starter-social-twitter   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持<br><br>spring-boot-starter-test  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板<br><br>spring-boot-starter-thymeleaf  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置<br><br>spring-boot-starter-velocity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持<br><br>spring-boot-starter-web  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvc<br><br>spring-boot-starter-Tomcat  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcat<br><br>spring-boot-starter-Jetty  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcat<br><br>spring-boot-starter-undertow  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcat<br><br>spring-boot-starter-logging  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logback<br><br>spring-boot-starter-log4j  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架<br><br>spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持<br><br>spring-boot-starter-ws  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持<br><br></div></p><p></p><p><br>还有第三方为Spring Boot所写的starter pom,这里不做介绍</p><h4 id="7、使用xml配置"><a href="#7、使用xml配置" class="headerlink" title="7、使用xml配置"></a>7、使用xml配置</h4><p>Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的<strong>@ImportResource</strong>来加载xml配置，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">ImportResource</span>(&#123;"<span class="selector-tag">classpath</span><span class="selector-pseudo">:context.xml</span>”&#125;)</span><br></pre></td></tr></table></figure><h4 id="8、命令行参数配置"><a href="#8、命令行参数配置" class="headerlink" title="8、命令行参数配置"></a>8、命令行参数配置</h4><p>Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行<br>可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号</p><h4 id="9、常规属性配置"><a href="#9、常规属性配置" class="headerlink" title="9、常规属性配置"></a>9、常规属性配置</h4><p>在常规Spring环境下，注入properties文件里的值得方式，通过<strong>@PropertySource</strong>指明properties文件的位置，然后通过<strong>@Value</strong>注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用<strong>@Value</strong>注入即可。<br><br>例如：<br><br>在application.properties文件中添加属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.<span class="attribute">author</span>=cm</span><br><span class="line">book.<span class="attribute">name</span>=spring boot</span><br></pre></td></tr></table></figure><p>在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PropertiesTests &#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"book.author"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span> author;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"book.name"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> getAuthor() &#123;</span><br><span class="line"><span class="keyword">return</span> author;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> setAuthor(<span class="built_in">String</span> author) &#123;</span><br><span class="line"><span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、类型安全的配置（基于properties）"><a href="#10、类型安全的配置（基于properties）" class="headerlink" title="10、类型安全的配置（基于properties）"></a>10、类型安全的配置（基于properties）</h4><p>Spring Boot提供了基于类型安全的配置方式，通过<strong>@ConfigurationProperties</strong>将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PropertiesTests &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span> author;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> getAuthor() &#123;</span><br><span class="line"><span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> setAuthor(<span class="built_in">String</span> author) &#123;</span><br><span class="line"><span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、日志配置"><a href="#11、日志配置" class="headerlink" title="11、日志配置"></a>11、日志配置</h4><p>Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。</p><p><br>默认情况下，Spring Boot使用Logback作为日志框架。日志级别:<strong><strong>logging.file=/home/cm/mylog.log</strong></strong><br>配置日志文件，格式为logging.level.包名=级别：<strong><strong>logging.level.org.springframework.web=DEBUG</strong></strong></p><h4 id="12、Profile配置"><a href="#12、Profile配置" class="headerlink" title="12、Profile配置"></a>12、Profile配置</h4><p>Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),<br>通过在application.properties中设置<strong><strong>spring.profiles.active=prod</strong></strong>来指定活动的Profile<br>例如：<br><br>我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。<br><br>两种配置文件分别为：<br></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application-prod.properties:  server.<span class="attribute">port</span>=80</span><br><span class="line">application-dev.properties:  server.<span class="attribute">port</span>=8888</span><br></pre></td></tr></table></figure><p>然后在application.properties增加：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=dev(prod)</span><br></pre></td></tr></table></figure><p>通过Profile可以灵活切换Spring Boot项目的配置了。</p><h2 id="二、Spring-Boot运行原理"><a href="#二、Spring-Boot运行原理" class="headerlink" title="二、Spring Boot运行原理"></a>二、Spring Boot运行原理</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：</p><p><br><a href="http://i1.piimg.com/4851/bb6e18a430a22a09.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/bb6e18a430a22a09t.jpg"></a><br><a href="http://i1.piimg.com/4851/73ed190dbda257cb.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/73ed190dbda257cbt.jpg"></a></p><p><br>若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：</p><p><br>1）运行jar时增加—debug参数：java -jar xx.jar —debug</p><p><br>2)在application.properties中设置属性：debug=true（这个方便点）</p><p><br>3）在开发工具启动参数中配置</p><p><br><a href="http://i1.piimg.com/4851/db0610f744b512ec.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/db0610f744b512ect.jpg"></a></p><p></p><h4 id="1、Spring-Boot运行原理解析："><a href="#1、Spring-Boot运行原理解析：" class="headerlink" title="1、Spring Boot运行原理解析："></a>1、Spring Boot运行原理解析：</h4><p> 对@SpringBootApplication注解说明：<br>  <strong>@SpringBootApplication</strong>是一个组合注解，它的核心功能是由<strong>@EnableAutoConfiguration</strong>注解提供的。<br>查看<strong>@EnableAutoConfiguration</strong>源码</p><p><br><a href="http://i1.piimg.com/4851/df2b568388d67082.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/df2b568388d67082t.jpg"></a></p><p><br>这里<strong>@Import</strong>注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。<br><a href="http://i1.piimg.com/4851/8290194ff6bbbda5.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/8290194ff6bbbda5t.jpg"></a><br><br><a href="http://i1.piimg.com/4851/dba6c685c8097175.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/dba6c685c8097175t.jpg"></a></p><p><br>       任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下：</p><p></p><p><div style="color:gray"><br>    @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下<br><br>    @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下<br><br>     @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件<br><br>     @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件<br><br>     @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置<br><br>     @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下<br><br>     @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下<br><br>     @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下<br><br>     @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值<br><br>     @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值<br><br>     @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean<br><br>     @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下<br><br></div></p><p><br>这些注解都是使用了<strong>@Conditional</strong>元注解，不过是使用了不同的条件而已。</p><h4 id="2、分析http的编码配置"><a href="#2、分析http的编码配置" class="headerlink" title="2、分析http的编码配置"></a>2、分析http的编码配置</h4><p>配置参数</p><p>  HttpEncodingProperties的源码如下：</p><p><br><a href="http://i1.piimg.com/4851/01b5f66dfd191b68.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/01b5f66dfd191b68t.jpg"></a></p><p><br>这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。<br>根据条件配置CharacterEncodingFilter的Bean，源码如下:<br><a href="http://i1.piimg.com/4851/6307e6e411a78c22.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://i1.piimg.com/4851/6307e6e411a78c22t.jpg"></a></p><h4 id="3、自定义自动配置（包装成starter-pom）"><a href="#3、自定义自动配置（包装成starter-pom）" class="headerlink" title="3、自定义自动配置（包装成starter pom）"></a>3、自定义自动配置（包装成starter pom）</h4><p>1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2) 新建属性配置类HellpServiceProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG = <span class="string">"world"</span>;</span><br><span class="line">    <span class="keyword">private</span> String msg = MSG;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world</p><p></p><p>3）新建依据类HelloService（此类可以是第三方类库的类）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）新建自动配置类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloServiceProperties.<span class="keyword">class</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(HelloService.<span class="keyword">class</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"hello"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> &#123;</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloServiceProperties helloServiceProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HelloService.<span class="keyword">class</span>)</span><br><span class="line">    <span class="keyword">public</span> HelloService helloService() &#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        helloService.setMsg(helloServiceProperties.getMsg());</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据HelloServiceProperties提供的参数，并通过<strong>@ConditionalOnClass</strong>来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。</p><p><br>5）注册自动配置</p><p><br>在src/main/resources中新建META-INF/spring.factories文件，内容为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.EnableAutoConfiguration</span>=\  com<span class="selector-class">.gnd</span><span class="selector-class">.springboot</span><span class="selector-class">.config</span><span class="selector-class">.HelloServiceAutoConfiguration</span>&lt;br&gt;</span><br></pre></td></tr></table></figure><p>其中“\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔</p><p><br>6）测试自定义自动配置</p><p><br>新建一个maven web工程，添加如下依赖:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.gnd.springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-hello为之前新建的自定义自动配置starter pom</p><p><br>新建测试启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line">public class Chapter11Application &#123;</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private HelloService helloService;</span><br><span class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">helloService</span><span class="selector-class">.sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args)&#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(Chapter11Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试工程之后，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a>“测试，测试结果如下:<br><br><a href="http://p1.bpimg.com/4851/6ff00c546916cb99.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://p1.bpimg.com/4851/6ff00c546916cb99t.jpg"></a></p><p><br>新建application.properties配置文件，内容为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.<span class="attribute">msg</span>=haha</span><br></pre></td></tr></table></figure><p>重启工程，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a>“测试，测试结果如下:<br><a href="http://p1.bpimg.com/4851/fbf8797b19bd1733.png" title="点击显示原始图片" target="_blank" rel="noopener"><img src="http://p1.bpimg.com/4851/fbf8797b19bd1733t.jpg"></a></p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Spring-Boot基本配置&quot;&gt;&lt;a href=&quot;#一、Spring-Boot基本配置&quot; class=&quot;headerlink&quot; title=&quot;一、Spring Boot基本配置&quot;&gt;&lt;/a&gt;一、Spring Boot基本配置&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4 id=&quot;1、入口类和-SpringBootApplication&quot;&gt;&lt;a href=&quot;#1、入口类和-SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;1、入口类和@SpringBootApplication&quot;&gt;&lt;/a&gt;1、入口类和@SpringBootApplication&lt;/h4&gt;&lt;p&gt;Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),
    
    </summary>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
