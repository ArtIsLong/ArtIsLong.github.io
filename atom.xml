<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ArtIsLong的博客]]></title>
  <subtitle><![CDATA[好的程序猿都是野路子]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-06-01T13:31:30.000Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[ArtIsLong的博客]]></name>
    <email><![CDATA[799418876@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[SpringBoot动态数据源切换]]></title>
    <link href="/2017/06/01/SpringBoot%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    <id>/2017/06/01/SpringBoot动态数据源切换/</id>
    <published>2017-06-01T13:30:56.000Z</published>
    <updated>2017-06-01T13:31:30.000Z</updated>
    <content type="html"><![CDATA[<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。<a id="more"></a></p>
<hr>
<ul>
<li>1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line"> * Retrieve the current target DataSource. Determines the</div><div class="line"> * &#123;<span class="doctag">@link</span> #determineCurrentLookupKey() current lookup key&#125;, performs</div><div class="line"> * a lookup in the &#123;<span class="doctag">@link</span> #setTargetDataSources targetDataSources&#125; map,</div><div class="line"> * falls back to the specified</div><div class="line"> * &#123;<span class="doctag">@link</span> #setDefaultTargetDataSource default target DataSource&#125; if necessary.</div><div class="line"> * <span class="doctag">@see</span> #determineCurrentLookupKey()</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> DataSource determineTargetDataSource() &#123;</div><div class="line">	Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</div><div class="line">	Object lookupKey = determineCurrentLookupKey();</div><div class="line">	DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.<span class="keyword">get</span>(lookupKey);</div><div class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="literal">null</span>)) &#123;</div><div class="line">		dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> new IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dataSource;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Determine the current lookup key. This will typically be</div><div class="line"> * implemented to check a thread-bound transaction context.</div><div class="line"> * &lt;p&gt;Allows for arbitrary keys. The returned key needs</div><div class="line"> * to match the stored lookup key type, as resolved by the</div><div class="line"> * &#123;<span class="doctag">@link</span> #resolveSpecifiedLookupKey&#125; method.</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object determineCurrentLookupKey();</div></pre></td></tr></table></figure>
<p>源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的）</p>
<p>所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。</p>
<ul>
<li>2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="type">Object</span> determineCurrentLookupKey() &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * DynamicDataSourceContextHolder代码中使用setDataSource</div><div class="line">         * 设置当前的数据源，在路由类中使用getDataSource进行获取，</div><div class="line">         * 交给AbstractRoutingDataSource进行注入使用。</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="type">DynamicDataSourceContextHolder</span>.getDataSource();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3、创建统一数据源管理类DynamicDataSourceContextHolder</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> DynamicDataSourceContextHolder &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 线程本地环境</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; dataSources = <span class="keyword">new</span> ThreadLocal&lt;<span class="keyword">String</span>&gt;();</div><div class="line">    <span class="comment">// 管理所有的数据源Id</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; dataSourceIds = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> setDataSource(<span class="keyword">String</span> dataSource) &#123;</div><div class="line">        dataSources.set(dataSource);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getDataSource() &#123;</div><div class="line">        <span class="built_in">return</span> dataSources.<span class="built_in">get</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> clearDataSource() &#123;</div><div class="line">        dataSources.<span class="built_in">remove</span>();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断指定的DataSource当前是否存在</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> containsDataSource(<span class="keyword">String</span> dataSourceId) &#123;</div><div class="line">        <span class="built_in">return</span> dataSourceIds.contains(dataSourceId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4、重点来了，创建动态数据源注册器DynamicDataSourceRegister</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 默认数据连接池</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> DATASOURCE_TYPE_DEFAULT = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; dataSourceType;</div><div class="line"></div><div class="line">    <span class="comment">// 默认数据源</span></div><div class="line">    <span class="keyword">private</span> DataSource defaultDataSource;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, DataSource&gt; dataSourceMaps = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, DataSource&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加载多数据源配置</div><div class="line">     * @param environment</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setEnvironment(Environment environment) &#123;</div><div class="line">        initDefaultDataSource(environment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化默认数据源</div><div class="line">     * @param environment</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> initDefaultDataSource(Environment environment) &#123;</div><div class="line">        RelaxedPropertyResolver propertyResolver = <span class="keyword">new</span> RelaxedPropertyResolver(environment, <span class="string">"spring.datasource."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(propertyResolver.getProperty(<span class="string">"type"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(<span class="string">"type"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 创建数据源</span></div><div class="line">        <span class="keyword">String</span> jndiName = propertyResolver.getProperty(<span class="string">"jndi-name"</span>);</div><div class="line">        <span class="keyword">String</span>[] jndiNames = jndiName.<span class="built_in">split</span>(<span class="string">","</span>);</div><div class="line">        defaultDataSource = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        dataSourceMaps.put(<span class="string">"AAA"</span>, defaultDataSource);</div><div class="line">        DataSource dataSource1 = <span class="keyword">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class="number">1</span>]);</div><div class="line">        dataSourceMaps.put(<span class="string">"BBB"</span>, dataSource1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; targetDataSources = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();</div><div class="line">        <span class="comment">// 将主数据源添加到更多数据源中</span></div><div class="line">        targetDataSources.put(<span class="string">"dataSource"</span>, defaultDataSource);</div><div class="line">        DynamicDataSourceContextHolder.dataSourceIds.<span class="built_in">add</span>(<span class="string">"dataSource"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 添加更多数据源</span></div><div class="line">        targetDataSources.putAll(dataSourceMaps);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">key</span> : dataSourceMaps.keySet()) &#123;</div><div class="line">            DynamicDataSourceContextHolder.dataSourceIds.<span class="built_in">add</span>(<span class="built_in">key</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 创建DynamicDataSource</span></div><div class="line">        GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</div><div class="line">        beanDefinition.setBeanClass(DynamicDataSource.class);</div><div class="line">        beanDefinition.setSynthetic(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();</div><div class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"defaultTargetDataSource"</span>, defaultDataSource);</div><div class="line">        mutablePropertyValues.addPropertyValue(<span class="string">"targetDataSources"</span>, targetDataSources);</div><div class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"dataSource"</span>, beanDefinition);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释

&gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中
&gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。
</code></pre><p>5、将动态数据源注册器导入到Spring容器中</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@SpringBootApplication</span></div><div class="line"><span class="variable">@Import</span>(&#123;DynamicDataSourceRegister.class&#125;)</div><div class="line">public class Application &#123;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</div><div class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(Application.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件：</p>
</blockquote>
<ol>
<li>导入的类使用@Configuration进行标注</li>
<li>导入的类中至少有一个使用@Bean标准的方法</li>
<li>导入的类实现了ImportSelector接口</li>
<li>导入的类实现了ImportBeanDefinitionRegistrar接口</li>
</ol>
<p>到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础</p>
<ul>
<li>6、新建一个TargetDataSource注解</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="variable">@Documented</span></div><div class="line">public <span class="variable">@interface</span> TargetDataSource &#123;</div><div class="line">    <span class="selector-tag">String</span> <span class="selector-tag">value</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。</p>
<ul>
<li>7、新建数据源切换AOP切面</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Order(-1)</span>  <span class="comment">//保证此AOP在@Transactional之前执行</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> static <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 通过注解切换数据源（细粒度）</span></div><div class="line">    <span class="meta">@Around(<span class="meta-string">"@annotation(targetDataSource)"</span>)</span></div><div class="line">    <span class="keyword">public</span> Object changeDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable &#123;</div><div class="line">        Object <span class="keyword">object</span> = <span class="literal">null</span>;</div><div class="line">        String dataSourceId = targetDataSource.value();</div><div class="line">        <span class="keyword">if</span>(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123;</div><div class="line">            logger.info(<span class="string">"系统将使用&#123;&#125;数据源"</span>, dataSourceId);</div><div class="line">            DynamicDataSourceContextHolder.setDataSource(dataSourceId);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.debug(<span class="string">"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;"</span>, dataSourceId, joinPoint.getSignature());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">object</span>=joinPoint.proceed();</div><div class="line">        DynamicDataSourceContextHolder.clearDataSource();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">object</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。</p>
<p>最后附一下JNDI数据源在application.properties文件中的配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.jndi-name=<span class="string">java:</span>comp<span class="regexp">/env/</span>jdbc<span class="regexp">/AAA,java:comp/</span>env<span class="regexp">/jdbc/</span>BBB</div></pre></td></tr></table></figure>
<p>其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。</p>
<p>————————————————华丽的分割线—————————————————-</p>
<p>在项目的进展中，此数据源切换已被改造，增加了<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="external">Druid数据源</a>加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。]]>
    
    </summary>
    
      <category term="SpringBoot" scheme="/tags/SpringBoot/"/>
    
      <category term="SpringBoot" scheme="/categories/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人简历]]></title>
    <link href="/2017/02/09/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>/2017/02/09/个人简历/</id>
    <published>2017-02-09T14:38:15.000Z</published>
    <updated>2017-02-15T16:35:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a><center>个人简历</center></h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><blockquote>
<p>姓名：陈敏<br>籍贯：甘肃省平凉市<br>出生年月：1993年3月<br>邮箱：15221499301@139.com<br>联系电话：15221499301<br>博客：<a href="http://artislong.github.io" target="_blank" rel="external">http://artislong.github.io</a><br>github：<a href="https://github.com/artislong" target="_blank" rel="external">https://github.com/artislong</a><br>求职意向：Java研发<a id="more"></a></p>
</blockquote>
<h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote>
<p>简洁清晰的编程习惯，学习能力强<br><br>工作主动，执行力及抗压性强<br><br>热爱开源，喜欢学习各种开源技术<br></p>
</blockquote>
<h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><blockquote>
<p>熟练掌握Java编程语言，有较扎实的代码功底和Java核心基础；<br><br>熟悉HTML,CSS,JavaScript,JQuery前端技术<br><br>掌握Oracle，Mysql两种数据库的使用，熟悉SQL语言，了解Oracle的PL/SQL编程；<br><br>熟练使用SVN进行团队协作开发，熟悉Rational Rose，PowerDesigner建模工具<br><br>掌握Spring Boot，并能够熟练使用<br><br>熟悉Struts2,Hibernate,Spring,SpringMVC,MyBatis<br><br>熟悉Jbpm工作流框架常规工作流程<br><br>熟悉memcache，redis缓存服务器，熟悉其常用操作命令及存储机制<br><br>熟悉Linux常用操作命令</p>
</blockquote>
<h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><blockquote>
<p>2015年11月至2016年5月，进入亚信科技实习，从事新业务工单开发工作</p><p><br>2016年6月转正，进入产商品中心项目组，进行产品服务项目以及产品配置化项目的开发</p>
</blockquote>
<h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><blockquote>
<p>项目名称：OA<br>开发环境：window 7，MySQL 5.6，Tomcat7，jdk1.7<br>开发工具：MyEclipse 10<br>项目描述：本项目主旨为实现办公自动化功能，实现了系统管理、网上交流、审批流转等几大功能，系统管理包括部门管理、员工管理、角色管理，其中，角色管理通过拦截请求url的方式实现了权限控制，通过角色来控制对应角色下的用户对系统的操作权限。使用JBPM工作流框架实现审批流转功能，审批流转具有提交请假单、报销单等功能，审批流程由各级审批人员（经理）进行审批处理。使用DWR框架进行消息推送，实现用户登录提醒功能，并将登录用户信息存储到memcached中，用户可以实时查看在线用户人数及在线用户列表。<br>项目职责：设计与开发<br>项目相关技术：Spring，Struts2，Hibernate，JBPM，DWR，JQuery，Ajax，Memcached，以及JQuery相关插件<br>代码地址：<a href="https://github.com/artislong/OA" target="_blank" rel="external">https://github.com/artislong/OA</a><br>收获：通过项目的练习，使我掌握了SSH框架的基本使用方式，项目中的Jstl标签，El表达式的应用，使我明白了Jstl和El在Web项目中的真正作用，并且使我有了较扎实的代码编写能力。通过拦截url实现权限功能，使我在以后的学习中能够更加容易的掌握Apapche Shiro以及Spring Security安全框架。项目的简单灵活的架构设计，为我打下了项目架构设计的基础。</p>
</blockquote>
<p></p><p></p>
<blockquote>
<p>项目名称：CRM（客户关系管理系统）<br>开发环境：window 7，Oracle，Tomcat6，jdk1.6<br>开发工具：Eclipse JavaEE<br>项目描述：CRM系统作为亚信科技（中国）上海分公司的主要项目，是一款上海移动用户定制业务系统，功能齐全，系统庞大，并且与多个外平台交互。系统强健的功能为业务处理提供全程支撑和监控，实现了业务处理的实时计费，实时监控、实时优惠、实时帐务、实时信息查询和实时处理等多项功能，高效的支撑了业务运营。<br>项目职责：本人负责CRM个人新业务工单的开发，在实习期间，主要完成了一下工作：1、完成CRM短信模板配置界面功能的开发（已上线）。  2、使用Appframe框架提供的批量导入框架（BP）实现了客户投诉信息的批量导入，使用类似于POI的工具解析并处理了Excel数据。  3、梳理CRM系统产品缓存策略，阅读Appframe实现memcached客户端的源码，并对其进行优化。  4、开发扫描客户信息的后台实时处理进程，基本熟悉实时任务和定时任务。<br>项目相关技术：Appframe，Javascript，Ajax<br>收获：CRM系统作为为上海移动服务的主打产品，其中灵活多变的业务逻辑，使我在以后的工作中能够更加容易的理解复杂的业务需求，在掌握技术的前提下能够快速针对需求而做出最有效的实现。虽然整个系统庞大而复杂的业务让开发人员理解困难，但是其各种有效的数据库设计也为我在之后个人独立项目中提供了更多的数据库表的设计灵感。</p>
</blockquote>
<p></p><p></p>
<blockquote>
<p>项目名称：产商品项目<br>开发环境：window 7，Oracle，Tomcat7，jdk1.7<br>开发工具：Intellij Idea<br>项目描述：本项目为产商品中心项目，主要分为读和写两部分。第一部分为服务的开发（既读的部分），服务的开发是在原crm系统服务的基础上，使用SpringBoot+Redis对原有服务进行优化改造；第二部分为配置化项目（既写的部分），主要针对中国移动的各种套餐、活动的配置，采用敏捷开发模式，使用配置化开发方式开发出各种套餐活动的配置化界面。<br><br>项目职责：<br>1、在开发服务的过程中，除过对普通的服务进行改造优化外，本人在项目经理的要求下，完成了组合产品定价服务，为移动商城提供服务支持，其功能类似于淘宝天猫等商城中，不同商品组合购买，可以打不同的折扣。</p><p></p>
</blockquote>
<p>2、在配置化开发部分，主要是采用配置与代码协作开发方式，和同伴一起完成套餐、活动配置模板的开发，并在后期带领实习生完成基本配置工作的入门学习。</p>
<blockquote>
<p>项目相关技术：Spring Boot，Redis，JQuery，Ajax，JSON（Java，JS）<br>收获：使我能够熟练使用Spring Boot框架的同时，也使我掌握了查询优化（Java和Oracle）的基本思想，CRM远程调用产品中心接口的改造，也让我基本掌握了通过http协议调用远程接口的方式，同时，项目中，大量JSON数据的处理，也让我能够熟练的利用JSON工具处理JSON类型的数据。</p>
</blockquote>
<h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><blockquote>
<p>2012.9-2016.6  甘肃农业大学  信息管理与信息系统专业<br>2015.7-2015.11  上海杰普科技有限公司  培训JavaEE开发</p>
</blockquote>
<h3 id="技术经历"><a href="#技术经历" class="headerlink" title="技术经历"></a>技术经历</h3><blockquote>
<p>2013.10月开始自学Java方面相关知识<br>2015.9-2016.3，使用SSH框架完成OA系统的开发，同时作为毕设作品<br>2016.12，参考MyBatis的Mapper配置文件，对Spring自身提供的访问数据库的JdbcTemplate进行封装，主要针对JdbcTemplate的自定义SQL进行封装，设计并开发出一个通用的数据容器，用来存储查询结果，并且配置文件具有热加载功能，最后将其做成Spring Boot的一个Starter POM模块。</p>
</blockquote>
<h3 id="在校荣誉"><a href="#在校荣誉" class="headerlink" title="在校荣誉"></a>在校荣誉</h3><blockquote>
<p>2014年10月  甘肃农业大学计算机技能大赛(设计类)一等奖   校级<br>2014年12月  <a href="http://dasai.lanqiao.org/" target="_blank" rel="external">第六届蓝桥杯全国软件大赛甘肃赛区C语言软件开发三等奖</a>  国家级</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[个人简历  基本信息  姓名：陈敏  籍贯：甘肃省平凉市   出生年月：1993年3月  邮箱：15221499301@139.com  联系电话：15221499301   博客：[http://artislong.github.io](http://artislong.github.io)    github：[https://github.com/artislong](https://github.com/artislong)     求职意向：Java研发]]>
    
    </summary>
    
      <category term="个人简历" scheme="/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
      <category term="个人简历" scheme="/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[封装JdbcTemplate的自定义SQL]]></title>
    <link href="/2017/02/07/%E5%B0%81%E8%A3%85JdbcTemplate%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89SQL/"/>
    <id>/2017/02/07/封装JdbcTemplate的自定义SQL/</id>
    <published>2017-02-07T14:46:56.000Z</published>
    <updated>2017-06-01T14:44:47.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本博文为博主原创，转载请注明出处！</strong></p>
<h3 id="封装思路说明："><a href="#封装思路说明：" class="headerlink" title="封装思路说明："></a>封装思路说明：</h3><p>对JdbcTemplate自定义SQL的封装，主要是参考MyBatis来进行的，但又与MyBatis有很大的区别，主要是针对RowMapper接口进行处理，构造一个统一的数据容器来继承并实现RowMapper接口<a id="more"></a>。通过Dom4j解析自定义SQL的XML配置文件，根据自定义SQL的标识code获取对应的SQL。使用JdbcTemplate或者封装的JdbcClient工具类进行查询等操作，查询出的结果封装到数据容器中。</p>
<p><strong><em>代码路径为：<a href="https://github.com/ArtIsLong/JdbcTemplatePackaging.git" target="_blank" rel="external">https://github.com/ArtIsLong/JdbcTemplatePackaging.git</a></em></strong></p><p></p>
<h2 id="博主对JdbcTemplate封装的步骤："><a href="#博主对JdbcTemplate封装的步骤：" class="headerlink" title="博主对JdbcTemplate封装的步骤："></a>博主对JdbcTemplate封装的步骤：</h2><h3 id="一、封装读取XML的工具类（使用Dom4j实现）"><a href="#一、封装读取XML的工具类（使用Dom4j实现）" class="headerlink" title="一、封装读取XML的工具类（使用Dom4j实现）"></a>一、封装读取XML的工具类（使用Dom4j实现）</h3><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>   多的不说，先上代码，通过代码解释实现思路。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">	public String getSQLByClass(String className, String methodName) &#123;</span></div><div class="line">=======</div><div class="line"><span class="code">   多的不说，先上代码，通过代码解释实现逻辑。</span></div></pre></td></tr></table></figure>
<p>public String getSQLByClass(String className, String methodName) {</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>cbb46b7549f1e65e1a79a5a5d4245d6325a9a1f6<br>        String fileName = DynamicConsts.MAPPER_URL_PREFIX + properties.getUrl() + className + DynamicConsts.PARSE_XML_SUFFEX;   –1–<br>        Element root = null;<br>        Document documentText = null;<br>        SAXReader reader = new SAXReader();<br>        String sql = null;<br>        try {<br>            isReLoad = StringUtils.isEmpty(properties.getIsReLoad()) ? defaultIsReLoad : properties.getIsReLoad(); –2–<br>            if(“true”.equals(isReLoad)) {<br>                documentText = reader.read(new File(fileName));<br>            } else {  –3–<br>                if(docCache.isEmpty() || docCache.get(fileName) == null) {<br>                    documentText = reader.read(new File(fileName));<br>                    docCache.put(fileName, documentText);</p>
<h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><p>cbb46b7549f1e65e1a79a5a5d4245d6325a9a1f6<br>                } else {<br>                    documentText = docCache.get(fileName);<br>                }<br>            }<br>            root = documentText.getRootElement();<br>            Iterator it = root.elementIterator();<br>            while(it.hasNext()) {<br>                Element next = (Element) it.next();<br>                Attribute attribute = next.attribute(“id”);<br>                if(methodName.equals(attribute.getValue())) {  –4–<br>                    sql = String.valueOf(next.getData());<br>                }<br>            }<br>        } catch (DocumentException e) {<br>            e.printStackTrace();<br>            log.error(“获取SQL失败，错误信息:” + e.getMessage());<br>        }<br>        return sql;<br>    }<br>```</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>说明：<br><br>1：读取XML配置文件全路径，配置主要有XML配置文件在工程中的包路径，配置文件固定后缀<br><br>2：读取配置使用重新加载配置文件的配置，配置值为true或false<br><br>3：通过2的配置，来判断XML配置文件修改之后是否需要重新加载；代码思路为，如果isReLoad为true，则程序每次访问，都会去加载XML配置文件，如果为false，则第一次加载之后会将XML配置文件放到内存中，下次访问直接从内存中获取（isReload默认为false，在开发阶段建议设为true）<br><br>4：根据自定义SQL的标识code获取SQL（标识code建议和DAO方法名一致）</p><p></p>
<h3 id="二、封装统一的数据容器"><a href="#二、封装统一的数据容器" class="headerlink" title="二、封装统一的数据容器"></a>二、封装统一的数据容器</h3><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="实现思路：实现RowMapper接口的mapRow方法，遍历ResultSet里的数据，将其存到Map里，其中key默认为表的列名，"><a href="#实现思路：实现RowMapper接口的mapRow方法，遍历ResultSet里的数据，将其存到Map里，其中key默认为表的列名，" class="headerlink" title="实现思路：实现RowMapper接口的mapRow方法，遍历ResultSet里的数据，将其存到Map里，其中key默认为表的列名，"></a>实现思路：实现RowMapper接口的mapRow方法，遍历ResultSet里的数据，将其存到Map里，其中key默认为表的列名，</h1><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>cbb46b7549f1e65e1a79a5a5d4245d6325a9a1f6</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本博文为博主原创，转载请注明出处！</strong></p>
<h3 id="封装思路说明："><a href="#封装思路说明：" class="headerlink" title="封装思路说明："></a>封装思路说明：</h3><p>对JdbcTemplate自定义SQL的封装，主要是参考MyBatis来进行的，但又与MyBatis有很大的区别，主要是针对RowMapper接口进行处理，构造一个统一的数据容器来继承并实现RowMapper接口]]>
    
    </summary>
    
      <category term="jdbcTemplate" scheme="/tags/jdbcTemplate/"/>
    
      <category term="封装JdbcTemplate自定义SQL" scheme="/categories/%E5%B0%81%E8%A3%85JdbcTemplate%E8%87%AA%E5%AE%9A%E4%B9%89SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx+tomcat+redis实现session共享]]></title>
    <link href="/2017/01/27/nginx-tomcat-redis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"/>
    <id>/2017/01/27/nginx-tomcat-redis实现session共享/</id>
    <published>2017-01-27T04:48:26.000Z</published>
    <updated>2017-02-07T14:49:07.000Z</updated>
    <content type="html"><![CDATA[<p>本文是基于window系统实现。</p>
<h2 id="1、软件准备"><a href="#1、软件准备" class="headerlink" title="1、软件准备"></a>1、软件准备</h2>]]></content>
    <summary type="html">
    <![CDATA[使用nginx+tomcat+redis实现sesison共享]]>
    
    </summary>
    
      <category term="session共享" scheme="/tags/session%E5%85%B1%E4%BA%AB/"/>
    
      <category term="session共享" scheme="/categories/session%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js工具库]]></title>
    <link href="/2016/12/22/js%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    <id>/2016/12/22/js工具库/</id>
    <published>2016-12-22T14:14:08.000Z</published>
    <updated>2016-12-22T14:19:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1、时间格式的校验"><a href="#1、时间格式的校验" class="headerlink" title="1、时间格式的校验"></a>1、时间格式的校验</h2><h3 id="1）校验时间格式是否是yyyy-MM-dd-HH-mm-ss格式的时间"><a href="#1）校验时间格式是否是yyyy-MM-dd-HH-mm-ss格式的时间" class="headerlink" title="1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间"></a>1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间<a id="more"></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间</div><div class="line"> * @param obj 输入框对象</div><div class="line"> * @param msg 错误信息</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIsDateTime</span>(<span class="params">obj, msg</span>) </span>&#123;</div><div class="line">    <span class="comment">//var str = "2016-04-15 00:00:00";</span></div><div class="line">    <span class="keyword">if</span>(obj.value != <span class="string">""</span>)&#123;    </div><div class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;) (\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/</span>;     </div><div class="line">        <span class="keyword">var</span> r = str.match(reg);     </div><div class="line">        <span class="keyword">if</span>(r==<span class="literal">null</span>) &#123;</div><div class="line">        	$.showErrorMessage(<span class="string">"校验失败"</span>,msg);</div><div class="line">        	obj.value=<span class="string">""</span>;</div><div class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2）判断日期类型是否为yyyy-MM-dd格式的类型"><a href="#2）判断日期类型是否为yyyy-MM-dd格式的类型" class="headerlink" title="2）判断日期类型是否为yyyy-MM-dd格式的类型"></a>2）判断日期类型是否为yyyy-MM-dd格式的类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间</div><div class="line"> * @param obj 输入框对象</div><div class="line"> * @param msg 错误信息</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIsDate</span>(<span class="params">obj,msg</span>) </span>&#123;</div><div class="line">    <span class="comment">//var str = "2016-04-15";</span></div><div class="line">    <span class="keyword">if</span>(obj.value != <span class="string">""</span>)&#123;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/</span>;</div><div class="line">    <span class="keyword">var</span> r = obj.value.match(reg);</div><div class="line">    <span class="keyword">if</span>(r==<span class="literal">null</span>) &#123;</div><div class="line">        $.showErrorMessage(<span class="string">"校验失败"</span>,msg);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3）判断日期类型是否为hh-mm-ss格式的类型"><a href="#3）判断日期类型是否为hh-mm-ss格式的类型" class="headerlink" title="3）判断日期类型是否为hh:mm:ss格式的类型"></a>3）判断日期类型是否为hh:mm:ss格式的类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间</div><div class="line"> * @param obj 输入框对象</div><div class="line"> * @param msg 错误信息</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIsTime</span>(<span class="params">obj,msg</span>) </span>&#123;</div><div class="line">    <span class="comment">//var str = "16:13:69";</span></div><div class="line">    <span class="keyword">if</span>(obj.value != <span class="string">""</span>)&#123;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/^((20|21|22|23|[0-1]\d)\:[0-5][0-9])(\:[0-5][0-9])?$/</span>;</div><div class="line">    <span class="keyword">var</span> r = obj.value.match(reg);</div><div class="line">    <span class="keyword">if</span>(r==<span class="literal">null</span>) &#123;</div><div class="line">        $.showErrorMessage(<span class="string">"校验失败"</span>,msg);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4）"><a href="#4）" class="headerlink" title="4）"></a>4）</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、时间格式的校验"><a href="#1、时间格式的校验" class="headerlink" title="1、时间格式的校验"></a>1、时间格式的校验</h2><h3 id="1）校验时间格式是否是yyyy-MM-dd-HH-mm-ss格式的时间"><a href="#1）校验时间格式是否是yyyy-MM-dd-HH-mm-ss格式的时间" class="headerlink" title="1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间"></a>1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间]]>
    
    </summary>
    
      <category term="js" scheme="/tags/js/"/>
    
      <category term="util" scheme="/categories/util/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java基本数据类型缓存解析]]></title>
    <link href="/2016/12/22/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    <id>/2016/12/22/java基本数据类型缓存解析/</id>
    <published>2016-12-21T16:46:28.000Z</published>
    <updated>2016-12-22T14:25:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本类型缓存解析"><a href="#基本类型缓存解析" class="headerlink" title="基本类型缓存解析"></a>基本类型缓存解析<a id="more"></a></h2><h3 id="一、Integer缓存解析："><a href="#一、Integer缓存解析：" class="headerlink" title="一、Integer缓存解析："></a>一、Integer缓存解析：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line">       <span class="keyword">static</span> &#123;</div><div class="line">           <span class="comment">// high value may be configured by property</span></div><div class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">           String integerCacheHighPropValue =</div><div class="line">               sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">               i = Math.max(i, <span class="number">127</span>);</div><div class="line">               <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">               h = Math.min(i, Integer.MAX_VALUE - (-low));</div><div class="line">           &#125;</div><div class="line">           high = h;</div><div class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">           <span class="keyword">int</span> j = low;</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line">       &#125;</div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">   	<span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。</p><p><br>2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。</p><p><br>3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。</p><p></p>
<p>所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false</p><p><br><strong><strong>注意</strong></strong>：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=<size>参数即可。</size></p>
<h3 id="二、Long及Byte、Character缓存解析"><a href="#二、Long及Byte、Character缓存解析" class="headerlink" title="二、Long及Byte、Character缓存解析"></a>二、Long及Byte、Character缓存解析</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</div><div class="line">   	<span class="keyword">private</span> LongCache()&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Long</span> cache[] = <span class="keyword">new</span> <span class="keyword">Long</span>[-(<span class="number">-128</span>) + <span class="number">127</span> + <span class="number">1</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</div><div class="line">            cache[i] = <span class="keyword">new</span> <span class="keyword">Long</span>(i - <span class="number">128</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Long</span> valueOf(<span class="keyword">long</span> l) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</div><div class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">-128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></div><div class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">Long</span>(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基本类型缓存解析"><a href="#基本类型缓存解析" class="headerlink" title="基本类型缓存解析"></a>基本类型缓存解析]]>
    
    </summary>
    
      <category term="java缓存" scheme="/tags/java%E7%BC%93%E5%AD%98/"/>
    
      <category term="java基础" scheme="/categories/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven配置]]></title>
    <link href="/2016/12/22/maven%E9%85%8D%E7%BD%AE/"/>
    <id>/2016/12/22/maven配置/</id>
    <published>2016-12-21T16:43:01.000Z</published>
    <updated>2016-12-22T14:25:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="maven打包加载src-main-java中的配置文件"><a href="#maven打包加载src-main-java中的配置文件" class="headerlink" title="maven打包加载src/main/java中的配置文件"></a>maven打包加载src/main/java中的配置文件</h2><p> maven打jar包时，不能识别src/main/java中的配置文件(<em>.xml,</em>.properties)，需要在build中添加以下配置<a id="more"></a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 是否替换资源中的属性 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--</span></div><div class="line">        &lt;includes&gt;</div><div class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</div><div class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</div><div class="line">        &lt;/includes&gt;</div><div class="line">        &lt;filtering&gt;true&lt;/filtering&gt;</div><div class="line">        --&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="maven打包加载src-main-java中的配置文件"><a href="#maven打包加载src-main-java中的配置文件" class="headerlink" title="maven打包加载src/main/java中的配置文件"></a>maven打包加载src/main/java中的配置文件</h2><p> maven打jar包时，不能识别src/main/java中的配置文件(<em>.xml,</em>.properties)，需要在build中添加以下配置]]>
    
    </summary>
    
      <category term="maven" scheme="/tags/maven/"/>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zookeeper集群部署(单机版)]]></title>
    <link href="/2016/12/20/zookeeper%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-%E5%8D%95%E6%9C%BA%E7%89%88/"/>
    <id>/2016/12/20/zookeeper集群部署-单机版/</id>
    <published>2016-12-19T16:05:59.000Z</published>
    <updated>2016-12-22T14:26:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>本文是在机器已经配置好java开发环境的基础上完成的。</em></strong></p>
<h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><p>Zookeeper最新版本是3.4.6，笔者使用zookeeper-3.4.5-cdh5.3.6.tar.gz完成集群的搭建。<br>Zk的其他版本下载地址：<a href="http://www.apache.org/dist/zookeeper/" target="_blank" rel="external">http://www.apache.org/dist/zookeeper/</a><br>将下载好的zookeeper解压，<a id="more"></a>建议重命名为zookeeper-3.4.5-1，并且拷贝出相同的两份，分别命名为zookeeper-3.4.5-2，zookeeper-3.4.5-3。</p><p><br>   然后在适当的目录下新建一个存放zookeeper数据的目录，笔者新建了devtools目录，在devtools目录中新建zookeeper-1目录，在其中增加data目录和log目录（这两个目录的作用在后面会做说明）；然后将zookeeper-1目录拷贝出两份，分别命名为zookeeper-2，zookeeper-3。</p><p><br>笔者目录结构为：</p><p><br><a href="http://i1.piimg.com/4851/34885c8a253a8a22.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/34885c8a253a8a22t.jpg"></a></p><p><br>   到此，软件和环境准备工作已经做好，接下来就需要对zookeeper的相关配置文件做修改了。</p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>新下载的Zookeeper，conf目录下有configuration.xsl，log4j.properties，zoo_sample.cfg三个配置文件，我们需要将zoo_sample.cfg复制一份，命名为zoo.cfg，因为zookeeper启动的时候会读取zoo.cfg文件的配置信息。<br>zoo.cfg文件中有几项参数，主要解释一下三项参数：<br><br>tickTime=2000  基本事件单元，以毫秒为单位。它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。<br><br>clientPort=2181  监听客户端连接的端口。<br><br>dataDir=/tmp/zookeeper  zookeeper默认存放数据的目录</p><p></p>
<p>接下来我们需要修改zoo.cfg中的配置信息。<br>在zoo.cfg中增加这两项配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataDir=<span class="string">F:</span><span class="regexp">/hadoop/</span>tools<span class="regexp">/devtools/</span>zookeeper<span class="number">-1</span>/data</div><div class="line">dataLogDir=<span class="string">F:</span><span class="regexp">/hadoop/</span>tools<span class="regexp">/devtools/</span>zookeeper<span class="number">-1</span>/log</div></pre></td></tr></table></figure>
<p>  这都是我们之前新建的目录，dataDir前面已经作过说明，dataLogDir是zookeeper存放日志文件的目录，如果不配置dataLogDir，日志文件默认存放到dataDir中。</p><p><br>  然后配置zk进程（server.x=ip:clientPort:zkReqPort）：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">server</span><span class="number">.1</span>=localhost:<span class="number">2287</span>:<span class="number">3387</span>        </div><div class="line"><span class="keyword">server</span><span class="number">.2</span>=localhost:<span class="number">2288</span>:<span class="number">3388</span></div><div class="line"><span class="keyword">server</span><span class="number">.3</span>=localhost:<span class="number">2289</span>:<span class="number">3389</span></div></pre></td></tr></table></figure>
<p>  server.x中的“<strong><em>x</em></strong>”表示ZooKeeper Server进程的标识，同一个ZooKeeper集群内的ZooKeeper Server进程间的通信不仅可以使用具体的点IP地址，也可以使用组播地址。</p><p><br>  <strong><em>clientPort</em></strong> 表示监听Client端请求的端口号</p><p><br>  <strong><em>zkReqPort</em></strong>  表示监听同ZooKeeper集群内其他ZooKeeper Server进程通信请求的端口号</p><p><br>因为笔者是在同一台机器上作伪集群的搭建，所以各个zookeeper的ip相同，保证每个zk进程的监听端口错开就可以了，如果是在不同机器上，则不需要。</p><p><br>以上配置已经完成了集群99%的搭建工作。</p><p></p>
<p>  此时需要在每个zookeeper-1/data目录中新建myid文件，文件内容为1，然后在zookeeper-2/data，zookeeper-3/data目录中也同样新建myid文件，内容分别为2和3。1,2,3分别对应server.x中的x，表示zookeeper进程的进程标识。如果不配置zookeeper的进程标识，zk集群将不能找到自己所对应的进程。因此，之前99%的工作也不如此处1%的重要。</p><p><br>自此，入门级集群的搭建基本完成。</p>
<h3 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h3><p>首先启动zk集群，windows下直接运行三个zookeeper服务器的zkServer.cmd即可。在启动第一个zookeeper的时候会出现以下错误信息：</p><p><br><a href="http://i1.piimg.com/4851/da2eac70e3af7468.jpg" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/da2eac70e3af7468t.jpg"></a><br></p>
<p></p><p>这些错误信息不要害怕，因为集群其他进程没启动，检查线程没有找到其他的服务器节点。在启动第二个zookeeper服务器之后就正常了。</p><p></p>
<p>启动成功之后就需要我们通过java代码去测试集群是否可用。</p><p></p>
<p>新建一个maven工程，在pom.xml文件中添加一下依赖信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Zkclient是github上一个开源的java zk客户端。<br>编写测试代码</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> testZkClient() &#123;</div><div class="line">    ZkClient zkClient = <span class="keyword">new</span> ZkClient(<span class="string">"localhost:2181,localhost:2182,localhost:2183"</span>);</div><div class="line">    <span class="keyword">String</span> node = <span class="string">"/zookeeper-3.4.5-1"</span>;</div><div class="line">    <span class="built_in">if</span> (zkClient.<span class="built_in">exists</span>(node)) &#123;</div><div class="line">        System.out.<span class="built_in">println</span>(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zkClient.exists(node) 检测zookeeper-3.4.5-1 是否存在</p>
<p>zookeeper集群的搭建及测试完成，在Linux下搭建伪集群和不同机器下搭建集群方式基本相同。笔者建议后来者可先在windows环境下搭建，windows的可视化界面效果能够为初学者减少很多出错的地方。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong><em>本文是在机器已经配置好java开发环境的基础上完成的。</em></strong></p>
<h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><p>Zookeeper最新版本是3.4.6，笔者使用zookeeper-3.4.5-cdh5.3.6.tar.gz完成集群的搭建。<br>Zk的其他版本下载地址：<a href="http://www.apache.org/dist/zookeeper/">http://www.apache.org/dist/zookeeper/</a><br>将下载好的zookeeper解压，]]>
    
    </summary>
    
      <category term="zookeeper" scheme="/tags/zookeeper/"/>
    
      <category term="zookeeper入门" scheme="/categories/zookeeper%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot核心]]></title>
    <link href="/2016/12/18/Spring-Boot%E6%A0%B8%E5%BF%83/"/>
    <id>/2016/12/18/Spring-Boot核心/</id>
    <published>2016-12-18T12:26:36.000Z</published>
    <updated>2016-12-22T14:31:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot基本配置"><a href="#一、Spring-Boot基本配置" class="headerlink" title="一、Spring Boot基本配置"></a>一、Spring Boot基本配置</h2><p></p><p></p>
<h4 id="1、入口类和-SpringBootApplication"><a href="#1、入口类和-SpringBootApplication" class="headerlink" title="1、入口类和@SpringBootApplication"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),<a id="more"></a>启动Spring Boot应用项目。</p>
<h4 id="2、关闭特定的自动配置"><a href="#2、关闭特定的自动配置" class="headerlink" title="2、关闭特定的自动配置"></a>2、关闭特定的自动配置</h4><p>通过<strong>@SpringBootApplication</strong>源码可以看出，关闭特定的自动配置应该使用<strong>@SpringBootApplication</strong>注解的exclude参数，例如:<br>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p>
<h4 id="3、定制Banner"><a href="#3、定制Banner" class="headerlink" title="3、定制Banner"></a>3、定制Banner</h4><p>在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。<br>1）我们在src/main/resources下新建一个banner.txt<br>2）通过<a href="http://patorjk.com/software/taag" target="_blank" rel="external">http://patorjk.com/software/taag</a>网站生成字符，将生成的字符复制到banner.txt文件中<br>3）自动程序，这时控制台图案将变成刚才生成的图案</p>
<h4 id="4、关闭banner"><a href="#4、关闭banner" class="headerlink" title="4、关闭banner"></a>4、关闭banner</h4><p>在main方法中修改为(Spring Boot:1.4.0)：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SpringApplication <span class="built_in">application</span> = new SpringApplication(Chapter1Application.<span class="built_in">class</span>);</div><div class="line">   <span class="built_in">application</span>.setBannerMode(Mode.OFF);</div><div class="line">   <span class="built_in">application</span>.<span class="built_in">run</span>(args);</div></pre></td></tr></table></figure>
<p>  或者</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">new</span> <span class="title">SpringApplicationBuilder</span>(<span class="type">Chapter1Application</span>.class) <span class="comment">//</span></span></div><div class="line">               .<span class="title">bannerMode</span>(<span class="type">Mode</span>.<span class="type">OFF</span>) <span class="comment">//</span></div><div class="line">			.<span class="title">run</span>(args);</div></pre></td></tr></table></figure>
<h4 id="5、Spring-Boot配置文件"><a href="#5、Spring-Boot配置文件" class="headerlink" title="5、Spring Boot配置文件"></a>5、Spring Boot配置文件</h4><p>Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。</p><p><br>Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p><br>Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。<br><br>例如：<br><br>修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在<br>application.properties中添加：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">server</span>.port=<span class="number">9090</span></div><div class="line">   <span class="keyword">server</span>.context-path=/helloBoot</div></pre></td></tr></table></figure>
<h4 id="6、官方starter-pom"><a href="#6、官方starter-pom" class="headerlink" title="6、官方starter pom"></a>6、官方starter pom</h4><p><div style="color:gray"><br>spring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持<br><br>spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  准生产特性，用来监控和管理应用<br><br>spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  提供基于ssh协议的监控和管理<br><br>spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用spring-rabbit来支持AMQP<br><br>spring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成<br><br>spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Batch的支持<br><br>spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Cache抽象的支持<br><br>spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法<br><br>spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-elasticsearch对Elasticsearch的支持<br><br>spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-gemfire对分布式存储GenFile的支持<br><br>spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对JPA的支持，包含spring-data-jpa，spring-orm和Hibernate<br><br>spring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-mongodb，对MongoDB进行支持<br><br>spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务<br><br>spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-solr对Apache Solr数据检索平台的支持<br><br>spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对FreeMarker模板引擎的支持<br><br>spring-boot-starter-groovy-templates  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持<br><br>spring-boot-starter-hateoas  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas  通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持<br><br>spring-boot-starter-hornetq  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持<br><br>spring-boot-starter-integration  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持<br><br>spring-boot-starter-jdbc  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持<br><br>spring-boot-starter-jersey  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持<br><br>spring-boot-starter-jta-atomikos  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持<br><br>spring-boot-starter-jta-bitronix  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持<br><br>spring-boot-starter-mail  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持<br><br>spring-boot-starter-mobile  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持<br><br>spring-boot-starter-mustache  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持<br><br>spring-boot-starter-redis  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reids<br><br>spring-boot-starter-security  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持<br><br>spring-boot-starter-social-faceboot  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持<br><br>spring-boot-starter-social-twitter   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持<br><br>spring-boot-starter-test  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板<br><br>spring-boot-starter-thymeleaf  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置<br><br>spring-boot-starter-velocity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持<br><br>spring-boot-starter-web  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvc<br><br>spring-boot-starter-Tomcat  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcat<br><br>spring-boot-starter-Jetty  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcat<br><br>spring-boot-starter-undertow  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcat<br><br>spring-boot-starter-logging  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logback<br><br>spring-boot-starter-log4j  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架<br><br>spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持<br><br>spring-boot-starter-ws  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持<br><br></div></p>
<p></p><p><br>还有第三方为Spring Boot所写的starter pom,这里不做介绍</p>
<h4 id="7、使用xml配置"><a href="#7、使用xml配置" class="headerlink" title="7、使用xml配置"></a>7、使用xml配置</h4><p>Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的<strong>@ImportResource</strong>来加载xml配置，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">ImportResource</span>(&#123;"<span class="selector-tag">classpath</span><span class="selector-pseudo">:context.xml</span>”&#125;)</div></pre></td></tr></table></figure>
<h4 id="8、命令行参数配置"><a href="#8、命令行参数配置" class="headerlink" title="8、命令行参数配置"></a>8、命令行参数配置</h4><p>Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行<br>可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号</p>
<h4 id="9、常规属性配置"><a href="#9、常规属性配置" class="headerlink" title="9、常规属性配置"></a>9、常规属性配置</h4><p>在常规Spring环境下，注入properties文件里的值得方式，通过<strong>@PropertySource</strong>指明properties文件的位置，然后通过<strong>@Value</strong>注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用<strong>@Value</strong>注入即可。<br><br>例如：<br><br>在application.properties文件中添加属性：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">book.author=cm</span></div><div class="line"><span class="keyword">book.name=spring </span><span class="keyword">boot</span></div></pre></td></tr></table></figure>
<p>在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTests</span> </span>&#123;</div><div class="line">	<span class="meta">@Value</span>(<span class="string">"book.author"</span>)</div><div class="line">	<span class="keyword">private</span> String author;</div><div class="line">	<span class="meta">@Value</span>(<span class="string">"book.name"</span>)</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> author;</div><div class="line">   	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10、类型安全的配置（基于properties）"><a href="#10、类型安全的配置（基于properties）" class="headerlink" title="10、类型安全的配置（基于properties）"></a>10、类型安全的配置（基于properties）</h4><p>Spring Boot提供了基于类型安全的配置方式，通过<strong>@ConfigurationProperties</strong>将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"book"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTests</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String author;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11、日志配置"><a href="#11、日志配置" class="headerlink" title="11、日志配置"></a>11、日志配置</h4><p>Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。</p><p><br>默认情况下，Spring Boot使用Logback作为日志框架。日志级别:<strong><strong>logging.file=/home/cm/mylog.log</strong></strong><br>配置日志文件，格式为logging.level.包名=级别：<strong><strong>logging.level.org.springframework.web=DEBUG</strong></strong></p>
<h4 id="12、Profile配置"><a href="#12、Profile配置" class="headerlink" title="12、Profile配置"></a>12、Profile配置</h4><p>Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),<br>通过在application.properties中设置<strong><strong>spring.profiles.active=prod</strong></strong>来指定活动的Profile<br>例如：<br><br>我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。<br><br>两种配置文件分别为：<br></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">application-prod<span class="selector-class">.properties</span>:  server.port=<span class="number">80</span></div><div class="line">application-dev<span class="selector-class">.properties</span>:  server.port=<span class="number">8888</span></div></pre></td></tr></table></figure>
<p>然后在application.properties增加：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=dev(prod)</div></pre></td></tr></table></figure>
<p>通过Profile可以灵活切换Spring Boot项目的配置了。</p>
<h2 id="二、Spring-Boot运行原理"><a href="#二、Spring-Boot运行原理" class="headerlink" title="二、Spring Boot运行原理"></a>二、Spring Boot运行原理</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：</p><p><br><a href="http://i1.piimg.com/4851/bb6e18a430a22a09.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/bb6e18a430a22a09t.jpg"></a><br><a href="http://i1.piimg.com/4851/73ed190dbda257cb.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/73ed190dbda257cbt.jpg"></a></p><p><br>若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：</p><p><br>1）运行jar时增加—debug参数：java -jar xx.jar —debug</p><p><br>2)在application.properties中设置属性：debug=true（这个方便点）</p><p><br>3）在开发工具启动参数中配置</p><p><br><a href="http://i1.piimg.com/4851/db0610f744b512ec.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/db0610f744b512ect.jpg"></a></p><p></p>
<h4 id="1、Spring-Boot运行原理解析："><a href="#1、Spring-Boot运行原理解析：" class="headerlink" title="1、Spring Boot运行原理解析："></a>1、Spring Boot运行原理解析：</h4><p> 对@SpringBootApplication注解说明：<br>  <strong>@SpringBootApplication</strong>是一个组合注解，它的核心功能是由<strong>@EnableAutoConfiguration</strong>注解提供的。<br>查看<strong>@EnableAutoConfiguration</strong>源码</p><p><br><a href="http://i1.piimg.com/4851/df2b568388d67082.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/df2b568388d67082t.jpg"></a></p><p><br>这里<strong>@Import</strong>注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。<br><a href="http://i1.piimg.com/4851/8290194ff6bbbda5.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/8290194ff6bbbda5t.jpg"></a><br><br><a href="http://i1.piimg.com/4851/dba6c685c8097175.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/dba6c685c8097175t.jpg"></a></p><p><br>       任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下：</p><p></p>
<p><div style="color:gray"><br>    @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下<br><br>    @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下<br><br>     @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件<br><br>     @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件<br><br>     @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置<br><br>     @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下<br><br>     @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下<br><br>     @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下<br><br>     @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值<br><br>     @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值<br><br>     @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean<br><br>     @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下<br><br></div></p><p><br>这些注解都是使用了<strong>@Conditional</strong>元注解，不过是使用了不同的条件而已。</p>
<h4 id="2、分析http的编码配置"><a href="#2、分析http的编码配置" class="headerlink" title="2、分析http的编码配置"></a>2、分析http的编码配置</h4><p>配置参数</p>
<p>  HttpEncodingProperties的源码如下：</p><p><br><a href="http://i1.piimg.com/4851/01b5f66dfd191b68.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/01b5f66dfd191b68t.jpg"></a></p><p><br>这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。<br>根据条件配置CharacterEncodingFilter的Bean，源码如下:<br><a href="http://i1.piimg.com/4851/6307e6e411a78c22.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/6307e6e411a78c22t.jpg"></a></p>
<h4 id="3、自定义自动配置（包装成starter-pom）"><a href="#3、自定义自动配置（包装成starter-pom）" class="headerlink" title="3、自定义自动配置（包装成starter pom）"></a>3、自定义自动配置（包装成starter pom）</h4><p>1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></div><div class="line">   	<span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   	    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2) 新建属性配置类HellpServiceProperties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"hello"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceProperties</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG = <span class="string">"world"</span>;</div><div class="line">    <span class="keyword">private</span> String msg = MSG;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">   	&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">   	    <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world</p><p></p>
<p>3）新建依据类HelloService（此类可以是第三方类库的类）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> HelloService &#123;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">String</span> msg;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sayHello() &#123;</div><div class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + msg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getMsg() &#123;</div><div class="line">        <span class="built_in">return</span> msg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setMsg(<span class="keyword">String</span> msg) &#123;</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4）新建自动配置类</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloServiceProperties.<span class="keyword">class</span>)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(HelloService.<span class="keyword">class</span>)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"hello"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="literal">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> &#123;</span></div><div class="line">   	<span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> HelloServiceProperties helloServiceProperties;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HelloService.<span class="keyword">class</span>)</div><div class="line">    <span class="keyword">public</span> HelloService helloService() &#123;</div><div class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</div><div class="line">        helloService.setMsg(helloServiceProperties.getMsg());</div><div class="line">        <span class="keyword">return</span> helloService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据HelloServiceProperties提供的参数，并通过<strong>@ConditionalOnClass</strong>来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。</p><p><br>5）注册自动配置</p><p><br>在src/main/resources中新建META-INF/spring.factories文件，内容为</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.EnableAutoConfiguration</span>=\	  com<span class="selector-class">.gnd</span><span class="selector-class">.springboot</span><span class="selector-class">.config</span><span class="selector-class">.HelloServiceAutoConfiguration</span>&lt;br&gt;</div></pre></td></tr></table></figure>
<p>其中“\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔</p><p><br>6）测试自定义自动配置</p><p><br>新建一个maven web工程，添加如下依赖:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></div><div class="line">   	<span class="tag">&lt;<span class="name">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">spring-framework.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;spring-framework.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.gnd.springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>spring-boot-starter-hello为之前新建的自定义自动配置starter pom</p><p><br>新建测试启动类</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@RestController</span></div><div class="line"><span class="variable">@SpringBootApplication</span></div><div class="line">public class Chapter11Application &#123;</div><div class="line">    <span class="variable">@Autowired</span></div><div class="line">    private HelloService helloService;</div><div class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</div><div class="line">    public String index() &#123;</div><div class="line">        <span class="selector-tag">return</span> <span class="selector-tag">helloService</span><span class="selector-class">.sayHello</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args)&#123;</div><div class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(Chapter11Application.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行测试工程之后，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="external">http://localhost:8080/test</a>“测试，测试结果如下:<br><br><a href="http://p1.bpimg.com/4851/6ff00c546916cb99.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://p1.bpimg.com/4851/6ff00c546916cb99t.jpg"></a></p><p><br>新建application.properties配置文件，内容为</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hello.msg</span>=<span class="string">haha</span></div></pre></td></tr></table></figure>
<p>重启工程，浏览器输入”<a href="http://localhost:8080/test" target="_blank" rel="external">http://localhost:8080/test</a>“测试，测试结果如下:<br><a href="http://p1.bpimg.com/4851/fbf8797b19bd1733.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://p1.bpimg.com/4851/fbf8797b19bd1733t.jpg"></a></p><p></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、Spring-Boot基本配置"><a href="#一、Spring-Boot基本配置" class="headerlink" title="一、Spring Boot基本配置"></a>一、Spring Boot基本配置</h2><p><p></p>
<h4 id="1、入口类和-SpringBootApplication"><a href="#1、入口类和-SpringBootApplication" class="headerlink" title="1、入口类和@SpringBootApplication"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot核心" scheme="/categories/Spring-Boot%E6%A0%B8%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jdk各版本区别]]></title>
    <link href="/2016/12/18/jdk%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
    <id>/2016/12/18/jdk各版本区别/</id>
    <published>2016-12-17T16:06:43.000Z</published>
    <updated>2016-12-22T14:24:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdk5新特性"><a href="#jdk5新特性" class="headerlink" title="jdk5新特性"></a>jdk5新特性</h1><h3 id="1、自动装箱和拆箱"><a href="#1、自动装箱和拆箱" class="headerlink" title="1、自动装箱和拆箱"></a>1、自动装箱和拆箱</h3><h3 id="2、枚举"><a href="#2、枚举" class="headerlink" title="2、枚举"></a>2、枚举</h3><h3 id="3、静态导入"><a href="#3、静态导入" class="headerlink" title="3、静态导入"></a>3、静态导入</h3><h3 id="4、可变参数"><a href="#4、可变参数" class="headerlink" title="4、可变参数"></a>4、可变参数</h3><h3 id="5、內省"><a href="#5、內省" class="headerlink" title="5、內省"></a>5、內省</h3><p>   内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。<a id="more"></a>Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br><br>   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p>
<h3 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h3><h3 id="7、For-Each循环"><a href="#7、For-Each循环" class="headerlink" title="7、For-Each循环"></a>7、For-Each循环</h3><h2 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h2><h3 id="1、Desktop类和SystemTray类"><a href="#1、Desktop类和SystemTray类" class="headerlink" title="1、Desktop类和SystemTray类"></a>1、Desktop类和SystemTray类</h3><p>   AWT新增加了两个雷：Desktop，SystemTray。</p><p><br>   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档</p><p><br>   SystemTray可以用来在系统托盘区创建一个托盘程序</p>
<h3 id="2、使用JAXB2来实现对象与XML之间的映射"><a href="#2、使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="2、使用JAXB2来实现对象与XML之间的映射"></a>2、使用JAXB2来实现对象与XML之间的映射</h3><p>   也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。</p>
<h3 id="3、StAX"><a href="#3、StAX" class="headerlink" title="3、StAX"></a>3、StAX</h3><p>   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p><p><br>   SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>
<h3 id="4、使用Compiler-API"><a href="#4、使用Compiler-API" class="headerlink" title="4、使用Compiler API"></a>4、使用Compiler API</h3><p>   使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。</p>
<h3 id="5、轻量级Http-Server-API"><a href="#5、轻量级Http-Server-API" class="headerlink" title="5、轻量级Http Server API"></a>5、轻量级Http Server API</h3><h3 id="6、插入式注解处理API"><a href="#6、插入式注解处理API" class="headerlink" title="6、插入式注解处理API"></a>6、插入式注解处理API</h3><h3 id="7、用Console开发控制台程序"><a href="#7、用Console开发控制台程序" class="headerlink" title="7、用Console开发控制台程序"></a>7、用Console开发控制台程序</h3><h3 id="8、对脚本语言的支持如：ruby，groovy，javascript"><a href="#8、对脚本语言的支持如：ruby，groovy，javascript" class="headerlink" title="8、对脚本语言的支持如：ruby，groovy，javascript"></a>8、对脚本语言的支持如：ruby，groovy，javascript</h3><h3 id="9、Common-Annotations"><a href="#9、Common-Annotations" class="headerlink" title="9、Common Annotations"></a>9、Common Annotations</h3><h2 id="jdk7新特性"><a href="#jdk7新特性" class="headerlink" title="jdk7新特性"></a>jdk7新特性</h2><h3 id="1、switch中可以使用字符串"><a href="#1、switch中可以使用字符串" class="headerlink" title="1、switch中可以使用字符串"></a>1、switch中可以使用字符串</h3><h3 id="2、泛型的自动判断"><a href="#2、泛型的自动判断" class="headerlink" title="2、泛型的自动判断"></a>2、泛型的自动判断</h3><h3 id="3、自定义自动关闭类（实现AutoCloseable接口）"><a href="#3、自定义自动关闭类（实现AutoCloseable接口）" class="headerlink" title="3、自定义自动关闭类（实现AutoCloseable接口）"></a>3、自定义自动关闭类（实现AutoCloseable接口）</h3><h3 id="4、新增一些取环境信息的工具方法（System中的方法）"><a href="#4、新增一些取环境信息的工具方法（System中的方法）" class="headerlink" title="4、新增一些取环境信息的工具方法（System中的方法）"></a>4、新增一些取环境信息的工具方法（System中的方法）</h3><h3 id="5、Boolean类型反转，空指针安全，参数与位运算"><a href="#5、Boolean类型反转，空指针安全，参数与位运算" class="headerlink" title="5、Boolean类型反转，空指针安全，参数与位运算"></a>5、Boolean类型反转，空指针安全，参数与位运算</h3><h3 id="6、两个char间的equals"><a href="#6、两个char间的equals" class="headerlink" title="6、两个char间的equals"></a>6、两个char间的equals</h3><h3 id="7、安全的加减乘除"><a href="#7、安全的加减乘除" class="headerlink" title="7、安全的加减乘除"></a>7、安全的加减乘除</h3><h3 id="1、对Java集合（Collections）的增强支持"><a href="#1、对Java集合（Collections）的增强支持" class="headerlink" title="1、对Java集合（Collections）的增强支持"></a>1、对Java集合（Collections）的增强支持</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list=[<span class="string">"item"</span>]; <span class="comment">//向List集合中添加元素</span></div><div class="line"><span class="built_in">String</span> item=list[<span class="number">0</span>]; <span class="comment">//从List集合中获取元素</span></div><div class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="keyword">set</span>=&#123;<span class="string">"item"</span>&#125;; <span class="comment">//向Set集合对象中添加元</span></div><div class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Integer&gt; map=&#123;<span class="string">"key"</span>:<span class="number">1</span>&#125;; <span class="comment">//向Map集合中添加对象</span></div><div class="line"><span class="built_in">int</span> value=map[<span class="string">"key"</span>]; <span class="comment">//从Map集合中获取对象</span></div></pre></td></tr></table></figure>
<p>   但是经过自己测试，按照上面的使用方法，并不能创建集合。</p>
<h3 id="2、int支持二进制数据"><a href="#2、int支持二进制数据" class="headerlink" title="2、int支持二进制数据"></a>2、int支持二进制数据</h3><h3 id="3、在try-catch异常捕捉中，一个catch可以写多个异常类型"><a href="#3、在try-catch异常捕捉中，一个catch可以写多个异常类型" class="headerlink" title="3、在try catch异常捕捉中，一个catch可以写多个异常类型"></a>3、在try catch异常捕捉中，一个catch可以写多个异常类型</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Connection conn = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   	<span class="keyword">Class</span>.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">   	conn = DriverManager.getConnection(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException|SQLException ex) &#123;</div><div class="line">   	ex.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、try-catch中资源定义好之后try-catch自动关闭"><a href="#4、try-catch中资源定义好之后try-catch自动关闭" class="headerlink" title="4、try catch中资源定义好之后try catch自动关闭"></a>4、try catch中资源定义好之后try catch自动关闭</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (BufferedReader <span class="keyword">in</span>  = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> 	FileReader(<span class="string">"in.txt"</span>));</div><div class="line">    	BufferedWriter <span class="keyword">out</span> = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> 	FileWriter(<span class="string">"out.txt"</span>))) &#123;</div><div class="line">	<span class="keyword">int</span> charRead;</div><div class="line">	<span class="keyword">while</span> ((charRead = <span class="keyword">in</span>.read()) != <span class="number">-1</span>) &#123;</div><div class="line">       	System.<span class="keyword">out</span>.printf(<span class="string">"%c "</span>, (<span class="keyword">char</span>)charRead);</div><div class="line">       	<span class="keyword">out</span>.write(charRead);</div><div class="line">   	&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">   	ex.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="jdk8新特性"><a href="#jdk8新特性" class="headerlink" title="jdk8新特性"></a>jdk8新特性</h2><h3 id="1、接口的默认方法"><a href="#1、接口的默认方法" class="headerlink" title="1、接口的默认方法"></a>1、接口的默认方法</h3><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">   	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line">   	<span class="keyword">default</span> <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">return</span> Math.<span class="title">sqrt</span><span class="params">(a)</span></span>;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keyword">double</span> calculate(<span class="keyword">int</span> a) &#123;</div><div class="line">	<span class="built_in">return</span> <span class="built_in">sqrt</span>(a * <span class="number">100</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;;</div><div class="line">  System.out.<span class="built_in">println</span>(formula.calculate(<span class="number">100</span>));  <span class="comment">// 100.0</span></div><div class="line">  System.out.<span class="built_in">println</span>(formula.<span class="built_in">sqrt</span>(<span class="number">16</span>));  <span class="comment">// 4.0</span></div></pre></td></tr></table></figure>
<p>文中的formula被实现为一个匿名类的实例，该代码非常</p>
<h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names = Arrays.asList(<span class="string">"tom"</span>,<span class="string">"jace"</span>,<span class="string">"mike"</span>);</div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;<span class="built_in">String</span>&gt;() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	public <span class="built_in">int</span> compare(<span class="built_in">String</span> o1, <span class="built_in">String</span> o2) &#123;</div><div class="line">		<span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。<br>在Java 8中提供了更简洁的语法，lambda表达式：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (String a, String b) -&gt; &#123;</span></span></div><div class="line">	<span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还可以更简洁：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (String a, String b) -&gt; b.compareTo(a))</span>;</span></div></pre></td></tr></table></figure>
<p>去掉大括号以及return关键字</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort<span class="function"><span class="params">(names, (a,b) -&gt; b.compareTo(a))</span>;</span></div></pre></td></tr></table></figure>
<p>Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。</p>
<h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><p>Lambda表达式是如何在java的类型系统中表示的呢？</p><p><br>每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。</p><p><br>我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加<strong>@FunctionalInterface</strong>注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说<strong>@FunctionalInterface</strong>注解标注的接口只能有一个抽象方法。</p><p><br>例如：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Converter&lt;F, T&gt; &#123;</div><div class="line">	T convert(F <span class="keyword">from</span>);</div><div class="line">&#125;</div><div class="line">Converter&lt;String, Integer&gt; <span class="function"><span class="title">converter</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> Integer.valueOf(<span class="keyword">from</span>);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);</div></pre></td></tr></table></figure>
<p>以上代码不需要@FunctionalInterface注解也是正确的。</p>
<h3 id="4、方法与构造函数引用"><a href="#4、方法与构造函数引用" class="headerlink" title="4、方法与构造函数引用"></a>4、方法与构造函数引用</h3><p>上面的代码也可以通过静态方法引用来表示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; converter = <span class="built_in">Integer</span><span class="type">::</span>valueOf;</div><div class="line"><span class="built_in">Integer</span> converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);</div></pre></td></tr></table></figure>
<p>Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">   	<span class="keyword">String</span> firstName;</div><div class="line">    <span class="keyword">String</span> lastName;</div><div class="line">   	Person() &#123;</div><div class="line">   	&#125;</div><div class="line">	<span class="keyword">public</span> Person(<span class="keyword">String</span> firstName, <span class="keyword">String</span> lastName) &#123;</div><div class="line">		<span class="built_in">this</span>.firstName = firstName;</div><div class="line">		<span class="built_in">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指定一个用来创建Person对象的对象工厂接口：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Person</span></span>&gt; </span>&#123;</div><div class="line">	P create(<span class="keyword">String</span> fisrtName, <span class="keyword">String</span> lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建Person对象</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;<span class="keyword">Person</span>&gt; personFactory = <span class="keyword">Person</span>::new;</div><div class="line"><span class="keyword">Person</span> <span class="keyword">person</span> = personFactory.create(<span class="string">"Peter"</span>,<span class="string">"Parker”);</span></div></pre></td></tr></table></figure>
<p>我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<h3 id="5、Lambda作用域"><a href="#5、Lambda作用域" class="headerlink" title="5、Lambda作用域"></a>5、Lambda作用域</h3><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<h3 id="6、访问局部变量"><a href="#6、访问局部变量" class="headerlink" title="6、访问局部变量"></a>6、访问局部变量</h3><p>我们可以直接在lambda表达式中访问外层的局部变量</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, <span class="built_in">String</span>&gt; stringConverter = (from) -&gt; <span class="built_in">String</span>.valueOf(from + <span class="built_in">num</span>);</div><div class="line">stringConverter.convert(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。</p>
<h3 id="7、访问对象字段与静态变量"><a href="#7、访问对象字段与静态变量" class="headerlink" title="7、访问对象字段与静态变量"></a>7、访问对象字段与静态变量</h3><p>和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static int outerStaticNum;</div><div class="line">int outerNum;</div><div class="line">public <span class="literal">void</span> testScopes() &#123;</div><div class="line">   	Converter <span class="function"><span class="title">stringConverter1</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> &#123;</div><div class="line">       	outerNum = <span class="number">23</span>;</div><div class="line">       	<span class="keyword">return</span> String.valueOf(<span class="keyword">from</span>);</div><div class="line">   	&#125;;</div><div class="line">    Converter <span class="function"><span class="title">stringConverter2</span> = <span class="params">(<span class="keyword">from</span>)</span> -&gt;</span> &#123;</div><div class="line">   	    outerStaticNum = <span class="number">72</span>;</div><div class="line">       	<span class="keyword">return</span> String.valueOf(<span class="keyword">from</span>);</div><div class="line">   	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8、访问接口的默认方法"><a href="#8、访问接口的默认方法" class="headerlink" title="8、访问接口的默认方法"></a>8、访问接口的默认方法</h3><h3 id="9、Date-API"><a href="#9、Date-API" class="headerlink" title="9、Date API"></a>9、Date API</h3><h3 id="10、Annotation注解"><a href="#10、Annotation注解" class="headerlink" title="10、Annotation注解"></a>10、Annotation注解</h3>]]></content>
    <summary type="html">
    <![CDATA[自从1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0）以来，到现在jdk的版本已经更新到1.8了，1.9也即将出现。本文将介绍jdk1.5到1.8各版本的特性。]]>
    
    </summary>
    
      <category term="jdk版本" scheme="/tags/jdk%E7%89%88%E6%9C%AC/"/>
    
      <category term="Java基础" scheme="/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot入门]]></title>
    <link href="/2016/12/13/Spring-Boot%E5%85%A5%E9%97%A8/"/>
    <id>/2016/12/13/Spring-Boot入门/</id>
    <published>2016-12-13T15:18:29.000Z</published>
    <updated>2016-12-22T14:27:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot简介"><a href="#一、Spring-Boot简介" class="headerlink" title="一、Spring Boot简介"></a>一、Spring Boot简介</h1><p>   <strong><em>Spring Boot</em></strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<a id="more"></a><br><br>    </p><p>Spring Boot有以下几个优点：<br><br>    1、 没有代码生成，不需要XML配置文件<br><br>    2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br><br>    3、 可以独立运行Spring应用程序<br><br>    4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br><br>    5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br><br>    6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br></p>
<h1 id="二、Spring-Boot入门工程搭建："><a href="#二、Spring-Boot入门工程搭建：" class="headerlink" title="二、Spring Boot入门工程搭建："></a>二、Spring Boot入门工程搭建：</h1><h2 id="1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。"><a href="#1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。" class="headerlink" title="1、采用Spring官网提供的SPRING INITIALIZR进行搭建。"></a>1、采用Spring官网提供的<a href="https://start.spring.io/" target="_blank" rel="external">SPRING INITIALIZR</a>进行搭建。</h2><p><a href="http://i1.piimg.com/4851/081074cce7646b73.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/081074cce7646b73t.jpg"></a><br>可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。</p>
<h2 id="2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）"><a href="#2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）" class="headerlink" title="2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）"></a>2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）</h2><h3 id="1、新建一个Maven的web工程"><a href="#1、新建一个Maven的web工程" class="headerlink" title="1、新建一个Maven的web工程"></a>1、新建一个Maven的web工程</h3><h3 id="2、在pom-xml文件中添加Spring-Boot的相关依赖"><a href="#2、在pom-xml文件中添加Spring-Boot的相关依赖" class="headerlink" title="2、在pom.xml文件中添加Spring Boot的相关依赖"></a>2、在pom.xml文件中添加Spring Boot的相关依赖</h3><p>   添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure>
<p>   添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>   然后在dependencies中添加Web支持的starter pom。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>spring-boot-starter-web会自动添加它所依赖的jar包<br><a href="http://i1.piimg.com/4851/052ad9b5b4e68a85.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/052ad9b5b4e68a85t.jpg"></a><br>   然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	<span class="params">&lt;plugin&gt;</span></div><div class="line">    	<span class="params">&lt;groupId&gt;</span>org.springframework.boot<span class="params">&lt;/groupId&gt;</span></div><div class="line">    	<span class="params">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="params">&lt;/artifactId&gt;</span></div><div class="line">    	<span class="params">&lt;configuration&gt;</span></div><div class="line">        	<span class="params">&lt;fork&gt;</span>true<span class="params">&lt;/fork&gt;</span></div><div class="line">	    <span class="params">&lt;/configuration&gt;</span></div><div class="line">	<span class="params">&lt;/plugin&gt;</span></div><div class="line">```        </div><div class="line"><span class="meta">### 3、简单测试</span></div><div class="line">   新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法</div></pre></td></tr></table></figure>
<pre><code>@SpringBootApplication
public class Chapter01Application {
    public static void main(String[] args){
        SpringApplication.run(Chapter01Application.class, args);
    }
}
</code></pre><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">***注***：</div><div class="line">**<span class="variable">@SpringBootApplication</span>**是一个组合注解，查看其源码，**<span class="variable">@SpringBootApplication</span>**</div><div class="line">组合了**<span class="variable">@SpringBootConfiguration</span>**，**<span class="variable">@EnableAutoConfiguration</span>**，**<span class="variable">@ComponentScan</span>**三个注解，**<span class="variable">@SpringBootConfiguration</span>**表示当前类是一个启动应用程序的入口；**<span class="variable">@EnableAutoConfiguration</span>**注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；<span class="variable">@ComponentScan</span>会以Application入口类所在目录为根目录，自动扫描工程中标注了**<span class="variable">@Component</span>**注解的类。</div><div class="line">&lt;a href=<span class="string">"http://i1.piimg.com/4851/5c5bb70a10d94825.png"</span> title=<span class="string">"点击显示原始图片"</span>&gt;&lt;img src=<span class="string">"http://i1.piimg.com/4851/5c5bb70a10d94825t.jpg"</span>&gt;&lt;/a&gt;</div><div class="line">   然后新建目录controller，在其中新建一个HelloController测试类。</div></pre></td></tr></table></figure>
<pre><code>@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String index() {
        return &quot;Hello, World!&quot;;
    }
}
</code></pre><p>```<br><a href="http://i1.piimg.com/4851/2fbce1b8657ec289.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/2fbce1b8657ec289t.jpg"></a><br><strong>@RestController</strong>也是一个组合注解，组合了<strong>@Controller</strong>，<strong>@ResponseBody</strong>两个注解</p>
<h3 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h3><p>   使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>即可访问HelloController，访问结果如下：<br><a href="http://i1.piimg.com/4851/4c01bd8a22d0fbfb.png" title="点击显示原始图片" target="_blank" rel="external"><img src="http://i1.piimg.com/4851/4c01bd8a22d0fbfbt.jpg"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、Spring-Boot简介"><a href="#一、Spring-Boot简介" class="headerlink" title="一、Spring Boot简介"></a>一、Spring Boot简介</h1><p>   <strong><em>Spring Boot</em></strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot" scheme="/categories/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot入门]]></title>
    <link href="/2016/12/13/Spring-Boot%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>/2016/12/13/Spring-Boot基础配置/</id>
    <published>2016-12-13T12:43:01.000Z</published>
    <updated>2017-06-01T14:44:47.000Z</updated>
    <content type="html"><![CDATA[<p>#Spring Boot入门</p>
<p></p><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<br>  </p><p>Spring Boot有以下几个优点：<br><br>   1、 没有代码生成，不需要XML配置文件<br><br>   2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br><br>   3、 可以独立运行Spring应用程序<br><br>   4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br><br>   5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br><br>   6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br></p>
<p>###Spring Boot入门工程搭建：</p>
<h4 id="一、采用Spring官网提供的SPRING-INITIALIZR进行搭建。"><a href="#一、采用Spring官网提供的SPRING-INITIALIZR进行搭建。" class="headerlink" title="一、采用Spring官网提供的SPRING INITIALIZR进行搭建。"></a>一、采用Spring官网提供的<a href="https://start.spring.io/" target="_blank" rel="external">SPRING INITIALIZR</a>进行搭建。<p></p></h4><p>可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。</p><p></p>
<h4 id="二、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）"><a href="#二、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）" class="headerlink" title="二、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）"></a>二、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）</h4><h5 id="1、新建一个Maven的web工程"><a href="#1、新建一个Maven的web工程" class="headerlink" title="1、新建一个Maven的web工程"></a>1、新建一个Maven的web工程<br></h5><h5 id="2、在pom-xml文件中添加Spring-Boot的相关依赖"><a href="#2、在pom-xml文件中添加Spring-Boot的相关依赖" class="headerlink" title="2、在pom.xml文件中添加Spring Boot的相关依赖"></a>2、在pom.xml文件中添加Spring Boot的相关依赖</h5><p>   添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。<br></p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;
</code></pre><p>   <br>添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。<br></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>   <br>然后在dependencies中添加Web支持的starter pom。<br></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>   <br>spring-boot-starter-web会自动添加它所依赖的jar包<br><br>   <br>然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程<br></p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;fork&gt;true&lt;/fork&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre><h5 id="3、简单测试"><a href="#3、简单测试" class="headerlink" title="3、简单测试"></a>3、简单测试</h5><p>   新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法<br></p>
<pre><code>@SpringBootApplication
public class Chapter01Application {
    public static void main(String[] args){                                  
        SpringApplication.run(Chapter01Application.class, args);
    }
}
</code></pre><p><strong><em>注</em></strong>：<strong>@SpringBootApplication</strong>是一个组合注解，查看其源码，<strong>@SpringBootApplication</strong><br>组合了<strong>@SpringBootConfiguration</strong>，<strong>@EnableAutoConfiguration</strong>，<strong>@ComponentScan</strong>三个注解，<strong>@SpringBootConfiguration</strong>表示当前类是一个启动应用程序的入口；<strong>@EnableAutoConfiguration</strong>注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；<strong>@ComponentScan</strong>会以Application入口类所在目录为根目录，自动扫描工程中标注了<strong>@Component</strong>注解的类。</p>
<p>  然后新建目录controller，在其中新建一个HelloController测试类。</p>
<pre><code>@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String index() {
        return &quot;Hello, World!&quot;;
    }
}
</code></pre><p>  <strong>@RestController</strong>也是一个组合注解，组合了<strong>@Controller</strong>，<strong>@ResponseBody</strong>两个注解</p>
<h5 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h5><p>   使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>即可访问HelloController</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#Spring Boot入门</p>
<p></p><p><strong>Spring Boot</strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义]]>
    </summary>
    
      <category term="Spring Boot" scheme="/tags/Spring-Boot/"/>
    
      <category term="Spring Boot基础" scheme="/categories/Spring-Boot%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
