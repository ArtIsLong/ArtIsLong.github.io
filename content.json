[{"title":"js工具库","date":"2016-12-22T14:14:08.000Z","path":"2016/12/22/js工具库/","text":"1、时间格式的校验1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间1234567891011121314151617/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsDateTime(obj, msg) &#123; //var str = \"2016-04-15 00:00:00\"; if(obj.value != \"\")&#123; var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;) (\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;)$/; var r = str.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); obj.value=\"\"; return false; &#125; &#125;&#125; 2）判断日期类型是否为yyyy-MM-dd格式的类型123456789101112131415/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsDate(obj,msg) &#123; //var str = \"2016-04-15\"; if(obj.value != \"\")&#123; var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; var r = obj.value.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); &#125; &#125;&#125; 3）判断日期类型是否为hh:mm:ss格式的类型123456789101112131415/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsTime(obj,msg) &#123; //var str = \"16:13:69\"; if(obj.value != \"\")&#123; var reg = /^((20|21|22|23|[0-1]\\d)\\:[0-5][0-9])(\\:[0-5][0-9])?$/; var r = obj.value.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); &#125; &#125;&#125; 4）","permalink":"/2016/12/22/js工具库/","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"java基本数据类型缓存解析","date":"2016-12-21T16:46:28.000Z","path":"2016/12/22/java基本数据类型缓存解析/","text":"基本类型缓存解析一、Integer缓存解析：private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low)); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} } public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。 所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false注意：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=参数即可。 二、Long及Byte、Character缓存解析private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); } } public static Long valueOf(long l) { final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l); } Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。","permalink":"/2016/12/22/java基本数据类型缓存解析/","tags":[{"name":"java缓存","slug":"java缓存","permalink":"/tags/java缓存/"}]},{"title":"maven配置","date":"2016-12-21T16:43:01.000Z","path":"2016/12/22/maven配置/","text":"maven打包加载src/main/java中的配置文件 maven打jar包时，不能识别src/main/java中的配置文件(.xml,.properties)，需要在build中添加以下配置： &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java/&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- 是否替换资源中的属性 --&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; --&gt; &lt;/resource&gt; &lt;/resources&gt;","permalink":"/2016/12/22/maven配置/","tags":[{"name":"maven","slug":"maven","permalink":"/tags/maven/"}]},{"title":"zookeeper集群部署(单机版)","date":"2016-12-19T16:05:59.000Z","path":"2016/12/20/zookeeper集群部署-单机版/","text":"本文是在机器已经配置好java开发环境的基础上完成的。 软件准备Zookeeper最新版本是3.4.6，笔者使用zookeeper-3.4.5-cdh5.3.6.tar.gz完成集群的搭建。Zk的其他版本下载地址：http://www.apache.org/dist/zookeeper/将下载好的zookeeper解压，建议重命名为zookeeper-3.4.5-1，并且拷贝出相同的两份，分别命名为zookeeper-3.4.5-2，zookeeper-3.4.5-3。 然后在适当的目录下新建一个存放zookeeper数据的目录，笔者新建了devtools目录，在devtools目录中新建zookeeper-1目录，在其中增加data目录和log目录（这两个目录的作用在后面会做说明）；然后将zookeeper-1目录拷贝出两份，分别命名为zookeeper-2，zookeeper-3。笔者目录结构为： 到此，软件和环境准备工作已经做好，接下来就需要对zookeeper的相关配置文件做修改了。 集群配置新下载的Zookeeper，conf目录下有configuration.xsl，log4j.properties，zoo_sample.cfg三个配置文件，我们需要将zoo_sample.cfg复制一份，命名为zoo.cfg，因为zookeeper启动的时候会读取zoo.cfg文件的配置信息。zoo.cfg文件中有几项参数，主要解释一下三项参数：tickTime=2000 基本事件单元，以毫秒为单位。它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。clientPort=2181 监听客户端连接的端口。dataDir=/tmp/zookeeper zookeeper默认存放数据的目录 接下来我们需要修改zoo.cfg中的配置信息。在zoo.cfg中增加这两项配置： dataDir=F:/hadoop/tools/devtools/zookeeper-1/data dataLogDir=F:/hadoop/tools/devtools/zookeeper-1/log 这都是我们之前新建的目录，dataDir前面已经作过说明，dataLogDir是zookeeper存放日志文件的目录，如果不配置dataLogDir，日志文件默认存放到dataDir中。 然后配置zk进程（server.x=ip:clientPort:zkReqPort）： server.1=localhost:2287:3387 server.2=localhost:2288:3388 server.3=localhost:2289:3389 server.x中的“x”表示ZooKeeper Server进程的标识，同一个ZooKeeper集群内的ZooKeeper Server进程间的通信不仅可以使用具体的点IP地址，也可以使用组播地址。 clientPort 表示监听Client端请求的端口号 zkReqPort 表示监听同ZooKeeper集群内其他ZooKeeper Server进程通信请求的端口号因为笔者是在同一台机器上作伪集群的搭建，所以各个zookeeper的ip相同，保证每个zk进程的监听端口错开就可以了，如果是在不同机器上，则不需要。以上配置已经完成了集群99%的搭建工作。 此时需要在每个zookeeper-1/data目录中新建myid文件，文件内容为1，然后在zookeeper-2/data，zookeeper-3/data目录中也同样新建myid文件，内容分别为2和3。1,2,3分别对应server.x中的x，表示zookeeper进程的进程标识。如果不配置zookeeper的进程标识，zk集群将不能找到自己所对应的进程。因此，之前99%的工作也不如此处1%的重要。自此，入门级集群的搭建基本完成。 集群测试首先启动zk集群，windows下直接运行三个zookeeper服务器的zkServer.cmd即可。在启动第一个zookeeper的时候会出现以下错误信息： 这些错误信息不要害怕，因为集群其他进程没启动，检查线程没有找到其他的服务器节点。在启动第二个zookeeper服务器之后就正常了。 启动成功之后就需要我们通过java代码去测试集群是否可用。 新建一个maven工程，在pom.xml文件中添加一下依赖信息： &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; Zkclient是github上一个开源的java zk客户端。编写测试代码 @Test public void testZkClient() { ZkClient zkClient = new ZkClient(&quot;localhost:2181,localhost:2182,localhost:2183&quot;); String node = &quot;/zookeeper-3.4.5-1&quot;; if (zkClient.exists(node)) { System.out.println(node); } } zkClient.exists(node) 检测zookeeper-3.4.5-1 是否存在 zookeeper集群的搭建及测试完成，在Linux下搭建伪集群和不同机器下搭建集群方式基本相同。笔者建议后来者可先在windows环境下搭建，windows的可视化界面效果能够为初学者减少很多出错的地方。","permalink":"/2016/12/20/zookeeper集群部署-单机版/","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"/tags/zookeeper/"}]},{"title":"Spring Boot核心","date":"2016-12-18T12:26:36.000Z","path":"2016/12/18/Spring-Boot核心/","text":"一、Spring Boot基本配置 1、入口类和@SpringBootApplicationSpring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),启动Spring Boot应用项目。 2、关闭特定的自动配置通过@SpringBootApplication源码可以看出，关闭特定的自动配置应该使用@SpringBootApplication注解的exclude参数，例如:@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 3、定制Banner在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。1）我们在src/main/resources下新建一个banner.txt2）通过http://patorjk.com/software/taag网站生成字符，将生成的字符复制到banner.txt文件中3）自动程序，这时控制台图案将变成刚才生成的图案 4、关闭banner在main方法中修改为(Spring Boot:1.4.0)： SpringApplication application = new SpringApplication(Chapter1Application.class); application.setBannerMode(Mode.OFF); application.run(args); 或者 new SpringApplicationBuilder(Chapter1Application.class) // .bannerMode(Mode.OFF) // .run(args); 5、Spring Boot配置文件Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。例如：修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在application.properties中添加： server.port=9090 server.context-path=/helloBoot 6、官方starter pomspring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 准生产特性，用来监控和管理应用spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供基于ssh协议的监控和管理spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-rabbit来支持AMQPspring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Batch的支持spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Cache抽象的支持spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-elasticsearch对Elasticsearch的支持spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-gemfire对分布式存储GenFile的支持spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JPA的支持，包含spring-data-jpa，spring-orm和Hibernatespring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-mongodb，对MongoDB进行支持spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-solr对Apache Solr数据检索平台的支持spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对FreeMarker模板引擎的支持spring-boot-starter-groovy-templates &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持spring-boot-starter-hateoas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas 通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持spring-boot-starter-hornetq &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持spring-boot-starter-integration &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持spring-boot-starter-jdbc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持spring-boot-starter-jersey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持spring-boot-starter-jta-atomikos &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持spring-boot-starter-jta-bitronix &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持spring-boot-starter-mail &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持spring-boot-starter-mobile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持spring-boot-starter-mustache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持spring-boot-starter-redis &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reidsspring-boot-starter-security &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持spring-boot-starter-social-faceboot &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持spring-boot-starter-social-twitter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持spring-boot-starter-test &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板spring-boot-starter-thymeleaf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置spring-boot-starter-velocity &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持spring-boot-starter-web &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvcspring-boot-starter-Tomcat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcatspring-boot-starter-Jetty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcatspring-boot-starter-undertow &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcatspring-boot-starter-logging &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logbackspring-boot-starter-log4j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持spring-boot-starter-ws &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持 还有第三方为Spring Boot所写的starter pom,这里不做介绍 7、使用xml配置Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的@ImportResource来加载xml配置，例如： @ImportResource({&quot;classpath:context.xml”}) 8、命令行参数配置Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号 9、常规属性配置在常规Spring环境下，注入properties文件里的值得方式，通过@PropertySource指明properties文件的位置，然后通过@Value注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用@Value注入即可。例如：在application.properties文件中添加属性： book.author=cm book.name=spring boot 在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性 @Component public class PropertiesTests { @Value(&quot;book.author&quot;) private String author; @Value(&quot;book.name&quot;) private String name; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 10、类型安全的配置（基于properties）Spring Boot提供了基于类型安全的配置方式，通过@ConfigurationProperties将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为： @Component @ConfigurationProperties(prefix = &quot;book&quot;) public class PropertiesTests { private String author; private String name; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 11、日志配置Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。默认情况下，Spring Boot使用Logback作为日志框架。日志级别:logging.file=/home/cm/mylog.log配置日志文件，格式为logging.level.包名=级别：logging.level.org.springframework.web=DEBUG 12、Profile配置Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),通过在application.properties中设置spring.profiles.active=prod来指定活动的Profile例如：我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。两种配置文件分别为： application-prod.properties: server.port=80 application-dev.properties: server.port=8888 然后在application.properties增加： spring.profiles.active=dev(prod) 通过Profile可以灵活切换Spring Boot项目的配置了。 二、Spring Boot运行原理Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：1）运行jar时增加—debug参数：java -jar xx.jar —debug2)在application.properties中设置属性：debug=true（这个方便点）3）在开发工具启动参数中配置 1、Spring Boot运行原理解析： 对@SpringBootApplication注解说明： @SpringBootApplication是一个组合注解，它的核心功能是由@EnableAutoConfiguration注解提供的。查看@EnableAutoConfiguration源码这里@Import注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。 任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下： @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下 @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下 @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件 @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件 @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下 @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下 @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值 @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值 @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下这些注解都是使用了@Conditional元注解，不过是使用了不同的条件而已。 2、分析http的编码配置配置参数 HttpEncodingProperties的源码如下：这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。根据条件配置CharacterEncodingFilter的Bean，源码如下: 3、自定义自动配置（包装成starter pom）1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置: &lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;${spring-framework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2) 新建属性配置类HellpServiceProperties @ConfigurationProperties(prefix = &quot;hello&quot;) public class HelloServiceProperties { private static final String MSG = &quot;world&quot;; private String msg = MSG; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } 此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world 3）新建依据类HelloService（此类可以是第三方类库的类） public class HelloService { private String msg; public String sayHello() { return &quot;Hello &quot; + msg; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } 4）新建自动配置类 @Configuration @EnableConfigurationProperties(HelloServiceProperties.class) @ConditionalOnClass(HelloService.class) @ConditionalOnProperty(prefix = &quot;hello&quot;, value = &quot;enabled&quot;, matchIfMissing = true) public class HelloServiceAutoConfiguration { @Autowired private HelloServiceProperties helloServiceProperties; @Bean @ConditionalOnMissingBean(HelloService.class) public HelloService helloService() { HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; } } 根据HelloServiceProperties提供的参数，并通过@ConditionalOnClass来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。5）注册自动配置在src/main/resources中新建META-INF/spring.factories文件，内容为 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.gnd.springboot.config.HelloServiceAutoConfiguration&lt;br&gt; 其中“\\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔6）测试自定义自动配置新建一个maven web工程，添加如下依赖: &lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;${spring-framework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;spring-boot-starter-hello&lt;/groupId&gt; &lt;artifactId&gt;com.gnd.springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring-boot-starter-hello为之前新建的自定义自动配置starter pom新建测试启动类 @RestController @SpringBootApplication public class Chapter11Application { @Autowired private HelloService helloService; @RequestMapping(&quot;/test&quot;) public String index() { return helloService.sayHello(); } public static void main(String[] args){ SpringApplication.run(Chapter11Application.class, args); } } 运行测试工程之后，浏览器输入”http://localhost:8080/test“测试，测试结果如下:新建application.properties配置文件，内容为 hello.msg=haha 重启工程，浏览器输入”http://localhost:8080/test“测试，测试结果如下:","permalink":"/2016/12/18/Spring-Boot核心/","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/tags/Spring-Boot/"}]},{"title":"jdk各版本区别","date":"2016-12-17T16:06:43.000Z","path":"2016/12/18/jdk各版本区别/","text":"jdk5新特性1、自动装箱和拆箱2、枚举3、静态导入4、可变参数5、內省 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。 一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 6、泛型7、For-Each循环jdk6新特性1、Desktop类和SystemTray类 AWT新增加了两个雷：Desktop，SystemTray。 Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档 SystemTray可以用来在系统托盘区创建一个托盘程序 2、使用JAXB2来实现对象与XML之间的映射 也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。 3、StAX StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4、使用Compiler API 使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。 5、轻量级Http Server API6、插入式注解处理API7、用Console开发控制台程序8、对脚本语言的支持如：ruby，groovy，javascript9、Common Annotationsjdk7新特性1、switch中可以使用字符串2、泛型的自动判断3、自定义自动关闭类（实现AutoCloseable接口）4、新增一些取环境信息的工具方法（System中的方法）5、Boolean类型反转，空指针安全，参数与位运算6、两个char间的equals7、安全的加减乘除1、对Java集合（Collections）的增强支持List&lt;String&gt; list=[&quot;item&quot;]; //向List集合中添加元素 String item=list[0]; //从List集合中获取元素 Set&lt;String&gt; set={&quot;item&quot;}; //向Set集合对象中添加元 Map&lt;String,Integer&gt; map={&quot;key&quot;:1}; //向Map集合中添加对象 int value=map[&quot;key&quot;]; //从Map集合中获取对象 但是经过自己测试，按照上面的使用方法，并不能创建集合。 2、int支持二进制数据3、在try catch异常捕捉中，一个catch可以写多个异常类型Connection conn = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); } catch(ClassNotFoundException|SQLException ex) { ex.printStackTrace(); } 4、try catch中资源定义好之后try catch自动关闭try (BufferedReader in = new BufferedReader(new FileReader(&quot;in.txt&quot;)); BufferedWriter out = new BufferedWriter(new FileWriter(&quot;out.txt&quot;))) { int charRead; while ((charRead = in.read()) != -1) { System.out.printf(&quot;%c &quot;, (char)charRead); out.write(charRead); } } catch (IOException ex) { ex.printStackTrace(); } jdk8新特性1、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下： public interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常 2、Lambda表达式List&lt;String&gt; names = Arrays.asList(&quot;tom&quot;,&quot;jace&quot;,&quot;mike&quot;); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.compareTo(o1); } }); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。在Java 8中提供了更简洁的语法，lambda表达式： Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); }); 还可以更简洁： Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 去掉大括号以及return关键字 Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。 3、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@FunctionalInterface注解标注的接口只能有一个抽象方法。例如： @FunctionalInterface public interface Converter&lt;F, T&gt; { T convert(F from); } Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); 以上代码不需要@FunctionalInterface注解也是正确的。 4、方法与构造函数引用上面的代码也可以通过静态方法引用来表示： Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： public class Person { String firstName; String lastName; Person() { } public Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 指定一个用来创建Person对象的对象工厂接口： public interface PersonFactory&lt;P extends Person&gt; { P create(String fisrtName, String lastName); } 创建Person对象 PersonFactory&lt;Person&gt; personFactory = Person::new; Person person = personFactory.create(&quot;Peter&quot;,&quot;Parker”); 我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5、Lambda作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6、访问局部变量我们可以直接在lambda表达式中访问外层的局部变量 final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。 7、访问对象字段与静态变量和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： static int outerStaticNum; int outerNum; public void testScopes() { Converter stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); }; Converter stringConverter2 = (from) -&gt; { outerStaticNum = 72; return String.valueOf(from); }; } 8、访问接口的默认方法9、Date API10、Annotation注解","permalink":"/2016/12/18/jdk各版本区别/","tags":[{"name":"jdk版本","slug":"jdk版本","permalink":"/tags/jdk版本/"}]},{"title":"Spring Boot入门","date":"2016-12-13T15:18:29.000Z","path":"2016/12/13/Spring-Boot入门/","text":"一、Spring Boot简介 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。 Spring Boot有以下几个优点： 1、 没有代码生成，不需要XML配置文件 2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器 3、 可以独立运行Spring应用程序 4、 提供了Maven，Gradle两种方法搭建Spring Boot工程 5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合） 6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查 二、Spring Boot入门工程搭建：1、采用Spring官网提供的SPRING INITIALIZR进行搭建。可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。 2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）1、新建一个Maven的web工程2、在pom.xml文件中添加Spring Boot的相关依赖添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 然后在dependencies中添加Web支持的starter pom。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; spring-boot-starter-web会自动添加它所依赖的jar包 然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 3、简单测试新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法 @SpringBootApplication public class Chapter01Application { public static void main(String[] args){ SpringApplication.run(Chapter01Application.class, args); } } 注：@SpringBootApplication是一个组合注解，查看其源码，@SpringBootApplication组合了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解，@SpringBootConfiguration表示当前类是一个启动应用程序的入口；@EnableAutoConfiguration注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了@Component注解的类。 然后新建目录controller，在其中新建一个HelloController测试类。 @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String index() { return &quot;Hello, World!&quot;; } } @RestController也是一个组合注解，组合了@Controller，@ResponseBody两个注解 4、运行使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问[http://localhost:8080/hello](http://localhost:8080/hello)即可访问HelloController，访问结果如下：","permalink":"/2016/12/13/Spring-Boot入门/","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/tags/Spring-Boot/"}]}]