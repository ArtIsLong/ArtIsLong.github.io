{"meta":{"title":"ArtIsLong的博客","subtitle":"好的程序猿都是野路子","description":"甘肃农业大学16级毕业生","author":"ArtIsLong的博客","url":""},"pages":[{}],"posts":[{"title":"storm集群搭建","date":"2018-08-07T05:45:58.000Z","path":"2018/08/07/storm集群搭建/","text":"基本配置详解 配置项 配置说明 storm.zookeeper.servers ZooKeeper服务器列表 storm.zookeeper.port ZooKeeper连接端口 storm.local.dir storm使用的本地文件系统目录(必须存在并且storm进程可读写) storm.cluster.mode Storm集群运行模式([distributed\\ local]) storm.local.mode.zmq Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false storm.zookeeper.root ZooKeeper中Storm的根目录位置 storm.zookeeper.session.timeout 客户端连接ZooKeeper超时时间 storm.id 运行中拓扑的id,由storm name和一个唯一随机数组成。 nimbus.host nimbus服务器地址 nimbus.thrift.port nimbus的thrift监听端口 nimbus.childopts 通过storm-deploy项目部署时指定给nimbus进程的jvm选项 nimbus.task.timeout.secs 心跳超时时间，超时后nimbus会认为task死掉并重分配给另一个地址。 nimbus.monitor.freq.secs nimbus检查心跳和重分配任务的时间间隔.注意如果是机器宕掉nimbus会立即接管并处理。 nimbus.supervisor.timeout.secs supervisor的心跳超时时间,一旦超过nimbus会认为该supervisor已死并停止为它分发新任务. nimbus.task.launch.secs task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs. nimbus.reassign 当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。 nimbus.file.copy.expiration.secs nimbus判断上传/下载链接的超时时间，当空闲时间超过该设定时nimbus会认为链接死掉并主动断开 ui.port Storm UI的服务端口 drpc.servers DRPC服务器列表，以便DRPCSpout知道和谁通讯 drpc.port Storm DRPC的服务端口 supervisor.slots.ports supervisor上能够运行workers的端口列表.每个worker占用一个端口,且每个端口只运行一个worker.通过这项配置可以调整每台机器上运行的worker数.(调整slot数/每机) supervisor.childopts 在storm-deploy项目中使用,用来配置supervisor守护进程的jvm选项 supervisor.worker.timeout.secs supervisor中的worker心跳超时时间,一旦超时supervisor会尝试重启worker进程. supervisor.worker.start.timeout.secs supervisor初始启动时，worker的心跳超时时间，当超过该时间supervisor会尝试重启worker。因为JVM初始启动和配置会带来的额外消耗，从而使得第一次心跳会超过supervisor.worker.timeout.secs的设定 supervisor.enable supervisor是否应当运行分配给他的workers.默认为true,该选项用来进行Storm的单元测试,一般不应修改. supervisor.heartbeat.frequency.secs supervisor心跳发送频率(多久发送一次) supervisor.monitor.frequency.secs supervisor检查worker心跳的频率 worker.childopts supervisor启动worker时使用的jvm选项.所有的”%ID%”字串会被替换为对应worker的标识符 worker.heartbeat.frequency.secs worker的心跳发送时间间隔 task.heartbeat.frequency.secs task汇报状态心跳时间间隔 task.refresh.poll.secs task与其他tasks之间链接同步的频率.(如果task被重分配,其他tasks向它发送消息需要刷新连接).一般来讲，重分配发生时其他tasks会理解得到通知。该配置仅仅为了防止未通知的情况。 topology.debug 如果设置成true，Storm将记录发射的每条信息。 topology.optimize master是否在合适时机通过在单个线程内运行多个task以达到优化topologies的目的. topology.workers 执行该topology集群中应当启动的进程数量.每个进程内部将以线程方式执行一定数目的tasks.topology的组件结合该参数和并行度提示来优化性能 topology.ackers topology中启动的acker任务数.Acker保存由spout发送的tuples的记录，并探测tuple何时被完全处理.当Acker探测到tuple被处理完毕时会向spout发送确认信息.通常应当根据topology的吞吐量来确定acker的数目，但一般不需要太多.当设置为0时,相当于禁用了消息可靠性,storm会在spout发送tuples后立即进行确认. topology.message.timeout.secs topology中spout发送消息的最大处理超时时间.如果一条消息在该时间窗口内未被成功ack,Storm会告知spout这条消息失败。而部分spout实现了失败消息重播功能。 topology.kryo.register 注册到Kryo(Storm底层的序列化框架)的序列化方案列表.序列化方案可以是一个类名,或者是com.esotericsoftware.kryo.Serializer的实现. topology.skip.missing.kryo.registrations Storm是否应该跳过它不能识别的kryo序列化方案.如果设置为否task可能会装载失败或者在运行时抛出错误. topology.max.task.parallelism 在一个topology中能够允许的最大组件并行度.该项配置主要用在本地模式中测试线程数限制. topology.max.spout.pending 一个spout task中处于pending状态的最大的tuples数量.该配置应用于单个task,而不是整个spouts或topology. topology.state.synchronization.timeout.secs 组件同步状态源的最大超时时间(保留选项,暂未使用) topology.stats.sample.rate 用来产生task统计信息的tuples抽样百分比 topology.fall.back.on.java.serialization topology中是否使用java的序列化方案 zmq.threads 每个worker进程内zeromq通讯用到的线程数 zmq.linger.millis 当连接关闭时,链接尝试重新发送消息到目标主机的持续时长.这是一个不常用的高级选项,基本上可以忽略. java.library.path JVM启动(如Nimbus,Supervisor和workers)时的java.library.path设置.该选项告诉JVM在哪些路径下定位本地库. 环境准备 从Storm官网下载Storm安装包，本文使用的Storm版本为1.2.2 从Zookeeper官网下载Zookeeper安装包 开始安装配置由于Zookeeper和Storm都是以Java为基础开发的，所以需要Java环境，在Linux服务器上配置Java开发环境，此处不做累述，读者请自行百度。 搭建Zookeeper集群参考 Zookeeper集群搭建博客 搭建Storm集群配置1234wget https://www.apache.org/dyn/closer.lua/storm/apache-storm-1.2.2/apache-storm-1.2.2.tar.gztar -zxvf apache-storm-1.2.2.tar.gzcd apache-storm-1.2.2/confvi storm.yaml 主要的配置项有一下几点： 配置Storm集群的Zookeeper集群主机列表 1234storm.zookeeper.servers: - \"master\" - \"slave1\" - \"slave2\" 如果Zookeeper集群使用的端口与默认端口不同，还需一下配置： 1storm.zookeeper.port: 2182 指定Storm数据存储目录 Nimbus和Supervisor守护进程需要在本地磁盘上存储少量状态信息。需要我们手动在每台Supervisor机器上创建此目录，并授予适当的权限。 1storm.local.dir: \"/home/hadoop/storm/data\" 如果使用相对路径，可以相对于安装Storm的位置（STORM_HOME），或者使用默认值留空。 1$STORM_HOME/data supervisor的worker数量配置 以下配置指定supervisor的工作节点，可以运行的worker数量，每个worker占用一个端口来接收消息，最多分配5个；默认情况下每个节点可以运行4个worker，分别在6700、6701、6702、6703，此处定义几个端口，则就表示可以运行几个worker。 12345supervisor.slots.ports: - 6700 - 6701 - 6702 - 6703 此处为最基本的配置，若需其他对集群的优化配置，请查看官网Storm集群搭建教程，上面有详细的配置方式。（英语较差的童鞋，不要害怕英文文档，试着读，多读几遍，慢慢的大概意思也会了解了，有道是“书读百遍其义自见”） 启动集群 在Nimbus主机上启动nimbus 1bin/storm nimbus 2&gt;&amp;1 &amp; 在每个Storm集群节点上启动supervisor 1bin/storm supervisor 2&gt;&amp;1 &amp; 在Nimbus主机上启动Storm UI 1bin/storm ui 2&gt;&amp;1 &amp;","raw":"---\nlayout: post\ntitle: storm集群搭建\ntoc: true\ndate: 2018-08-07 13:45:58\ntags: 大数据\ncategories: storm\ndescription: Storm集群搭建\n---\n\n## 基本配置详解 <!--more-->\n\n| 配置项                                      | 配置说明                                                     |\n| ------------------------------------------- | ------------------------------------------------------------ |\n| storm.zookeeper.servers                     | ZooKeeper服务器列表                                          |\n| storm.zookeeper.port                        | ZooKeeper连接端口                                            |\n| storm.local.dir                             | storm使用的本地文件系统目录(必须存在并且storm进程可读写)     |\n| storm.cluster.mode                          | Storm集群运行模式([distributed\\|local])                      |\n| storm.local.mode.zmq                        | Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false |\n| storm.zookeeper.root                        | ZooKeeper中Storm的根目录位置                                 |\n| storm.zookeeper.session.timeout             | 客户端连接ZooKeeper超时时间                                  |\n| storm.id                                    | 运行中拓扑的id,由storm name和一个唯一随机数组成。            |\n| nimbus.host                                 | nimbus服务器地址                                             |\n| nimbus.thrift.port                          | nimbus的thrift监听端口                                       |\n| nimbus.childopts                            | 通过storm-deploy项目部署时指定给nimbus进程的jvm选项          |\n| nimbus.task.timeout.secs                    | 心跳超时时间，超时后nimbus会认为task死掉并重分配给另一个地址。 |\n| nimbus.monitor.freq.secs                    | nimbus检查心跳和重分配任务的时间间隔.注意如果是机器宕掉nimbus会立即接管并处理。 |\n| nimbus.supervisor.timeout.secs              | supervisor的心跳超时时间,一旦超过nimbus会认为该supervisor已死并停止为它分发新任务. |\n| nimbus.task.launch.secs                     | task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs. |\n| nimbus.reassign                             | 当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。 |\n| nimbus.file.copy.expiration.secs            | nimbus判断上传/下载链接的超时时间，当空闲时间超过该设定时nimbus会认为链接死掉并主动断开 |\n| ui.port                                     | Storm UI的服务端口                                           |\n| drpc.servers                                | DRPC服务器列表，以便DRPCSpout知道和谁通讯                    |\n| drpc.port                                   | Storm DRPC的服务端口                                         |\n| supervisor.slots.ports                      | supervisor上能够运行workers的端口列表.每个worker占用一个端口,且每个端口只运行一个worker.通过这项配置可以调整每台机器上运行的worker数.(调整slot数/每机) |\n| supervisor.childopts                        | 在storm-deploy项目中使用,用来配置supervisor守护进程的jvm选项 |\n| supervisor.worker.timeout.secs              | supervisor中的worker心跳超时时间,一旦超时supervisor会尝试重启worker进程. |\n| supervisor.worker.start.timeout.secs        | supervisor初始启动时，worker的心跳超时时间，当超过该时间supervisor会尝试重启worker。因为JVM初始启动和配置会带来的额外消耗，从而使得第一次心跳会超过supervisor.worker.timeout.secs的设定 |\n| supervisor.enable                           | supervisor是否应当运行分配给他的workers.默认为true,该选项用来进行Storm的单元测试,一般不应修改. |\n| supervisor.heartbeat.frequency.secs         | supervisor心跳发送频率(多久发送一次)                         |\n| supervisor.monitor.frequency.secs           | supervisor检查worker心跳的频率                               |\n| worker.childopts                            | supervisor启动worker时使用的jvm选项.所有的”%ID%”字串会被替换为对应worker的标识符 |\n| worker.heartbeat.frequency.secs             | worker的心跳发送时间间隔                                     |\n| task.heartbeat.frequency.secs               | task汇报状态心跳时间间隔                                     |\n| task.refresh.poll.secs                      | task与其他tasks之间链接同步的频率.(如果task被重分配,其他tasks向它发送消息需要刷新连接).一般来讲，重分配发生时其他tasks会理解得到通知。该配置仅仅为了防止未通知的情况。 |\n| topology.debug                              | 如果设置成true，Storm将记录发射的每条信息。                  |\n| topology.optimize                           | master是否在合适时机通过在单个线程内运行多个task以达到优化topologies的目的. |\n| topology.workers                            | 执行该topology集群中应当启动的进程数量.每个进程内部将以线程方式执行一定数目的tasks.topology的组件结合该参数和并行度提示来优化性能 |\n| topology.ackers                             | topology中启动的acker任务数.Acker保存由spout发送的tuples的记录，并探测tuple何时被完全处理.当Acker探测到tuple被处理完毕时会向spout发送确认信息.通常应当根据topology的吞吐量来确定acker的数目，但一般不需要太多.当设置为0时,相当于禁用了消息可靠性,storm会在spout发送tuples后立即进行确认. |\n| topology.message.timeout.secs               | topology中spout发送消息的最大处理超时时间.如果一条消息在该时间窗口内未被成功ack,Storm会告知spout这条消息失败。而部分spout实现了失败消息重播功能。 |\n| topology.kryo.register                      | 注册到Kryo(Storm底层的序列化框架)的序列化方案列表.序列化方案可以是一个类名,或者是com.esotericsoftware.kryo.Serializer的实现. |\n| topology.skip.missing.kryo.registrations    | Storm是否应该跳过它不能识别的kryo序列化方案.如果设置为否task可能会装载失败或者在运行时抛出错误. |\n| topology.max.task.parallelism               | 在一个topology中能够允许的最大组件并行度.该项配置主要用在本地模式中测试线程数限制. |\n| topology.max.spout.pending                  | 一个spout task中处于pending状态的最大的tuples数量.该配置应用于单个task,而不是整个spouts或topology. |\n| topology.state.synchronization.timeout.secs | 组件同步状态源的最大超时时间(保留选项,暂未使用)              |\n| topology.stats.sample.rate                  | 用来产生task统计信息的tuples抽样百分比                       |\n| topology.fall.back.on.java.serialization    | topology中是否使用java的序列化方案                           |\n| zmq.threads                                 | 每个worker进程内zeromq通讯用到的线程数                       |\n| zmq.linger.millis                           | 当连接关闭时,链接尝试重新发送消息到目标主机的持续时长.这是一个不常用的高级选项,基本上可以忽略. |\n| java.library.path                           | JVM启动(如Nimbus,Supervisor和workers)时的java.library.path设置.该选项告诉JVM在哪些路径下定位本地库. |\n\n## 环境准备\n\n- 从[Storm官网](http://storm.apache.org/downloads.html)下载Storm安装包，本文使用的Storm版本为1.2.2 \n\n- 从[Zookeeper官网](http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.10)下载Zookeeper安装包\n\n## 开始安装配置\n\n由于Zookeeper和Storm都是以Java为基础开发的，所以需要Java环境，在Linux服务器上配置Java开发环境，此处不做累述，读者请自行百度。\n\n### 搭建Zookeeper集群\n\n参考 Zookeeper集群搭建博客\n\n### 搭建Storm集群\n\n#### 配置\n\n~~~\nwget https://www.apache.org/dyn/closer.lua/storm/apache-storm-1.2.2/apache-storm-1.2.2.tar.gz\ntar -zxvf apache-storm-1.2.2.tar.gz\ncd apache-storm-1.2.2/conf\nvi storm.yaml\n~~~\n\n主要的配置项有一下几点：\n\n- 配置Storm集群的Zookeeper集群主机列表\n~~~\nstorm.zookeeper.servers:\n    - \"master\"\n    - \"slave1\"\n    - \"slave2\"\n~~~\n\n- 如果Zookeeper集群使用的端口与默认端口不同，还需一下配置：\n\n~~~\nstorm.zookeeper.port: 2182\n~~~\n\n- 指定Storm数据存储目录\n\nNimbus和Supervisor守护进程需要在本地磁盘上存储少量状态信息。需要我们手动在每台Supervisor机器上创建此目录，并授予适当的权限。\n\n~~~\nstorm.local.dir: \"/home/hadoop/storm/data\"\n~~~\n\n如果使用相对路径，可以相对于安装Storm的位置（STORM_HOME），或者使用默认值留空。\n\n~~~\n$STORM_HOME/data\n~~~\n\n- supervisor的worker数量配置\n\n以下配置指定supervisor的工作节点，可以运行的worker数量，每个worker占用一个端口来接收消息，最多分配5个；默认情况下每个节点可以运行4个worker，分别在6700、6701、6702、6703，此处定义几个端口，则就表示可以运行几个worker。\n\n~~~\nsupervisor.slots.ports:\n    - 6700\n    - 6701\n    - 6702\n    - 6703\n~~~\n\n此处为最基本的配置，若需其他对集群的优化配置，请查看官网Storm集群搭建教程，上面有详细的配置方式。（英语较差的童鞋，不要害怕英文文档，试着读，多读几遍，慢慢的大概意思也会了解了，有道是“书读百遍其义自见”）\n\n#### 启动集群\n\n- 在Nimbus主机上启动nimbus\n\n~~~shell\nbin/storm nimbus 2>&1 &\n~~~\n\n- 在每个Storm集群节点上启动supervisor\n\n~~~shell\nbin/storm supervisor 2>&1 &\n~~~\n\n- 在Nimbus主机上启动Storm UI\n\n~~~shell\nbin/storm ui 2>&1 &\n~~~","content":"<h2 id=\"基本配置详解\"><a href=\"#基本配置详解\" class=\"headerlink\" title=\"基本配置详解 \"></a>基本配置详解 <a id=\"more\"></a></h2><table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>配置说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>storm.zookeeper.servers</td>\n<td>ZooKeeper服务器列表</td>\n</tr>\n<tr>\n<td>storm.zookeeper.port</td>\n<td>ZooKeeper连接端口</td>\n</tr>\n<tr>\n<td>storm.local.dir</td>\n<td>storm使用的本地文件系统目录(必须存在并且storm进程可读写)</td>\n</tr>\n<tr>\n<td>storm.cluster.mode</td>\n<td>Storm集群运行模式([distributed\\</td>\n<td>local])</td>\n</tr>\n<tr>\n<td>storm.local.mode.zmq</td>\n<td>Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false</td>\n</tr>\n<tr>\n<td>storm.zookeeper.root</td>\n<td>ZooKeeper中Storm的根目录位置</td>\n</tr>\n<tr>\n<td>storm.zookeeper.session.timeout</td>\n<td>客户端连接ZooKeeper超时时间</td>\n</tr>\n<tr>\n<td>storm.id</td>\n<td>运行中拓扑的id,由storm name和一个唯一随机数组成。</td>\n</tr>\n<tr>\n<td>nimbus.host</td>\n<td>nimbus服务器地址</td>\n</tr>\n<tr>\n<td>nimbus.thrift.port</td>\n<td>nimbus的thrift监听端口</td>\n</tr>\n<tr>\n<td>nimbus.childopts</td>\n<td>通过storm-deploy项目部署时指定给nimbus进程的jvm选项</td>\n</tr>\n<tr>\n<td>nimbus.task.timeout.secs</td>\n<td>心跳超时时间，超时后nimbus会认为task死掉并重分配给另一个地址。</td>\n</tr>\n<tr>\n<td>nimbus.monitor.freq.secs</td>\n<td>nimbus检查心跳和重分配任务的时间间隔.注意如果是机器宕掉nimbus会立即接管并处理。</td>\n</tr>\n<tr>\n<td>nimbus.supervisor.timeout.secs</td>\n<td>supervisor的心跳超时时间,一旦超过nimbus会认为该supervisor已死并停止为它分发新任务.</td>\n</tr>\n<tr>\n<td>nimbus.task.launch.secs</td>\n<td>task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs.</td>\n</tr>\n<tr>\n<td>nimbus.reassign</td>\n<td>当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。</td>\n</tr>\n<tr>\n<td>nimbus.file.copy.expiration.secs</td>\n<td>nimbus判断上传/下载链接的超时时间，当空闲时间超过该设定时nimbus会认为链接死掉并主动断开</td>\n</tr>\n<tr>\n<td>ui.port</td>\n<td>Storm UI的服务端口</td>\n</tr>\n<tr>\n<td>drpc.servers</td>\n<td>DRPC服务器列表，以便DRPCSpout知道和谁通讯</td>\n</tr>\n<tr>\n<td>drpc.port</td>\n<td>Storm DRPC的服务端口</td>\n</tr>\n<tr>\n<td>supervisor.slots.ports</td>\n<td>supervisor上能够运行workers的端口列表.每个worker占用一个端口,且每个端口只运行一个worker.通过这项配置可以调整每台机器上运行的worker数.(调整slot数/每机)</td>\n</tr>\n<tr>\n<td>supervisor.childopts</td>\n<td>在storm-deploy项目中使用,用来配置supervisor守护进程的jvm选项</td>\n</tr>\n<tr>\n<td>supervisor.worker.timeout.secs</td>\n<td>supervisor中的worker心跳超时时间,一旦超时supervisor会尝试重启worker进程.</td>\n</tr>\n<tr>\n<td>supervisor.worker.start.timeout.secs</td>\n<td>supervisor初始启动时，worker的心跳超时时间，当超过该时间supervisor会尝试重启worker。因为JVM初始启动和配置会带来的额外消耗，从而使得第一次心跳会超过supervisor.worker.timeout.secs的设定</td>\n</tr>\n<tr>\n<td>supervisor.enable</td>\n<td>supervisor是否应当运行分配给他的workers.默认为true,该选项用来进行Storm的单元测试,一般不应修改.</td>\n</tr>\n<tr>\n<td>supervisor.heartbeat.frequency.secs</td>\n<td>supervisor心跳发送频率(多久发送一次)</td>\n</tr>\n<tr>\n<td>supervisor.monitor.frequency.secs</td>\n<td>supervisor检查worker心跳的频率</td>\n</tr>\n<tr>\n<td>worker.childopts</td>\n<td>supervisor启动worker时使用的jvm选项.所有的”%ID%”字串会被替换为对应worker的标识符</td>\n</tr>\n<tr>\n<td>worker.heartbeat.frequency.secs</td>\n<td>worker的心跳发送时间间隔</td>\n</tr>\n<tr>\n<td>task.heartbeat.frequency.secs</td>\n<td>task汇报状态心跳时间间隔</td>\n</tr>\n<tr>\n<td>task.refresh.poll.secs</td>\n<td>task与其他tasks之间链接同步的频率.(如果task被重分配,其他tasks向它发送消息需要刷新连接).一般来讲，重分配发生时其他tasks会理解得到通知。该配置仅仅为了防止未通知的情况。</td>\n</tr>\n<tr>\n<td>topology.debug</td>\n<td>如果设置成true，Storm将记录发射的每条信息。</td>\n</tr>\n<tr>\n<td>topology.optimize</td>\n<td>master是否在合适时机通过在单个线程内运行多个task以达到优化topologies的目的.</td>\n</tr>\n<tr>\n<td>topology.workers</td>\n<td>执行该topology集群中应当启动的进程数量.每个进程内部将以线程方式执行一定数目的tasks.topology的组件结合该参数和并行度提示来优化性能</td>\n</tr>\n<tr>\n<td>topology.ackers</td>\n<td>topology中启动的acker任务数.Acker保存由spout发送的tuples的记录，并探测tuple何时被完全处理.当Acker探测到tuple被处理完毕时会向spout发送确认信息.通常应当根据topology的吞吐量来确定acker的数目，但一般不需要太多.当设置为0时,相当于禁用了消息可靠性,storm会在spout发送tuples后立即进行确认.</td>\n</tr>\n<tr>\n<td>topology.message.timeout.secs</td>\n<td>topology中spout发送消息的最大处理超时时间.如果一条消息在该时间窗口内未被成功ack,Storm会告知spout这条消息失败。而部分spout实现了失败消息重播功能。</td>\n</tr>\n<tr>\n<td>topology.kryo.register</td>\n<td>注册到Kryo(Storm底层的序列化框架)的序列化方案列表.序列化方案可以是一个类名,或者是com.esotericsoftware.kryo.Serializer的实现.</td>\n</tr>\n<tr>\n<td>topology.skip.missing.kryo.registrations</td>\n<td>Storm是否应该跳过它不能识别的kryo序列化方案.如果设置为否task可能会装载失败或者在运行时抛出错误.</td>\n</tr>\n<tr>\n<td>topology.max.task.parallelism</td>\n<td>在一个topology中能够允许的最大组件并行度.该项配置主要用在本地模式中测试线程数限制.</td>\n</tr>\n<tr>\n<td>topology.max.spout.pending</td>\n<td>一个spout task中处于pending状态的最大的tuples数量.该配置应用于单个task,而不是整个spouts或topology.</td>\n</tr>\n<tr>\n<td>topology.state.synchronization.timeout.secs</td>\n<td>组件同步状态源的最大超时时间(保留选项,暂未使用)</td>\n</tr>\n<tr>\n<td>topology.stats.sample.rate</td>\n<td>用来产生task统计信息的tuples抽样百分比</td>\n</tr>\n<tr>\n<td>topology.fall.back.on.java.serialization</td>\n<td>topology中是否使用java的序列化方案</td>\n</tr>\n<tr>\n<td>zmq.threads</td>\n<td>每个worker进程内zeromq通讯用到的线程数</td>\n</tr>\n<tr>\n<td>zmq.linger.millis</td>\n<td>当连接关闭时,链接尝试重新发送消息到目标主机的持续时长.这是一个不常用的高级选项,基本上可以忽略.</td>\n</tr>\n<tr>\n<td>java.library.path</td>\n<td>JVM启动(如Nimbus,Supervisor和workers)时的java.library.path设置.该选项告诉JVM在哪些路径下定位本地库.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li><p>从<a href=\"http://storm.apache.org/downloads.html\" target=\"_blank\" rel=\"noopener\">Storm官网</a>下载Storm安装包，本文使用的Storm版本为1.2.2 </p>\n</li>\n<li><p>从<a href=\"http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.10\" target=\"_blank\" rel=\"noopener\">Zookeeper官网</a>下载Zookeeper安装包</p>\n</li>\n</ul>\n<h2 id=\"开始安装配置\"><a href=\"#开始安装配置\" class=\"headerlink\" title=\"开始安装配置\"></a>开始安装配置</h2><p>由于Zookeeper和Storm都是以Java为基础开发的，所以需要Java环境，在Linux服务器上配置Java开发环境，此处不做累述，读者请自行百度。</p>\n<h3 id=\"搭建Zookeeper集群\"><a href=\"#搭建Zookeeper集群\" class=\"headerlink\" title=\"搭建Zookeeper集群\"></a>搭建Zookeeper集群</h3><p>参考 Zookeeper集群搭建博客</p>\n<h3 id=\"搭建Storm集群\"><a href=\"#搭建Storm集群\" class=\"headerlink\" title=\"搭建Storm集群\"></a>搭建Storm集群</h3><h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http<span class=\"variable\">s:</span>//www.apache.org/dyn/closer.<span class=\"keyword\">lua</span>/storm/apache-storm-<span class=\"number\">1.2</span>.<span class=\"number\">2</span>/apache-storm-<span class=\"number\">1.2</span>.<span class=\"number\">2</span>.tar.gz</span><br><span class=\"line\">tar -zxvf apache-storm-<span class=\"number\">1.2</span>.<span class=\"number\">2</span>.tar.gz</span><br><span class=\"line\"><span class=\"keyword\">cd</span> apache-storm-<span class=\"number\">1.2</span>.<span class=\"number\">2</span>/<span class=\"keyword\">conf</span></span><br><span class=\"line\"><span class=\"keyword\">vi</span> storm.yaml</span><br></pre></td></tr></table></figure>\n<p>主要的配置项有一下几点：</p>\n<ul>\n<li><p>配置Storm集群的Zookeeper集群主机列表</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm.zookeeper.servers:</span><br><span class=\"line\">    -<span class=\"ruby\"> <span class=\"string\">\"master\"</span></span></span><br><span class=\"line\"><span class=\"ruby\">    - <span class=\"string\">\"slave1\"</span></span></span><br><span class=\"line\"><span class=\"ruby\">    - <span class=\"string\">\"slave2\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果Zookeeper集群使用的端口与默认端口不同，还需一下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm<span class=\"selector-class\">.zookeeper</span><span class=\"selector-class\">.port</span>: <span class=\"number\">2182</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>指定Storm数据存储目录</li>\n</ul>\n<p>Nimbus和Supervisor守护进程需要在本地磁盘上存储少量状态信息。需要我们手动在每台Supervisor机器上创建此目录，并授予适当的权限。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm<span class=\"selector-class\">.local</span><span class=\"selector-class\">.dir</span>: <span class=\"string\">\"/home/hadoop/storm/data\"</span></span><br></pre></td></tr></table></figure>\n<p>如果使用相对路径，可以相对于安装Storm的位置（STORM_HOME），或者使用默认值留空。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">$STORM</span>_HOME/data</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>supervisor的worker数量配置</li>\n</ul>\n<p>以下配置指定supervisor的工作节点，可以运行的worker数量，每个worker占用一个端口来接收消息，最多分配5个；默认情况下每个节点可以运行4个worker，分别在6700、6701、6702、6703，此处定义几个端口，则就表示可以运行几个worker。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisor.slots.ports:</span><br><span class=\"line\">    -<span class=\"ruby\"> <span class=\"number\">6700</span></span></span><br><span class=\"line\"><span class=\"ruby\">    - <span class=\"number\">6701</span></span></span><br><span class=\"line\"><span class=\"ruby\">    - <span class=\"number\">6702</span></span></span><br><span class=\"line\"><span class=\"ruby\">    - <span class=\"number\">6703</span></span></span><br></pre></td></tr></table></figure>\n<p>此处为最基本的配置，若需其他对集群的优化配置，请查看官网Storm集群搭建教程，上面有详细的配置方式。（英语较差的童鞋，不要害怕英文文档，试着读，多读几遍，慢慢的大概意思也会了解了，有道是“书读百遍其义自见”）</p>\n<h4 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h4><ul>\n<li>在Nimbus主机上启动nimbus</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/storm nimbus 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在每个Storm集群节点上启动supervisor</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/storm supervisor 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在Nimbus主机上启动Storm UI</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/storm ui 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>","slug":"storm集群搭建","updated":"2018-08-07T09:14:09.000Z","comments":true,"link":"","permalink":"/2018/08/07/storm集群搭建/","excerpt":"基本配置详解","categories":[{"name":"storm","slug":"storm","permalink":"/categories/storm/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"/tags/大数据/"}]},{"title":"zookeeper集群搭建","date":"2018-08-07T05:43:07.000Z","path":"2018/08/07/zookeeper集群搭建/","text":"本文的所有配置及集群的搭建，都是基于zookeeper-3.4.10的。 zoo.cfg配置详解 参数名 说明 clientPort 客户端连接Server的端口，即对外服务端口，一般设置为2181 dataDir 存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir，事务日志的写性能直接影响zk性能 tickTime zk中的一个时间单元，zk中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime dataLogDir 事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升zk性能（No Java System Property） globalOutstandingLimit 最大请求堆积数。默认是1000。zk运行的时候，尽管server已经没有空闲来处理更多的客户端请求了，但还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。(Java System Property:zookeeper.globalOutstandingLimit) preAllocSize 预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果zk的快照频率较大的话，建议适当减小这个参数。（Java System Property:zookeeper.preAllocSize） snapCount 每进行snapCount次事务日志输出后，出发一次快照(snapshot)，此时，zk会生成一个snapshot.文件，同时创建一个新的事务日志文件log.\\。默认是100000.(真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能)。(Java System Property:zookeeper.snapCount) traceFile 用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java System Property:zookeeper.requestTraceFile) maxClientCnxns 单个客户端与单台服务器之间的连接数的限制，是IP级别的，默认是60，如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台zk服务器直接的连接数限制，不是针对指定客户端IP，也不是zk集群的连接数限制，也不是单台zk对所有客户端的连接数限制。 clientPortAddress 对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听clientPort指定的端口。 minSessionTimeoutmaxSessionTimeout Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2*tickTime~20*tickTime这个范文 fsync.warningthresholdms 事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。( Java system property: fsync.warningthresholdms) autopurge.purgeInterval 在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property) autopurge.snapRetainCount 这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property) electionAlg 在之前的版本中， 这个参数配置是允许我们选择leader选举算法，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property) initLimit Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在 initLimit 时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property) syncLimit 在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property) leaderServes 默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper.leaderServes) server.x=[hostname]:nnnnn[:nnnnn] 这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。 (No Java system property) group.x=nnnnn[:nnnnn]weight.x=nnnnn 对机器分组和权重设置，可以 参见这里(No Java system property) cnxTimeout Leader选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper.cnxTimeout) zookeeper.DigestAuthenticationProvider.superDigest ZK权限设置相关，具体参见 《 使用super 身份对有权限的节点进行操作 》 和 《 ZooKeeper 权限控制 》 skipACL 对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property: zookeeper.skipACL) forceSync 这个参数确定了是否需要在事务日志提交的时候调用 FileChannel .force来保证数据完全同步到磁盘。(Java system property:zookeeper.forceSync) jute.maxbuffer 每个节点最大数据量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property:jute.maxbuffer) zoo.cfg配置要求类型配置项描述最低配置clientPort监听客户端连接的端口，默认值为2181dataDir存储持久数据的本地文件系统位置tickTime基本事件单元，以毫秒为单位，用来控制心跳和超时，默认情况下超时时间为两倍的tickTime高级配置dataLogDir事件日志写入的目录maxClientCnxns限制连接到Zookeeper的客户端数量，并且限制并发连接数量，它通过ip区分不同的客户端minSessionTimeout与maxSessionTimeout最小会话超时时间和最大的会话超时时间，在默认情况下，最小的会话超时时间为两倍的tickTime时间，最大的会话超时时间为20倍的会话超时时间，系统启动时会显示相应的信息。默认为-1集群配置initLimit参数设定了允许所有Follower与Leader进行连接并同步的时间，如果在设定的时间段内，半数以上的Follower未能完成同步，Leader便会宣布放弃领导地位，进行另一次的Leader选举。如果zk集群环境数量确实很大，同步数据的时间会很变长，因此这种情况下可以适当调大该参数。默认为10syncLimit参数设定了允许一个Follower与一个Leader进行同步的时间，如果在设定的时间段内，Follower未完成同步，它将会被集群丢弃。所有连接到这个Follower的客户端将连接到另外一个Followerserver.A=B:C:D其中A是一个数字，表示这个是第几号服务器；B是这个服务器的IP地址或者主机名称；C表示的是Follower与Leader交换信息的端口，默认值为2888；D表示的是Leader选举端口，默认值为3888 集群搭建软件准备由于zookeeper是基于Java开发的，所以需要Java环境，需要的童鞋，请自行百度，安装Java环境 1234wget http://ftp.mirror.tw/pub/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gztar -zxvf zookeeper-3.4.10.tar.gzcd zookeeper-3.4.10/confmv zoo_sample.cfg 注意： zookeeper默认配置文件为zoo_sample.cfg，需要自定义配置时，需要将此配置文件修改为zoo.cfg，注意，zoo.cfg和zoo_sample.cfg文件不能同时存在 集群配置 zoo.cfg对此配置文件的配置项不做解释，每项具体含义，上面都有详细解释，读者可自行查阅1234567891011tickTime=2000initLimit=10syncLimit=5dataDir=/home/zk/zookeeper-3.4.10/data/dataLogDir=/home/zk/zookeeper-3.4.10/logs/clientPort=2181autopurge.snapRetainCount=500autopurge.purgeInterval=24server.1=192.168.11.12:2888:3888server.2=192.168.11.13:2888:3888server.3=192.168.11.14:2888:3888 然后将配置文件同步到其他两台服务器上。推荐使用scp命令，如： 1scp /home/zk/zookeeper-3.4.10/conf/zoo.cfg zk@192.168.11.12:/home/zk/zookeeper-3.4.10/conf 创建ServerID标识（敲黑板了，此处是重点） 在192.168.11.12服务器的/home/zk/zookeeper-3.4.10/data目录下，新建myid文件，输入1；其他服务器上类似，myid与server.x=192.168.11.12:2888:3888的x匹配。 1echo \"1\" &gt; /home/zk/zookeeper-3.4.10/data/myid 启动集群在三台服务器上执行以下命令。 1sh zkServer.sh start 注意： 启动zookeeper常见问题有以下几点： 启动第一台zk节点时，查看日志，可以看见有异常，因为其他节点未启动，zk检查线程未找到zk集群的其他节点，所以报错。将其他节点起起来即可。 节点启动成功，但是不能正常连接，请开发zk集群涉及到的防火墙端口 启动节点报错，极有可能是zoo.cfg配置文件配置有误，请检查配置文件配置项是否正确 其他问题请自行百度（解决问题是一个程序员最基本的能力） 如果一些童鞋的服务器或虚拟机资源不足，可使用zookeeper的伪集群方式部署，思路：通过在同一台机器上，启动不同端口的zookeeper，即可构成集群，此处就不再累述了。","raw":"---\nlayout: post\ntitle: zookeeper集群搭建\ntoc: true\ndate: 2018-08-07 13:43:07\ntags: zookeeper\ncategories: 中间件\ndescription: Zookeeper集群搭建\n---\n\n本文的所有配置及集群的搭建，都是基于zookeeper-3.4.10的。<!--more-->\n\n### zoo.cfg配置详解\n\n| 参数名                                             | 说明                                                         |\n| -------------------------------------------------- | ------------------------------------------------------------ |\n| clientPort                                         | 客户端连接Server的端口，即对外服务端口，一般设置为2181       |\n| dataDir                                            | 存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir，事务日志的写性能直接影响zk性能 |\n| tickTime                                           | zk中的一个时间单元，zk中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime |\n| dataLogDir                                         | 事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升zk性能（No Java System Property） |\n| globalOutstandingLimit                             | 最大请求堆积数。默认是1000。zk运行的时候，尽管server已经没有空闲来处理更多的客户端请求了，但还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。(Java System Property:zookeeper.globalOutstandingLimit) |\n| preAllocSize                                       | 预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果zk的快照频率较大的话，建议适当减小这个参数。（Java System Property:zookeeper.preAllocSize） |\n| snapCount                                          | 每进行snapCount次事务日志输出后，出发一次快照(snapshot)，此时，zk会生成一个snapshot.*文件，同时创建一个新的事务日志文件log.\\*。默认是100000.(真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能)。(Java System Property:zookeeper.snapCount) |\n| traceFile                                          | 用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java System Property:zookeeper.requestTraceFile) |\n| maxClientCnxns                                     | 单个客户端与单台服务器之间的连接数的限制，是IP级别的，默认是60，如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台zk服务器直接的连接数限制，不是针对指定客户端IP，也不是zk集群的连接数限制，也不是单台zk对所有客户端的连接数限制。 |\n| clientPortAddress                                  | 对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听clientPort指定的端口。 |\n| minSessionTimeoutmaxSessionTimeout                 | Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2\\*tickTime~20\\*tickTime这个范文 |\n| fsync.warningthresholdms                           | 事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。( Java system property: fsync.warningthresholdms) |\n| autopurge.purgeInterval                            | 在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property) |\n| autopurge.snapRetainCount                          | 这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property) |\n| electionAlg                                        | 在之前的版本中， 这个参数配置是允许我们选择leader选举[算法](http://lib.csdn.net/base/31)，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property) |\n| initLimit                                          | Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在 **initLimit** 时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property) |\n| syncLimit                                          | 在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property) |\n| leaderServes                                       | 默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper.leaderServes) |\n| server.x=[hostname]:nnnnn[:nnnnn]                  | 这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。   (No Java system property) |\n| group.x=nnnnn[:nnnnn]weight.x=nnnnn                | 对机器分组和权重设置，可以  [参见这里](http://zookeeper.apache.org/doc/r3.4.3/zookeeperHierarchicalQuorums.html)(No Java system property) |\n| cnxTimeout                                         | Leader选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper.cnxTimeout) |\n| zookeeper.DigestAuthenticationProvider.superDigest | ZK权限设置相关，具体参见  [《  **使用super**  **身份对有权限的节点进行操作** 》 ](http://nileader.blog.51cto.com/1381108/930635) 和  [《 **ZooKeeper**   **权限控制** 》](http://nileader.blog.51cto.com/1381108/795525) |\n| skipACL                                            | 对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property: zookeeper.skipACL) |\n| forceSync                                          | 这个参数确定了是否需要在事务日志提交的时候调用 [FileChannel ](http://rdc.taobao.com/team/%5C/java%5C/jdk1.6.0_22%5C/jre%5C/lib%5C/rt.jar%3Cjava.nio.channels(FileChannel.class%E2%98%83FileChannel).force来保证数据完全同步到磁盘。(Java system property:zookeeper.forceSync) |\n| jute.maxbuffer                                     | 每个节点最[大数据](http://lib.csdn.net/base/20)量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property:jute.maxbuffer) |\n\n\n### zoo.cfg配置要求\n\n<table>\n<tr>\n<td>类型</td>\n<td>配置项</td>\n<td>描述</td>\n</tr>\n<tr>\n<td rowspan=\"3\">最低配置</td>\n<td>clientPort</td>\n<td>监听客户端连接的端口，默认值为2181</td>\n</tr>\n<tr>\n<td>dataDir</td>\n<td>存储持久数据的本地文件系统位置</td>\n</tr>\n<tr>\n<td>tickTime</td>\n<td>基本事件单元，以毫秒为单位，用来控制心跳和超时，默认情况下超时时间为两倍的tickTime</td>\n</tr>\n<tr>\n<td rowspan=\"3\">高级配置</td>\n<td>dataLogDir</td>\n<td>事件日志写入的目录</td>\n</tr>\n<tr>\n<td>maxClientCnxns</td>\n<td>限制连接到Zookeeper的客户端数量，并且限制并发连接数量，它通过ip区分不同的客户端</td>\n</tr>\n<tr>\n<td>minSessionTimeout与maxSessionTimeout</td>\n<td>最小会话超时时间和最大的会话超时时间，在默认情况下，最小的会话超时时间为两倍的tickTime时间，最大的会话超时时间为20倍的会话超时时间，系统启动时会显示相应的信息。默认为-1</td>\n</tr>\n<tr>\n<td rowspan=\"3\">集群配置</td>\n<td>initLimit</td>\n<td>参数设定了允许所有Follower与Leader进行连接并同步的时间，如果在设定的时间段内，半数以上的Follower未能完成同步，Leader便会宣布放弃领导地位，进行另一次的Leader选举。如果zk集群环境数量确实很大，同步数据的时间会很变长，因此这种情况下可以适当调大该参数。默认为10</td>\n</tr>\n<tr>\n<td>syncLimit</td>\n<td>参数设定了允许一个Follower与一个Leader进行同步的时间，如果在设定的时间段内，Follower未完成同步，它将会被集群丢弃。所有连接到这个Follower的客户端将连接到另外一个Follower</td>\n</tr>\n<tr>\n<td>server.A=B:C:D</td>\n<td>其中A是一个数字，表示这个是第几号服务器；B是这个服务器的IP地址或者主机名称；C表示的是Follower与Leader交换信息的端口，默认值为2888；D表示的是Leader选举端口，默认值为3888</td>\n</tr>\n</table>\n\n### 集群搭建\n\n#### 软件准备\n\n由于zookeeper是基于Java开发的，所以需要Java环境，需要的童鞋，请自行百度，安装Java环境\n\n~~~\nwget http://ftp.mirror.tw/pub/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\ntar -zxvf zookeeper-3.4.10.tar.gz\ncd zookeeper-3.4.10/conf\nmv zoo_sample.cfg\n~~~\n\n**注意：** zookeeper默认配置文件为zoo_sample.cfg，需要自定义配置时，需要将此配置文件修改为zoo.cfg，注意，zoo.cfg和zoo_sample.cfg文件不能同时存在\n\n#### 集群配置\n\n- zoo.cfg\n  对此配置文件的配置项不做解释，每项具体含义，上面都有详细解释，读者可自行查阅\n~~~\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/zk/zookeeper-3.4.10/data/\ndataLogDir=/home/zk/zookeeper-3.4.10/logs/\nclientPort=2181\nautopurge.snapRetainCount=500\nautopurge.purgeInterval=24\nserver.1=192.168.11.12:2888:3888\nserver.2=192.168.11.13:2888:3888\nserver.3=192.168.11.14:2888:3888\n~~~\n\n然后将配置文件同步到其他两台服务器上。\n推荐使用scp命令，如：\n\n~~~\nscp /home/zk/zookeeper-3.4.10/conf/zoo.cfg zk@192.168.11.12:/home/zk/zookeeper-3.4.10/conf\n~~~\n\n- 创建ServerID标识（敲黑板了，此处是重点）\n\n在192.168.11.12服务器的/home/zk/zookeeper-3.4.10/data目录下，新建myid文件，输入1；\n其他服务器上类似，myid与server.x=192.168.11.12:2888:3888的x匹配。\n\n~~~\necho \"1\" > /home/zk/zookeeper-3.4.10/data/myid\n~~~\n\n#### 启动集群\n\n在三台服务器上执行以下命令。\n\n~~~\nsh zkServer.sh start\n~~~\n\n**注意：** \n  启动zookeeper常见问题有以下几点：\n  - 启动第一台zk节点时，查看日志，可以看见有异常，因为其他节点未启动，zk检查线程未找到zk集群的其他节点，所以报错。将其他节点起起来即可。\n  - 节点启动成功，但是不能正常连接，请开发zk集群涉及到的防火墙端口\n  - 启动节点报错，极有可能是zoo.cfg配置文件配置有误，请检查配置文件配置项是否正确\n  - 其他问题请自行百度（解决问题是一个程序员最基本的能力）\n\n如果一些童鞋的服务器或虚拟机资源不足，可使用zookeeper的伪集群方式部署，思路：通过在同一台机器上，启动不同端口的zookeeper，即可构成集群，此处就不再累述了。\n","content":"<p>本文的所有配置及集群的搭建，都是基于zookeeper-3.4.10的。<a id=\"more\"></a></p>\n<h3 id=\"zoo-cfg配置详解\"><a href=\"#zoo-cfg配置详解\" class=\"headerlink\" title=\"zoo.cfg配置详解\"></a>zoo.cfg配置详解</h3><table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clientPort</td>\n<td>客户端连接Server的端口，即对外服务端口，一般设置为2181</td>\n</tr>\n<tr>\n<td>dataDir</td>\n<td>存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir，事务日志的写性能直接影响zk性能</td>\n</tr>\n<tr>\n<td>tickTime</td>\n<td>zk中的一个时间单元，zk中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime</td>\n</tr>\n<tr>\n<td>dataLogDir</td>\n<td>事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升zk性能（No Java System Property）</td>\n</tr>\n<tr>\n<td>globalOutstandingLimit</td>\n<td>最大请求堆积数。默认是1000。zk运行的时候，尽管server已经没有空闲来处理更多的客户端请求了，但还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。(Java System Property:zookeeper.globalOutstandingLimit)</td>\n</tr>\n<tr>\n<td>preAllocSize</td>\n<td>预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果zk的快照频率较大的话，建议适当减小这个参数。（Java System Property:zookeeper.preAllocSize）</td>\n</tr>\n<tr>\n<td>snapCount</td>\n<td>每进行snapCount次事务日志输出后，出发一次快照(snapshot)，此时，zk会生成一个snapshot.<em>文件，同时创建一个新的事务日志文件log.\\</em>。默认是100000.(真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能)。(Java System Property:zookeeper.snapCount)</td>\n</tr>\n<tr>\n<td>traceFile</td>\n<td>用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java System Property:zookeeper.requestTraceFile)</td>\n</tr>\n<tr>\n<td>maxClientCnxns</td>\n<td>单个客户端与单台服务器之间的连接数的限制，是IP级别的，默认是60，如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台zk服务器直接的连接数限制，不是针对指定客户端IP，也不是zk集群的连接数限制，也不是单台zk对所有客户端的连接数限制。</td>\n</tr>\n<tr>\n<td>clientPortAddress</td>\n<td>对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听clientPort指定的端口。</td>\n</tr>\n<tr>\n<td>minSessionTimeoutmaxSessionTimeout</td>\n<td>Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2*tickTime~20*tickTime这个范文</td>\n</tr>\n<tr>\n<td>fsync.warningthresholdms</td>\n<td>事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。( Java system property: fsync.warningthresholdms)</td>\n</tr>\n<tr>\n<td>autopurge.purgeInterval</td>\n<td>在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property)</td>\n</tr>\n<tr>\n<td>autopurge.snapRetainCount</td>\n<td>这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property)</td>\n</tr>\n<tr>\n<td>electionAlg</td>\n<td>在之前的版本中， 这个参数配置是允许我们选择leader选举<a href=\"http://lib.csdn.net/base/31\" target=\"_blank\" rel=\"noopener\">算法</a>，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property)</td>\n</tr>\n<tr>\n<td>initLimit</td>\n<td>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在 <strong>initLimit</strong> 时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property)</td>\n</tr>\n<tr>\n<td>syncLimit</td>\n<td>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property)</td>\n</tr>\n<tr>\n<td>leaderServes</td>\n<td>默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper.leaderServes)</td>\n</tr>\n<tr>\n<td>server.x=[hostname]:nnnnn[:nnnnn]</td>\n<td>这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。   (No Java system property)</td>\n</tr>\n<tr>\n<td>group.x=nnnnn[:nnnnn]weight.x=nnnnn</td>\n<td>对机器分组和权重设置，可以  <a href=\"http://zookeeper.apache.org/doc/r3.4.3/zookeeperHierarchicalQuorums.html\" target=\"_blank\" rel=\"noopener\">参见这里</a>(No Java system property)</td>\n</tr>\n<tr>\n<td>cnxTimeout</td>\n<td>Leader选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper.cnxTimeout)</td>\n</tr>\n<tr>\n<td>zookeeper.DigestAuthenticationProvider.superDigest</td>\n<td>ZK权限设置相关，具体参见  <a href=\"http://nileader.blog.51cto.com/1381108/930635\" target=\"_blank\" rel=\"noopener\">《  <strong>使用super</strong>  <strong>身份对有权限的节点进行操作</strong> 》 </a> 和  <a href=\"http://nileader.blog.51cto.com/1381108/795525\" target=\"_blank\" rel=\"noopener\">《 <strong>ZooKeeper</strong>   <strong>权限控制</strong> 》</a></td>\n</tr>\n<tr>\n<td>skipACL</td>\n<td>对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property: zookeeper.skipACL)</td>\n</tr>\n<tr>\n<td>forceSync</td>\n<td>这个参数确定了是否需要在事务日志提交的时候调用 <a href=\"http://rdc.taobao.com/team/%5C/java%5C/jdk1.6.0_22%5C/jre%5C/lib%5C/rt.jar%3Cjava.nio.channels(FileChannel.class%E2%98%83FileChannel\" target=\"_blank\" rel=\"noopener\">FileChannel </a>.force来保证数据完全同步到磁盘。(Java system property:zookeeper.forceSync)</td>\n</tr>\n<tr>\n<td>jute.maxbuffer</td>\n<td>每个节点最<a href=\"http://lib.csdn.net/base/20\" target=\"_blank\" rel=\"noopener\">大数据</a>量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property:jute.maxbuffer)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"zoo-cfg配置要求\"><a href=\"#zoo-cfg配置要求\" class=\"headerlink\" title=\"zoo.cfg配置要求\"></a>zoo.cfg配置要求</h3><table><br><tr><br><td>类型</td><br><td>配置项</td><br><td>描述</td><br></tr><br><tr><br><td rowspan=\"3\">最低配置</td><br><td>clientPort</td><br><td>监听客户端连接的端口，默认值为2181</td><br></tr><br><tr><br><td>dataDir</td><br><td>存储持久数据的本地文件系统位置</td><br></tr><br><tr><br><td>tickTime</td><br><td>基本事件单元，以毫秒为单位，用来控制心跳和超时，默认情况下超时时间为两倍的tickTime</td><br></tr><br><tr><br><td rowspan=\"3\">高级配置</td><br><td>dataLogDir</td><br><td>事件日志写入的目录</td><br></tr><br><tr><br><td>maxClientCnxns</td><br><td>限制连接到Zookeeper的客户端数量，并且限制并发连接数量，它通过ip区分不同的客户端</td><br></tr><br><tr><br><td>minSessionTimeout与maxSessionTimeout</td><br><td>最小会话超时时间和最大的会话超时时间，在默认情况下，最小的会话超时时间为两倍的tickTime时间，最大的会话超时时间为20倍的会话超时时间，系统启动时会显示相应的信息。默认为-1</td><br></tr><br><tr><br><td rowspan=\"3\">集群配置</td><br><td>initLimit</td><br><td>参数设定了允许所有Follower与Leader进行连接并同步的时间，如果在设定的时间段内，半数以上的Follower未能完成同步，Leader便会宣布放弃领导地位，进行另一次的Leader选举。如果zk集群环境数量确实很大，同步数据的时间会很变长，因此这种情况下可以适当调大该参数。默认为10</td><br></tr><br><tr><br><td>syncLimit</td><br><td>参数设定了允许一个Follower与一个Leader进行同步的时间，如果在设定的时间段内，Follower未完成同步，它将会被集群丢弃。所有连接到这个Follower的客户端将连接到另外一个Follower</td><br></tr><br><tr><br><td>server.A=B:C:D</td><br><td>其中A是一个数字，表示这个是第几号服务器；B是这个服务器的IP地址或者主机名称；C表示的是Follower与Leader交换信息的端口，默认值为2888；D表示的是Leader选举端口，默认值为3888</td><br></tr><br></table>\n\n<h3 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h3><h4 id=\"软件准备\"><a href=\"#软件准备\" class=\"headerlink\" title=\"软件准备\"></a>软件准备</h4><p>由于zookeeper是基于Java开发的，所以需要Java环境，需要的童鞋，请自行百度，安装Java环境</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:<span class=\"comment\">//ftp.mirror.tw/pub/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span></span><br><span class=\"line\">tar -zxvf zookeeper-<span class=\"number\">3.4</span>.<span class=\"number\">10</span><span class=\"selector-class\">.tar</span><span class=\"selector-class\">.gz</span></span><br><span class=\"line\">cd zookeeper-<span class=\"number\">3.4</span>.<span class=\"number\">10</span>/conf</span><br><span class=\"line\">mv zoo_sample.cfg</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> zookeeper默认配置文件为zoo_sample.cfg，需要自定义配置时，需要将此配置文件修改为zoo.cfg，注意，zoo.cfg和zoo_sample.cfg文件不能同时存在</p>\n<h4 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h4><ul>\n<li>zoo.cfg<br>对此配置文件的配置项不做解释，每项具体含义，上面都有详细解释，读者可自行查阅<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">tickTime</span>=2000</span><br><span class=\"line\"><span class=\"attribute\">initLimit</span>=10</span><br><span class=\"line\"><span class=\"attribute\">syncLimit</span>=5</span><br><span class=\"line\"><span class=\"attribute\">dataDir</span>=/home/zk/zookeeper-3.4.10/data/</span><br><span class=\"line\"><span class=\"attribute\">dataLogDir</span>=/home/zk/zookeeper-3.4.10/logs/</span><br><span class=\"line\"><span class=\"attribute\">clientPort</span>=2181</span><br><span class=\"line\">autopurge.<span class=\"attribute\">snapRetainCount</span>=500</span><br><span class=\"line\">autopurge.<span class=\"attribute\">purgeInterval</span>=24</span><br><span class=\"line\">server.<span class=\"attribute\">1</span>=192.168.11.12:2888:3888</span><br><span class=\"line\">server.<span class=\"attribute\">2</span>=192.168.11.13:2888:3888</span><br><span class=\"line\">server.<span class=\"attribute\">3</span>=192.168.11.14:2888:3888</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后将配置文件同步到其他两台服务器上。<br>推荐使用scp命令，如：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp /home/zk/zookeeper-<span class=\"number\">3.4</span>.<span class=\"number\">10</span>/conf/zoo.cfg zk<span class=\"variable\">@192</span>.<span class=\"number\">168.11</span>.<span class=\"number\">12</span><span class=\"symbol\">:/home/zk/zookeeper-</span><span class=\"number\">3.4</span>.<span class=\"number\">10</span>/conf</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建ServerID标识（敲黑板了，此处是重点）</li>\n</ul>\n<p>在192.168.11.12服务器的/home/zk/zookeeper-3.4.10/data目录下，新建myid文件，输入1；<br>其他服务器上类似，myid与server.x=192.168.11.12:2888:3888的x匹配。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">\"1\"</span> &gt; <span class=\"regexp\">/home/</span>zk<span class=\"regexp\">/zookeeper-3.4.10/</span>data<span class=\"regexp\">/myid</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h4><p>在三台服务器上执行以下命令。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sh </span>zkServer.<span class=\"keyword\">sh </span>start</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong><br>  启动zookeeper常见问题有以下几点：</p>\n<ul>\n<li>启动第一台zk节点时，查看日志，可以看见有异常，因为其他节点未启动，zk检查线程未找到zk集群的其他节点，所以报错。将其他节点起起来即可。</li>\n<li>节点启动成功，但是不能正常连接，请开发zk集群涉及到的防火墙端口</li>\n<li>启动节点报错，极有可能是zoo.cfg配置文件配置有误，请检查配置文件配置项是否正确</li>\n<li>其他问题请自行百度（解决问题是一个程序员最基本的能力）</li>\n</ul>\n<p>如果一些童鞋的服务器或虚拟机资源不足，可使用zookeeper的伪集群方式部署，思路：通过在同一台机器上，启动不同端口的zookeeper，即可构成集群，此处就不再累述了。</p>\n","slug":"zookeeper集群搭建","updated":"2018-08-07T15:35:13.000Z","comments":true,"link":"","permalink":"/2018/08/07/zookeeper集群搭建/","excerpt":"本文的所有配置及集群的搭建，都是基于zookeeper-3.4.10的。","categories":[{"name":"中间件","slug":"中间件","permalink":"/categories/中间件/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"/tags/zookeeper/"}]},{"title":"Activiti工作流(一)","date":"2018-07-28T15:43:07.000Z","path":"2018/07/28/Activiti基础总结/","text":"——————待续——————","raw":"---\nlayout: post\ntitle: Activiti工作流(一)\ntoc: true\ndate: 2018-07-28 23:43:07\ntags: 工作流\ncategories: 工作流\ndescription: Activiti工作流\n---\n\n------------------待续------------------\n","content":"<p>——————待续——————</p>\n","slug":"Activiti基础总结","updated":"2018-10-17T07:13:09.000Z","comments":true,"link":"","permalink":"/2018/07/28/Activiti基础总结/","excerpt":"","categories":[{"name":"工作流","slug":"工作流","permalink":"/categories/工作流/"}],"tags":[{"name":"工作流","slug":"工作流","permalink":"/tags/工作流/"}]},{"title":"Tomcat源码分析","date":"2018-03-21T15:43:07.000Z","path":"2018/03/21/Tomcat源码分析/","text":"Tomcat目录说明 bin 存放启动和关闭Tomcat的脚本文件 conf 存放Tomcat的各种配置文件 lib 存放Tomcat的依赖jar包 logs 存放Tomcat的日志文件 temp 存放Tomcat运行中产生的临时文件 webapps web应用所在目录，即供外界访问的web资源的存放目录 work Tomcat的工作目录 1. conf/配置文件说明1.1 catalina.propertiesTomcat的catalina.properties文件位于%CATALINA_HOME%/conf/目录下面，该文件主要配置tomcat的安全设置、类加载设置、不需要扫描的类设置、字符缓存设置四大块。 安全设置 12package.access=sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.package.definition=sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat. 类加载设置 tomcat的类加载顺序为： Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common 注: Common的配置是通过catalina.properties的commons.loader设置的 1common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot; 类加载顺序： ${catalina.base}/lib 未打包的类和资源文件 ${catalina.base}/lib/*.jar JAR文件 ${catalina.home}/lib 未打包的类和文件 ${catalina.home}/lib/*.jar JAR文件 默认情况下，会加载以下内容： annotations-api.jar — JavaEE注释类 catalina.jar — 执行Tomcat的Catalina Servlet容器部分 catalina-ant.jar — Tomcat Catalina Ant 任务 catalina-ha.jar — 高可用包 catalina-tribes.jar — 组通信包 ecj-\\.jar* — Eclipse JDT Java 编译器 el-api.jar — EL 2.2 API. jasper.jar — JSP 运行时编译器 jasper-el.jar — EL表达式的实现 jsp-api.jar — JSP 2.2 API. servlet-api.jar — Servlet 3.0 API. tomcat-api.jar — 由Tomcat定义的几个接口 tomcat-coyote.jar — Tomcat连接器和使用程序类 tomcat-dbcp.jar — 基于Apache Commons Pool和Apache Commons DBCP的数据库连接池 tomcat-i18n-**.jar — 包含其他语言的资源约束的可选JAR，默认捆绑包含在每个单独的应用中，如果不需要国际化，可以删除 tomcat-jdbc.jar — Tomcat JDBC数据库连接池 tomcat-util.jar — Tomcat的各种组件使用的常见类 tomcat7-websocket.jar — WebSocket 1.1 实现 websocket-api.jar — WebSocket 1.1 API 注： CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录，一个Tomcat可以通过配置CATALINA_BASE来增加多个工作目录，也就是增加多个实例。多个实例各自可以有自己的conf，logs，temp，webapps。 server.loader和shared.loader 在common.loader加载完毕后，tomcat启动程序会检查catalina.properties文件中配置的server.loader和shared.loader是否设置。如果设置，读取tomcat下对应的server和shared这两个目录的类库。server和shared是对应tomcat目录下的两个目录，在Tomcat中默认是没有，catalina.properties中默认也是没有设置其值。设置方法如下： 12server.loader=$&#123;catalina.base&#125;/server/classes,$&#123;catalina.base&#125;/server/lib/*.jarshared.loader=$&#123;catalina.base&#125;/shared/classes,$&#123;catalina.base&#125;/shared/lib/*.jar 同时需要在tomcat目录下创建server和shared目录结构并将公用的、应用类放到里面。类加载顺序为： Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common —&gt; Server —&gt; Shared 字符缓存设置 12345# String cache configuration.tomcat.util.buf.StringCache.byte.enabled=true#tomcat.util.buf.StringCache.char.enabled=true#tomcat.util.buf.StringCache.trainThreshold=500000#tomcat.util.buf.StringCache.cacheSize=5000 总结： Tomcat可以通过catalina.properties的server和shared，为webapp提供公用类库。使一些公用的、不需要与webapp放在一起的设置信息单独保存，在更新webapp的war的时候无需更改webapp的设置。 1.2 catalina.policy包含由Java Security Manager实现的安全策略声明，它替换了安装java时带有的java.policy文件。这个文件用来防止欺骗代码或JSP执行带有像System.exit(0)这样可能影响容器的破坏性代码，只有当Tomcat用-security命令行参数启动时这个文件才会被使用。 1.3 context.xml这个通用context.xml可被所有的web应用程序使用，这个文件默认地可以设置到何处访问各web应用程序中的web.xml文件。context.xml文件的作用和server.xml中标签作用相同。在tomcat5.5之后，对Context的配置不推荐在server.xml中进行配置，而是在/conf/context.xml中进行独立的配置。因为server.xml是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而context.xml文件则不然，tomcat服务器会定时去扫描这个文件。一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器。 默认的context.xml如下： 1234&lt;Context&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt;&lt;/Context&gt; 以下给出一个JNDI数据源的配置： 1234567891011&lt;Resource name=\"jdbc/mysql\" auth=\"Container\" type=\"com.alibaba.druid.pool.DruidDataSource\" maxActive=\"100\" maxIdle=\"30\" maxWait=\"10000\" username=\"root\" password=\"root\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/test\"/&gt; context.xml的作用范围 tomcat server级别 在/conf/context.xml里配置 Host级别 在/conf/Catalina/${hostName}里添加context.xml，继而进行配置。 web app级别 在/conf/Catalina/\\${hostName}里添加\\${webappName}.xml，继而进行配置。 1.4 server.xmltomcat的主要配置文件，解析器用这个文件在启动时根据规范创建容器。 默认的server.xml如下： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt; &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; Server是顶级元素，代表一个Tomcat实例。可以包含一个或多个Service，每个Service都有自己的Engines和Connectors。 Server元素 className 使用Java实现类的名称。这个类必须实现org.apache.catalina.Server接口。如果没有指定类名，将会使用标准实现。 address server在这个TCP/IP地址上监听一个shutdown命令。如果没有指定地址，将会使用localhost。 port server在这个端口上监听一个shutdown命令。设置为-1表示禁用shutdown命令。 shutdown 连接到指定端口的TCP/IP收到这个命令字符后，将会关闭Tomcat。 Listeners元素 Server可以包含多个监听器。一个监听器监听指定事件，并对其作出响应。 GlobalResourcesLifecycleListener作用于全局资源，保证JNDI对资源的可达性，比如数据库。 1&lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; SSLEngine 使用的SSLEngine名称。off：不适用SSL，on：使用SSL但不指定引擎。默认值是on。会初始化本地SSL引擎，对于使用SSLEnabled属性的APR/native connector来讲，该选项必须可用。 SSLRandomSeed 指定伪随机数生成器（PRNG）的随机数种子源，默认值为builtin。在开发环境下，可能要将其设置为/dev/urandom，以获得更快的启动速度。 FIPSMode 设置为on会请求OpenSSL进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会保留该模式）。该设置为enter会强制OpenSSl进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会产生一个错误）。设置为require要求OpenSSL已经处于FIPS模式（如果OpenSSL当前没有处于FIPS模式将会产生一个错误）。 GlobalNamingResources元素全局命名资源 GlobalNamingResources元素定义了JNDI（Java命名和目录接口）资源，其允许Java软件客户端通过名称搜寻和查找数据。默认配置定义了一个名称为UserDatabase的JNDI，通过“conf/tomcat-users.xml”得到一个用于用户授权的内存数据库。 1234567&lt;GlobalNamingResources&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; 也可以定义其他全句话JNDI资源来实现连接池，比如MySQL数据库。 Services元素 一个Service可以连接一个或多个Connectors到一个引擎。默认配置定义了一个名为“Catalina”的Service，连接了两个Connectors：HTTP和AJP到当前的引擎。 123456789101112131415&lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; &lt;/Engine&gt;&lt;/Service&gt; className 该实现使用的Java类名称。这个类必须实现org.apache.catalina.Service接口。如果没有指定类名称，将会使用标准实现。 name Service的显示名称，如果采用了标准的Catalina组件，将会包含日志信息。每个Service与某个特定的Server关联的名称必须是唯一的。 Connectors元素 一个Connector关联一个TCP端口，负责处理Service与客户端之间的交互。默认配置定义了两个Connectors。 HTTP/1.1 处理HTTP请求，使得Tomcat成为一个HTTP服务器。客户端可以通过Connector向服务器发送HTTP请求，接收服务器端的HTTP响应信息。 1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 与生产服务默认使用80端口不同，Tomcat HTTP服务默认在TCP端口8080上运行。可以选择1024到65535之间的任意数字作为端口号来运行Tomcat服务器，前提是该端口没有被任何其他应用使用。connectionTimeOut属性定义了这个connector在链接获得同意之后，获得请求URI line（请求信息）响应的最大等待时间毫秒数。默认为20秒。redirect属性会把SSL请求重定向到TCP的8443端口。 AJP/1.3 Apache JServ Protocol connector处理Tomcat服务器与Apache HTTP服务器之间的交互。 1&lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; 可以将Tomcat和Apache HTTP服务运行在一起，Apache HTTP服务器处理静态请求和PHP；Tomcat服务器负责处理Java Servlet/JSP。 容器 包含了Engine、Host、Context和Cluster的Tomcat称为容器。最高级的是Engine，最底层的是Context。某些组件，比如Realm和Value，也可以放在容器中。 Engine引擎 引擎是容器中最高级别的部分。可以包含一个或多个Host。Tomcat服务器可以配置为运行在多个主机名上，包括虚拟主机。 1&lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; Catalina引擎从HTTP connector接收HTTP请求，并根据请求头部信息中主机名或IP地址重定向到正确的主机上。 backgroundProcessorDelay 这个值表示了在这个引擎和它的子容器上调用backgroundProcess方法之间间隔的秒数，包括所有host和context。值为非负时不会调用子容器（意味着其使用自身的处理线程）。设置为正值会产生一个衍生线程。等待指定的时间之后，该线程会在这个引擎和它的所有子容器上调用backgroundProcess方法。如果没有指定，默认值为10，即会有10秒的延迟。 className 实现该引擎使用的Java类名。该类必须实现org.apache.catalina.Engine接口。如果没有指定，会使用标准值。 defaultHost 默认主机名，定义了处理指向该服务器的请求所在主机的名称，但名称不是在这个文件中配置。 jvmRoute 在负载均衡场景下必须定义该参数，来保证session affinity可用，对于集群中所有Tomcat服务器来讲定义的名称必须是唯一的，该名称将会被添加到生成的会话标示符中，因此，允许前端代理总是将特定会话转发到同一个Tomcat实例。 name Engine的逻辑名称，用在日志和错误信息中。当在相同的Server中使用多个Service元素时，每个Engine必须制定一个唯一的名称。 startStopThreads Engine在启动Host子元素时将会并发使用的线程数。如果设置为0，将会使用Runtime.getRuntime().availableProcessors()的值。设置为负数，将会使用Runtime.getRuntime().availableProcessors() + value的值，如果结果小于1，将会使用1个线程。如果没有指定，默认值为1。 Realm元素 一个Realm（域）就是一个包含user、password和role认证（比如访问控制）的数据库。你可以在任何容器中定义Realm，例如Engine、Host、Context和Cluster。 123&lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/&gt;&lt;/Realm&gt; 默认配置定义了一个Catalina Engine的Realm（UserDatabaseRealm），对用户访问engine的权限进行控制。其使用定义在GlobalNamingResources中，名字为UserDatabase的JNDI。 除了UserDatabaseRealm以外，还有：JDBCRealm（授权用户是否可以通过JDBC驱动连接到关系型数据库）；DataSourceRealm（通过JNDI连接到数据库）；JNDIRealm（连接到一个LDAP目录）；MemoryRealm（将XML文件加载到内存）。 className 使用Java实现类的名称。这个类必须实现org.apache.catalina.Realm接口。 Hosts 一个Host定义了在Engine下的一个虚拟机，反过来其又支持多个Context（web应用）。 1&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 默认配置定义了一个名为localhost的主机。appBase属性定义了所有webapp的根目录，在这种情况下是webapps。默认情况下，每一个webapp的URL和它所在的目录名称相同。例如，默认的Tomcat安装目录的webapps下提供了四个web应用：docs、examples、host-manager和manager。只有ROOT是个例外，它用一个空字符串定义。也就是说，它的URL是http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。 appBase 虚拟机应用的根目录。该目录是一个可能包含部署到虚拟机上web应用的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用webapps。 xmlBase 虚拟机XML根目录。该目录是一个可能包含部署到虚拟机上context XML描述符的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用conf/目录。 createDirs 如果设置为true，Tomcat将会在启动阶段，尝试创建一个由appBase和xmlBase属性定义的目录。默认值为true。如果设置为true，并且目录创建失败，将会打印出一个错误信息，但是不会终止启动过程。 autoDeploy 该属性的值指明了在Tomcat运行的时候，是否需要定义检查新的或者更新后的web应用。如果为true，Tomcat会定义检查appBase和xmlBase目录，并对找到的新web应用和context XML描述符进行部署。更新web应用或XML上下文描述符将会触发web应用的重载。默认值为true。 backgroundProcessorDeploy 表示在调用这台主机的backgroundProcess方法和它的子容器方法，包括所有的context，之间延迟的秒数。如果延迟值不是负数的话，不会调用子容器（意味着会使用它们自己的处理线程）。设置为正数会产生衍生线程。在等待指定的时间之后，线程将会在该host上调用backgroundProcess方法，包括它的所有子容器。host将会使用后台进程执行web应用部署相关的任务。如果没有指定，默认值为-1，意味着host将会依赖于它的父引擎的后台处理线程。 className 使用的Java实现类的名称。该类必须实现org.apache.catalina.Host接口。 deployIgnore 一个正则表达式，定义了在自动部署和启动时部署的情况下需要忽略的目录。这就允许我们在版本控制系统中保持自己的配置，例如，不会将.svn或者git文件夹部署到appBase目录下。该正则表达式是相对于appBase的。同时也是固定的，意味着是相对于整个文件或目录的名称进行的。因此，foo只会匹配名称为foo的文件或目录，而不会匹配foo.war等名称的文件或目录。如果想让“foo”匹配任意名称，可以使用“.*foo.*”。 deployOnStartup 指定在Tomcat启动时是否需要自动部署host下的web应用。默认值为true。 failCtxlfServletStartFails 设置为true时，如果它的任意一个load-on-startup &gt;= 0的servlet停止自身启动后，停止启动它的每一个子context。每一个子context可能覆盖这个属性。如果没有指定，将会使用默认值false。 name 通常是虚拟主机的网络名称，注册在你的域名服务器上。无论指定的主机名称是什么样的，Tomcat在内部都会将其转换为小写。嵌套在Engine内部的Host，其中必须有一个Host的名称匹配Engine的默认Host设置。 startStopThreads Host在启动子Context元素时会并发使用的线程数。如果自动部署被使用的话将会使用该线程池部署新的Context。值为0时将会使用Runtime.getRuntime().availableProcessors()的值。值为负数时将会使用Runtime.getRuntime().availableProcessors()加上该值得和，小于1时将会使用1个线程。如果没有指定，会使用默认值1。 undeployOldVersion 该选项的值决定Tomcat，即自动部署进程部分，是否会检查并发部署的过时web应用，任何找到的应用都会被移除。只有在autoDeploy为true的情况下才会生效。如果没有指定将会使用默认值false。 Value Value（阀门）作为请求的前置处理程序，可以在请求发送到应用之前拦截HTTP请求。可以定义在任何容器中，比如Engine、Host、Context和Cluster。默认配置中，AccessLogValue会拦截HTTP请求，并在日志文件中创建一个切入点 123&lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; className 设置为org.apache.catalina.ha.tcp.ReplicationValue filter 对于已知文件扩展名或url，可以在请求中使用Value通知cluster没有修改session，对于本次变化cluster没有必要通知session管理者。如果请求匹配该过滤器模型，cluster会假设session没有发生变化。一个filter样例大概是这样的filter=“.*.gif|.*.js|.*.jpeg|.*.jpg|.*.png|.*.htm|.*.html|.*.css|.*.txt”。filter使用java.util.regex的正则表达式。 primaryIndicator 布尔值，如果为true，replication value将会把primaryIndicatorName属性定义的名称插入到request属性中，该值无论是Boolean.TRUE或者Boolean.FALSE，都会被放入request属性中。 primaryIndicatorName 默认值为org.apache.catalina.ha.tcp.isPrimarySession，这个值定义了一个request属性的名称，值是一个布尔值，表示会话所在的服务器是否为主服务器。 statistics 布尔值，如果想让value手机请求的统计数据，设置为true，默认值为false。 RemoteAddrValue 阻截来自特定IP地址的请求。 RemoteHostValue 阻截基于主机名称的请求。 RequestDumperValue 记录了请求的详细信息。 SingleSignOnValue 当置于a下时，允许单点登录到该主机下的所有应用上。 ​ 1.5 tomcat-users.xml用于访问tomcat管理应用程序时的安全性设置，用server.xml中引用的默认的用户数据库域（UserDatabase Realm）使用它，所有的凭证默认都是被注释的，如需授权和访问控制，或配置角色，可参考以下配置。 12345&lt;role rolename=\"manager\"/&gt;&lt;role rolename=\"manager-gui\"/&gt;&lt;role rolename=\"admin\"/&gt;&lt;role rolename=\"admin-gui\"/&gt;&lt;user username=\"admin\" password=\"admin\" roles=\"admin-gui,admin,manager-gui,manager\"/&gt; 这样tomcat7首页上的Server Status、Manager App、Host Manager就都可以点击登录进去。 tomcat6配置： 123&lt;role rolename=\"admin\"/&gt;&lt;role rolename=\"manager\"/&gt;&lt;user username=\"admin\" password=\"admin\" roles=\"admin,manager\"/&gt; 1.6 web.xml默认的web.xml文件可被所有的web应用程序使用，这个web.xml文件会设置jspservlet以支持应用程序处理jsps，并设置一个默认的servlet来处理静态资源和html文件，它还设置默认的回话超时以及像index.jsp，index.html这类欢迎文件，并且它为最通用的扩展文件设置默认的MIME类型。 一般在Java工程中，web.xml用来初始化工程配置信息，比如welcome页面，filter，listener，servlet，servlet-mapping，启动加载级别等等。 当应用程序被部署到tomcat时，它会用[engine name]/[host name]/[context-path name].xml创建与context.xml等效的文件，如用户也在\\$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml.default文件，在这个文件中特定主机下的所有web应用程序将对主机器虚拟环境采用一系列默认设置。 下面就详细介绍一下web.xml中常用的标签及其功能。 \\&lt;description>，\\&lt;display-name>，\\&lt;icon> \\&lt;description> 1&lt;description&gt;项目描述&lt;/description&gt; &lt;!--对项目作出描述--&gt; \\&lt;display-name> 1&lt;display-name&gt;项目名称&lt;/display-name&gt; &lt;!--定义项目的名称--&gt; \\&lt;icon>及\\&lt;small-icon>，\\&lt;large-icon> \\&lt;icon> icon元素包含small-icon和large-icon两个子元素，用来指定web站台中小图标和大图标的路径。 1234&lt;!--small-icon元素应指向web站台中某个小图标的路径，大小为16X 16 pixel，但是图像文件必须为GIF或JPEG格式，扩展名必须为.git或.jpg--&gt;&lt;small-icon&gt;/路径/smallicon.gif&lt;/small-icon&gt;&lt;!--large-icon元素应指向web站台中某个大图标路径，大小为32X 32pixel，但是图像文件必须为GIF或JPEG的格式，扩展名必须为.git或.jpg--&gt;&lt;large-icon&gt;/路径/largeicon.jpg&lt;/large-icon&gt; 例如： 123456&lt;display-name&gt;Demo Example&lt;/display-name&gt;&lt;description&gt;JSP 2.0 Demo Example&lt;/description&gt;&lt;icon&gt; &lt;small-icon&gt;/images/small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/large.gif&lt;/large-icon&gt;&lt;/icon&gt; \\&lt;context-param> \\&lt;context-param>元素含有一对参数名和参数值，用作应用的servlet上下文初始化参数。参数名在整个web应用中必须是唯一的。 例如： 1234&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;haha&lt;/param-value&gt;&lt;/context-param&gt; 此处设定的参数，在JSP页面可以使用\\${initParam.name}来获取。 在Servlet中可以使用下列方式获取： 1String name = getServletContext().getInitParamter(\"name\"); \\&lt;filter> filter元素用于指定web容器中的过滤器。 在请求和响应对象被servlet处理之前或之后，可以使用过滤器对这两个对象进行操作。通过filter-mapping元素，过滤器被映射到一个servlet或一个URL模式。这个过滤器的filter元素和filter-mapping元素必须具有相同的名称。 filter元素用来声明filter的相关设定，filter元素除了下面介绍的子元素之外，还包括&lt;icon>，\\&lt;display-name>，\\&lt;description>，\\&lt;init-param>，其用途一样。 例如： 12345678&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; \\&lt;filter-mapping> filter-mapping元素用来声明web应用中的过滤器映射。过滤器可被映射到一个servlet或一个URL模式。将过滤器映射到一个servlet中会造成过滤器作用于servlet上。将过滤器映射到一个URL模式中则可以将过滤器应用于任何资源，只要该资源的URL与URL模式匹配。过滤是按照部署描述符的filter-mapping元素出现的顺序执行的。 filter-mapping元素的两个主要子元素filter-name和url-pattern用来定义Filter对应的URL。还有servlet-name和dispatcher子元素，不是很常用。 特别说明一下dispatcher，设置Filter对应的请求方式，有：REQUEST,INCLUDE,FORWAR,ERROR四种，默认为REQUEST。 例如： 1234&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; \\&lt;servlet> 在web.xml中完成一个最常见的任务是对servlet或JSP页面给出名称和定制的URL。用servlet元素分配名称，使用servlet-mapping元素将定制的URL与刚分配的名称相关联。 例如： 1234&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt; \\&lt;servlet-mapping> servlet-mapping元素包含两个子元素servlet-name和url-pattern，用来定义servlet所对应的URL。 例如： 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; \\&lt;listener> listener元素用来注册一个监听器类，可以在web应用中包含该类。使用listener元素，可以收到事件什么时候发生以及用什么作为响应的通知。 listener元素用来定义Listener接口，它的主要子元素为\\&lt;listener-class> 例如： 123&lt;listener&gt; &lt;listener-class&gt;com.gnd.web.listener.TestListener&lt;/listener-class&gt;&lt;/listener&gt; \\&lt;session-config> session-config包含一个子元素session-timeout，定义web应用中session的有效期限。 例如： 123&lt;session-config&gt; &lt;session-timeout&gt;900&lt;/session-timeout&gt;&lt;/session-config&gt; \\&lt;mime-mapping> mime-mapping包含两个子元素extension和mime-type，定义某个扩展名和某一MIME Type做对应。 \\&lt;extension>扩展名名称\\&lt;/extension> \\&lt;mime-type>MIME格式\\&lt;/mime-type> 例如： 123456789101112&lt;mime-mapping&gt; &lt;extension&gt;doc&lt;/extension&gt; &lt;mime-type&gt;application/vnd.ms-word&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;xls&lt;/extension&gt; &lt;mime-type&gt;application/vnd.ms-excel&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;ppt&lt;/extension&gt; &lt;mime-type&gt;application/vnd.ms-powerpoint&lt;/mime-type&gt;&lt;/mime-mapping&gt; \\&lt;welcome-file-list> welcome-file-list包含一个子元素welcome-file，用来定义首页列表。 welcome-file用来指定首页文件名称，服务器会按照设定的顺序来找首页。 例如： 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; \\&lt;error-page> error-page元素包含三个子元素error-code，exception-type和location。 将错误代码后异常的种类对应到web应用资源路径。 例如： 12345678&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;error404.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;error404.jsp&lt;/location&gt;&lt;/error-page&gt; \\&lt;jsp-config> jsp-config元素主要用来设定jsp的相关配置，jsp-config包括taglib和jsp-property-group两个子元素，其中taglib元素在JSP1.2时就已经存在，而jsp-property-group是JSP2.0新增的元素。 \\&lt;taglib> taglib元素包含两个子元素taglib-uri和taglib-location，用来设定JSP网页用到的TagLibrary路径。 \\&lt;taglib-uri>URI\\&lt;/taglib-uri> taglib-uri定义TLD文件的URI，JSP网页的taglib指令可以经由这个URI存取到TLD文件。 \\&lt;taglib-location>/WEB-INF/lib/xxx.tld\\&lt;/taglib-location> TLD文件对应web应用的存放位置。 \\&lt;jsp-property-group> jsp-property-group元素包含8个子元素，分别为： \\&lt;description>Description\\&lt;/description> 此设定的说明 \\&lt;display-name>Name\\&lt;/display-name> 此设定的名称 \\&lt;url-pattern>URL\\&lt;/url-pattern> 设定值所影响的范围，如*.jsp \\true/false\\&lt;/el-ignored> 是否支持EL语法 \\&lt;scripting-invalid>true/false\\&lt;/scripting-invalid> 是否支持java代码片段&lt;%…%&gt; \\&lt;page-encoding>UTF-8\\&lt;/page-encoding> 设置JSP页面的编码 \\&lt;include-prelude>.jspf\\&lt;/include-prelude> 设置JSP页面的抬头，扩展名为.jspf \\.jspf\\ 设置JSP页面的结尾，扩展名为.jspf 例如： 1234567891011121314&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;Taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/MyTaglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Configuration JSP example&lt;/description&gt; &lt;display-name&gt;JspConfig&lt;/display-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; \\&lt;resource-ref> resource-ref元素包含五个子元素description，res-ref-name，res-type，res-auth，res-sharing-scope，利用JNDI取得应用可利用资源。 \\&lt;res-auth>Application/Container\\&lt;/res-auth> 资源由Application或Container来许可。 \\Shareable|Unshareable\\ 资源是否可以共享，默认值为Shareable 例如： 12345&lt;resource-ref&gt; &lt;res-ref-name&gt;jdbc/Druid&lt;/res-ref-name&gt; &lt;res-type&gt;com.alibaba.druid.pool.DruidDataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 1.7 loggin.propertiesJULI记录器使用默认日志配置，它默认地使用ConsoleHandler和fileHandler设置应用程序或者程序包的日志级别。 2. 启动流程分析2.1 Idea调试Tomcat源码环境搭建首先下载Tomcat源码，读者可自行去Tomcat官网 下载，若执行力差的同学也可直接从此处pull。 Tomcat源码导入到开发工具中的方法有多种，笔者采用最直接的方式，解压源码包后直接导入到开发工具中，导入之后的源码并不能直接运行，还需要几个依赖包，读者可从此处的lib目录下获取，也可自行搜集。 找好依赖包也并不能让Tomcat源码正常运行，还需要为Bootstrap这个启动类增加几个启动参数。 123456-Dcatalina.home=/Users/chenmin/GitHub/tomcat-Dcatalina.base=/Users/chenmin/GitHub/tomcat-Djava.endorsed.dirs=/Users/chenmin/GitHub/tomcat/endorsed-Djava.io.tmpdir=/Users/chenmin/GitHub/tomcat/temp-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=/Users/chenmin/GitHub/tomcat/conf/logging.properties 上面的参数具体代表的意思就不一一详述了，其实光看名字就知道都是干嘛用的了。 以上准备步骤做好之后，就可以直接运行Bootstrap类，运行Tomcat源码进行调试了。 2.2 Tomcat Server的组成2.2.1 整体说明在上面对配置文件的说明中，通过server.xml的解释，我们知道server.xml中最顶级的元素是server，而server.xml中的每一个元素我们都可以把它看做是Tomcat中的某一个部分。所以我们可以参照着server.xml来分析源码。 Tomcat最顶层的容器叫Server，它代表着整个Tomcat服务器。Server中至少要包含一个Service来提供服务。Service包含两部分：Connector和Container。Connector负责网络连接，request/response的创建，并对Socket和request、response进行转换等，Container用于封装和管理Servlet，并处理具体的request请求。 一个Tomcat中只有一个Server，一个Server可以有多个Service来提供服务，一个Service只有一个Container，但是可以有多个Connector（一个服务可以有多个连接）。 2.2.2 各组件详解可结合conf/配置文件说明中的server.xml的说明来看 Server Server代表整个Servlet容器 Service Service是由一个或多个Connector以及一个Engine，负责处理所有Connector所获得的客户请求的集合。 Connector Connector将在某个指定端口上侦听客户请求，并将获得的请求交给Engine来处理，从Engine处获得回应并返回给客户端。 Tomcat有两个默认的Connector，一个直接监听来自浏览器的http请求，一个监听来自其他WebServer的请求。 Coyote Http/1.1 Connector在端口8080上监听来自浏览器的http请求 Coyote AJP/1.3 Connector在端口8009上监听来自其他WebServer的servlet/jsp代理请求。 Engine Engine下可以配置多个虚拟主机，每个虚拟主机都有一个域名，当Engine获得一个请求时，Engine会把该请求匹配到某个Host上，然后把该请求交给该Host来处理。 Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。 Host 代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配。每个虚拟主机下都可以部署一个或者多个WebApp，每个WebApp对应于一个Context，有一个ContextPath。当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。匹配的方法是“最长匹配”，所以一个path==“”的Context将成为该Host的默认Context，所有无法和其他Context的路径名匹配的请求都将最终和该默认Context匹配。 Context 一个Context对应于一个Web Application（Web应用），一个Web应用有一个或多个Servlet组成，Context在创建的时候将根据配置文件\\$CATALINA_HOME/conf/web.xml和\\$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。如果找到，则执行该类，获得请求的回应，并返回。 Tomcat各组件关系图(此图来此网上) 2.3 源码分析2.3.1 启动总体流程Tomcat里的Server由org.apache.catalina.startup.Catalina来管理，Catalina是整个Tomcat的管理类，它里面的三个方法load，start，stop分别用来管理整个服务器的生命周期，load方法用于根据conf/server.xml文件创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器，start和stop方法在内部分别调用了Server的start和stop方法，load方法内部调用了Server的init方法，这三个方法都会按容器的结构逐层调用相应的方法，比如，Server的start方法中会调用所有的Service中的start方法，Service中的start方法又会调用所有的Service中的start方法，Service中的start方法又会调用所有包含的Connectors和Container的start方法，这样这个服务器就启动了，init和stop方法也一样，这就是整个Tomcat的生命周期的管理方式。Catalina还有个await方法，await方法直接调用了Server的await方法，这个方法的作用是进入一个循环，让主线程不退出。 Tomcat的启动入口上面说过，是org.apache.catalina.startup.Bootstrap，作用类似于一个CatalinaAdaptor，具体的处理过程还是使用Catalina来完成的，这么做的好处是可以把启动的入口和具体的管理类分开，从而可以很方便的创建出多种启动方式，每种启动方式只需要写一个相应的CatalinaAdaptor就可以了。 注：图片比较模糊，如需查看清晰图片，请自行下载resources/images目录中的tomcat启动流程分析.png 或 resources/docs中的Tomcat源码分析.mdl ，使用Rational Rose等工具打开即可。 2.3.2 启动流程详解正常情况下启动Tomcat，就是调用Bootstrap的main方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String args[]) &#123; if (daemon == null) &#123; // Don't set daemon until init() has completed // 初始化了ClassLoader，并用ClassLoader创建了Catalina实例，赋给catalinaDaemon变量 Bootstrap bootstrap = new Bootstrap(); try &#123; bootstrap.init(); &#125; catch (Throwable t) &#123; handleThrowable(t); t.printStackTrace(); return; &#125; daemon = bootstrap; &#125; else &#123; // When running as a service the call to stop will be on a new // thread so make sure the correct class loader is used to prevent // a range of class not found exceptions. Thread.currentThread().setContextClassLoader(daemon.catalinaLoader); &#125; try &#123; String command = \"start\"; if (args.length &gt; 0) &#123; command = args[args.length - 1]; &#125; if (command.equals(\"startd\")) &#123; args[args.length - 1] = \"start\"; daemon.load(args); daemon.start(); &#125; else if (command.equals(\"stopd\")) &#123; args[args.length - 1] = \"stop\"; daemon.stop(); &#125; else if (command.equals(\"start\")) &#123; daemon.setAwait(true); daemon.load(args); daemon.start(); &#125; else if (command.equals(\"stop\")) &#123; daemon.stopServer(args); &#125; else if (command.equals(\"configtest\")) &#123; daemon.load(args); if (null==daemon.getServer()) &#123; System.exit(1); &#125; System.exit(0); &#125; else &#123; log.warn(\"Bootstrap: command \\\"\" + command + \"\\\" does not exist.\"); &#125; &#125; catch (Throwable t) &#123; // Unwrap the Exception for clearer error reporting if (t instanceof InvocationTargetException &amp;&amp; t.getCause() != null) &#123; t = t.getCause(); &#125; handleThrowable(t); t.printStackTrace(); System.exit(1); &#125; &#125; main方法中，首先执行init方法初始化了Tomcat自己的类加载器，并通过类加载器创建Catalina实例，然后赋给catalinaDaemon变量，后续操作都使用catalinaDaemon来执行。 后面默认执行start命令，将调用setAwait(true)，load(args)和start()这三个方法，这三个方法内部都通过反射调用了Catalina的相应方法。 1234// org.apache.catalina.startup.Catalinapublic void setAwait(boolean b) &#123; await = b;&#125; setAwait方法用于设置Server启动完成后是否进入等待状态的标志，如果为true则进入，否则不进入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// org.apache.catalina.startup.Catalina/** * Start a new server instance. */public void load() &#123; long t1 = System.nanoTime(); initDirs(); // Before digester - it may be needed initNaming(); // Create and execute our Digester Digester digester = createStartDigester(); InputSource inputSource = null; InputStream inputStream = null; File file = null; try &#123; try &#123; file = configFile(); inputStream = new FileInputStream(file); inputSource = new InputSource(file.toURI().toURL().toString()); &#125; catch (Exception e) &#123; if (log.isDebugEnabled()) &#123; log.debug(sm.getString(\"catalina.configFail\", file), e); &#125; &#125; if (inputStream == null) &#123; try &#123; inputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile()); inputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString()); &#125; catch (Exception e) &#123; if (log.isDebugEnabled()) &#123; log.debug(sm.getString(\"catalina.configFail\",getConfigFile()), e); &#125; &#125; &#125; // This should be included in catalina.jar // Alternative: don't bother with xml, just create it manually. if (inputStream == null) &#123; try &#123; inputStream = getClass().getClassLoader().getResourceAsStream(\"server-embed.xml\"); inputSource = new InputSource(getClass().getClassLoader().getResource(\"server-embed.xml\").toString()); &#125; catch (Exception e) &#123; if (log.isDebugEnabled()) &#123; log.debug(sm.getString(\"catalina.configFail\",\"server-embed.xml\"), e); &#125; &#125; &#125; if (inputStream == null || inputSource == null) &#123; if (file == null) &#123; log.warn(sm.getString(\"catalina.configFail\",getConfigFile() + \"] or [server-embed.xml]\")); &#125; else &#123; log.warn(sm.getString(\"catalina.configFail\",file.getAbsolutePath())); if (file.exists() &amp;&amp; !file.canRead()) &#123; log.warn(\"Permissions incorrect, read permission is not allowed on the file.\"); &#125; &#125; return; &#125; try &#123; inputSource.setByteStream(inputStream); digester.push(this); digester.parse(inputSource); &#125; catch (SAXParseException spe) &#123; log.warn(\"Catalina.start using \" + getConfigFile() + \": \" + spe.getMessage()); return; &#125; catch (Exception e) &#123; log.warn(\"Catalina.start using \" + getConfigFile() + \": \" , e); return; &#125; &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; &#125; getServer().setCatalina(this); getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile()); getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile()); // Stream redirection initStreams(); // Start the new server try &#123; getServer().init(); &#125; catch (LifecycleException e) &#123; if (Boolean.getBoolean(\"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\")) &#123; throw new java.lang.Error(e); &#125; else &#123; log.error(\"Catalina.start\", e); &#125; &#125; long t2 = System.nanoTime(); if(log.isInfoEnabled()) &#123; log.info(\"Initialization processed in \" + ((t2 - t1) / 1000000) + \" ms\"); &#125;&#125; Catalina的load方法根据conf/server.xml创建了Server对象，并赋值给server属性（具体是通过开源项目Digester完成的），然后调用了server的init方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// org.apache.catalina.startup.Catalinapublic void start() &#123; if (getServer() == null) &#123; load(); &#125; if (getServer() == null) &#123; log.fatal(\"Cannot start server. Server instance is not configured.\"); return; &#125; long t1 = System.nanoTime(); // Start the new server try &#123; getServer().start(); &#125; catch (LifecycleException e) &#123; log.fatal(sm.getString(\"catalina.serverStartFail\"), e); try &#123; getServer().destroy(); &#125; catch (LifecycleException e1) &#123; log.debug(\"destroy() failed for failed Server \", e1); &#125; return; &#125; long t2 = System.nanoTime(); if(log.isInfoEnabled()) &#123; log.info(\"Server startup in \" + ((t2 - t1) / 1000000) + \" ms\"); &#125; // Register shutdown hook if (useShutdownHook) &#123; if (shutdownHook == null) &#123; shutdownHook = new CatalinaShutdownHook(); &#125; Runtime.getRuntime().addShutdownHook(shutdownHook); // If JULI is being used, disable JULI's shutdown hook since // shutdown hooks run in parallel and log messages may be lost // if JULI's hook completes before the CatalinaShutdownHook() LogManager logManager = LogManager.getLogManager(); if (logManager instanceof ClassLoaderLogManager) &#123; ((ClassLoaderLogManager) logManager).setUseShutdownHook(false); &#125; &#125; if (await) &#123; await(); stop(); &#125;&#125; 这里首先判断Server是否已经存在了，如果不存在则调用load方法来初始化Server，然后调用Server的start方法来启动服务器，最后注册了关闭钩子并根据await属性判断是否进入等待状态，之前我们已经将这里的await属性设置为true，所以需要进入等待状态。进入等待状态会调用await和stop两个方法，await方法会直接调用Server的await方法，Server的await方法内部会执行一个while循环，这样程序就停到了await方法，当await方法里的while循环退出时，就会执行stop方法，从而关闭服务器。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// org.apache.catalina.core.StandardServer@Overridepublic void await() &#123; // Negative values - don't wait on port - tomcat is embedded or we just don't like ports if( port == -2 ) &#123; // undocumented yet - for embedding apps that are around, alive. return; &#125; if( port==-1 ) &#123; try &#123; awaitThread = Thread.currentThread(); while(!stopAwait) &#123; try &#123; Thread.sleep( 10000 ); &#125; catch( InterruptedException ex ) &#123; // continue and check the flag &#125; &#125; &#125; finally &#123; awaitThread = null; &#125; return; &#125; // Set up a server socket to wait on try &#123; awaitSocket = new ServerSocket(port, 1,InetAddress.getByName(address)); &#125; catch (IOException e) &#123; log.error(\"StandardServer.await: create[\" + address+ \":\" + port+ \"]: \", e); return; &#125; try &#123; awaitThread = Thread.currentThread(); // Loop waiting for a connection and a valid command while (!stopAwait) &#123; ServerSocket serverSocket = awaitSocket; if (serverSocket == null) &#123; break; &#125; // Wait for the next connection Socket socket = null; StringBuilder command = new StringBuilder(); try &#123; InputStream stream; long acceptStartTime = System.currentTimeMillis(); try &#123; socket = serverSocket.accept(); socket.setSoTimeout(10 * 1000); // Ten seconds stream = socket.getInputStream(); &#125; catch (SocketTimeoutException ste) &#123; // This should never happen but bug 56684 suggests that // it does. log.warn(sm.getString(\"standardServer.accept.timeout\", Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste); continue; &#125; catch (AccessControlException ace) &#123; log.warn(\"StandardServer.accept security exception: \" + ace.getMessage(), ace); continue; &#125; catch (IOException e) &#123; if (stopAwait) &#123; // Wait was aborted with socket.close() break; &#125; log.error(\"StandardServer.await: accept: \", e); break; &#125; // Read a set of characters from the socket int expected = 1024; // Cut off to avoid DoS attack while (expected &lt; shutdown.length()) &#123; if (random == null) random = new Random(); expected += (random.nextInt() % 1024); &#125; while (expected &gt; 0) &#123; int ch = -1; try &#123; ch = stream.read(); &#125; catch (IOException e) &#123; log.warn(\"StandardServer.await: read: \", e); ch = -1; &#125; // Control character or EOF (-1) terminates loop if (ch &lt; 32 || ch == 127) &#123; break; &#125; command.append((char) ch); expected--; &#125; &#125; finally &#123; // Close the socket now that we are done with it try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; // Ignore &#125; &#125; // Match against our command string boolean match = command.toString().equals(shutdown); if (match) &#123; log.info(sm.getString(\"standardServer.shutdownViaPort\")); break; &#125; else log.warn(\"StandardServer.await: Invalid command '\" + command.toString() + \"' received\"); &#125; &#125; finally &#123; ServerSocket serverSocket = awaitSocket; awaitThread = null; awaitSocket = null; // Close the server socket and return if (serverSocket != null) &#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; &#125;&#125; #### 参考书籍 看透springMvc源代码分析与实践.pdf 推荐博客 解析XML之Digester","raw":"---\nlayout: post\ntitle: Tomcat源码分析\ntoc: true\ndate: 2018-03-21 23:43:07\ntags: Tomcat\ncategories: 中间件\ndescription: Tomcat源码分析\n---\n\n## Tomcat目录说明<!--more-->\n\n- bin\n\n  存放启动和关闭Tomcat的脚本文件\n\n- conf\n\n  存放Tomcat的各种配置文件\n\n- lib\n\n  存放Tomcat的依赖jar包\n\n- logs\n\n  存放Tomcat的日志文件\n\n- temp\n\n  存放Tomcat运行中产生的临时文件\n\n- webapps\n\n  web应用所在目录，即供外界访问的web资源的存放目录\n\n- work\n\n  Tomcat的工作目录\n\n## 1. conf/配置文件说明\n\n### 1.1 catalina.properties\n\nTomcat的catalina.properties文件位于%CATALINA_HOME%/conf/目录下面，该文件主要配置tomcat的安全设置、类加载设置、不需要扫描的类设置、字符缓存设置四大块。\n\n- 安全设置\n\n  ```properties\n  package.access=sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.\n  package.definition=sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.\n  ```\n\n- 类加载设置\n\n  >  tomcat的类加载顺序为：\n\n  Bootstrap ---> System ---> /WEB-INF/classes ---> /WEB-INF/lib/*.jar ---> Common\n\n  注: Common的配置是通过catalina.properties的commons.loader设置的\n\n  ```properties\n  common.loader=\"${catalina.base}/lib\",\"${catalina.base}/lib/*.jar\",\"${catalina.home}/lib\",\"${catalina.home}/lib/*.jar\"\n  ```\n\n  >  类加载顺序：\n\n  ${catalina.base}/lib  未打包的类和资源文件\n\n  ${catalina.base}/lib/*.jar  JAR文件\n\n  ${catalina.home}/lib  未打包的类和文件\n\n  ${catalina.home}/lib/*.jar  JAR文件\n\n  >  默认情况下，会加载以下内容：\n\n  - *annotations-api.jar* — JavaEE注释类\n  - *catalina.jar* — 执行Tomcat的Catalina Servlet容器部分\n  - *catalina-ant.jar* — Tomcat Catalina Ant 任务\n  - *catalina-ha.jar* — 高可用包\n  - *catalina-tribes.jar* — 组通信包\n  - *ecj-\\*.jar* — Eclipse JDT Java 编译器\n  - *el-api.jar* — EL 2.2 API.\n  - *jasper.jar* — JSP 运行时编译器\n  - *jasper-el.jar* — EL表达式的实现\n  - *jsp-api.jar* — JSP 2.2 API.\n  - *servlet-api.jar* — Servlet 3.0 API.\n  - *tomcat-api.jar* — 由Tomcat定义的几个接口\n  - *tomcat-coyote.jar* — Tomcat连接器和使用程序类\n  - *tomcat-dbcp.jar* — 基于Apache Commons Pool和Apache Commons DBCP的数据库连接池\n  - *tomcat-i18n-\\**.jar* — 包含其他语言的资源约束的可选JAR，默认捆绑包含在每个单独的应用中，如果不需要国际化，可以删除\n  - *tomcat-jdbc.jar* — Tomcat JDBC数据库连接池\n  - *tomcat-util.jar* — Tomcat的各种组件使用的常见类\n  - *tomcat7-websocket.jar* — WebSocket 1.1 实现\n  - *websocket-api.jar* — WebSocket 1.1 API\n\n  *注：* CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录，一个Tomcat可以通过配置CATALINA_BASE来增加多个工作目录，也就是增加多个实例。多个实例各自可以有自己的conf，logs，temp，webapps。\n\n  >  server.loader和shared.loader\n\n  在common.loader加载完毕后，tomcat启动程序会检查catalina.properties文件中配置的server.loader和shared.loader是否设置。如果设置，读取tomcat下对应的server和shared这两个目录的类库。server和shared是对应tomcat目录下的两个目录，在Tomcat中默认是没有，catalina.properties中默认也是没有设置其值。设置方法如下：\n\n  ```properties\n  server.loader=${catalina.base}/server/classes,${catalina.base}/server/lib/*.jar\n  shared.loader=${catalina.base}/shared/classes,${catalina.base}/shared/lib/*.jar\n  ```\n\n  同时需要在tomcat目录下创建server和shared目录结构并将公用的、应用类放到里面。类加载顺序为：\n\n  Bootstrap ---> System ---> /WEB-INF/classes ---> /WEB-INF/lib/*.jar ---> Common ---> Server ---> Shared\n\n- 字符缓存设置\n\n  ```properties\n  # String cache configuration.\n  tomcat.util.buf.StringCache.byte.enabled=true\n  #tomcat.util.buf.StringCache.char.enabled=true\n  #tomcat.util.buf.StringCache.trainThreshold=500000\n  #tomcat.util.buf.StringCache.cacheSize=5000\n  ```\n\n**总结：** Tomcat可以通过catalina.properties的server和shared，为webapp提供公用类库。使一些公用的、不需要与webapp放在一起的设置信息单独保存，在更新webapp的war的时候无需更改webapp的设置。\n\n### 1.2 catalina.policy\n\n包含由Java Security Manager实现的安全策略声明，它替换了安装java时带有的java.policy文件。这个文件用来防止欺骗代码或JSP执行带有像System.exit(0)这样可能影响容器的破坏性代码，只有当Tomcat用-security命令行参数启动时这个文件才会被使用。\n\n### 1.3 context.xml\n\n这个通用context.xml可被所有的web应用程序使用，这个文件默认地可以设置到何处访问各web应用程序中的web.xml文件。context.xml文件的作用和server.xml中<Context>标签作用相同。在tomcat5.5之后，对Context的配置不推荐在server.xml中进行配置，而是在/conf/context.xml中进行独立的配置。因为server.xml是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而context.xml文件则不然，tomcat服务器会定时去扫描这个文件。一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器。\n\n默认的context.xml如下：\n\n```xml\n<Context>\n    <WatchedResource>WEB-INF/web.xml</WatchedResource>\n    <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>\n</Context>\n```\n\n以下给出一个JNDI数据源的配置：\n\n```xml\n<Resource name=\"jdbc/mysql\"\n        auth=\"Container\"\n        type=\"com.alibaba.druid.pool.DruidDataSource\"\n        maxActive=\"100\"\n        maxIdle=\"30\"\n        maxWait=\"10000\"\n        username=\"root\"\n        password=\"root\"\n        driverClassName=\"com.mysql.jdbc.Driver\"\n        url=\"jdbc:mysql://localhost:3306/test\"\n/>\n```\n\n> context.xml的作用范围\n\n- tomcat server级别\n\n  在/conf/context.xml里配置\n\n- Host级别\n\n  在/conf/Catalina/${hostName}里添加context.xml，继而进行配置。\n\n- web app级别\n\n  在/conf/Catalina/\\${hostName}里添加\\${webappName}.xml，继而进行配置。\n\n### 1.4 server.xml\n\ntomcat的主要配置文件，解析器用这个文件在启动时根据规范创建容器。\n\n默认的server.xml如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n  <Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" />\n  <Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" />\n  <Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" />\n  <Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" />\n  <Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" />\n  <GlobalNamingResources>\n    <Resource name=\"UserDatabase\" auth=\"Container\"\n              type=\"org.apache.catalina.UserDatabase\"\n              description=\"User database that can be updated and saved\"\n              factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\"\n              pathname=\"conf/tomcat-users.xml\" />\n  </GlobalNamingResources>\n  <Service name=\"Catalina\">\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n    <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n    <Engine name=\"Catalina\" defaultHost=\"localhost\">\n      <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n        <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n               resourceName=\"UserDatabase\"/>\n      </Realm>\n      <Host name=\"localhost\"  appBase=\"webapps\"\n            unpackWARs=\"true\" autoDeploy=\"true\">\n        <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n               prefix=\"localhost_access_log\" suffix=\".txt\"\n               pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n      </Host>\n    </Engine>\n  </Service>\n</Server>\n```\n\nServer是顶级元素，代表一个Tomcat实例。可以包含一个或多个Service，每个Service都有自己的Engines和Connectors。\n\n> Server元素\n\n- className\n\n  使用Java实现类的名称。这个类必须实现org.apache.catalina.Server接口。如果没有指定类名，将会使用标准实现。\n\n- address\n\n  server在这个TCP/IP地址上监听一个shutdown命令。如果没有指定地址，将会使用localhost。\n\n- port\n\n  server在这个端口上监听一个shutdown命令。设置为-1表示禁用shutdown命令。\n\n- shutdown\n\n  连接到指定端口的TCP/IP收到这个命令字符后，将会关闭Tomcat。\n\n> Listeners元素\n\nServer可以包含多个监听器。一个监听器监听指定事件，并对其作出响应。\n\nGlobalResourcesLifecycleListener作用于全局资源，保证JNDI对资源的可达性，比如数据库。\n\n```xml\n<Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" />\n```\n\n- SSLEngine\n\n  使用的SSLEngine名称。off：不适用[SSL](https://baike.baidu.com/item/ssl/320778?fr=aladdin)，on：使用[SSL](https://baike.baidu.com/item/ssl/320778?fr=aladdin)但不指定引擎。默认值是on。会初始化本地[SSL](https://baike.baidu.com/item/ssl/320778?fr=aladdin)引擎，对于使用SSLEnabled属性的APR/native connector来讲，该选项必须可用。\n\n- SSLRandomSeed\n\n  指定伪随机数生成器（PRNG）的随机数种子源，默认值为builtin。在开发环境下，可能要将其设置为/dev/urandom，以获得更快的启动速度。\n\n- FIPSMode\n\n  设置为on会请求OpenSSL进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会保留该模式）。该设置为enter会强制OpenSSl进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会产生一个错误）。设置为require要求OpenSSL已经处于FIPS模式（如果OpenSSL当前没有处于FIPS模式将会产生一个错误）。\n\n> GlobalNamingResources元素全局命名资源\n\nGlobalNamingResources元素定义了JNDI（Java命名和目录接口）资源，其允许Java软件客户端通过名称搜寻和查找数据。默认配置定义了一个名称为UserDatabase的JNDI，通过“conf/tomcat-users.xml”得到一个用于用户授权的内存数据库。\n\n```xml\n<GlobalNamingResources>\n    <Resource name=\"UserDatabase\" auth=\"Container\"\n              type=\"org.apache.catalina.UserDatabase\"\n              description=\"User database that can be updated and saved\"\n              factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\"\n              pathname=\"conf/tomcat-users.xml\" />\n  </GlobalNamingResources>\n```\n\n也可以定义其他全句话JNDI资源来实现连接池，比如MySQL数据库。\n\n> Services元素\n\n一个Service可以连接一个或多个Connectors到一个引擎。默认配置定义了一个名为“Catalina”的Service，连接了两个Connectors：HTTP和AJP到当前的引擎。\n\n```xml\n<Service name=\"Catalina\">\n   <Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" />\n   <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n   <Engine name=\"Catalina\" defaultHost=\"localhost\">\n     <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n       <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" \t\t\t\t\n              resourceName=\"UserDatabase\"/>\n     </Realm>\n     <Host name=\"localhost\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n       <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n              prefix=\"localhost_access_log\" suffix=\".txt\"\n              pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n     </Host>\n   </Engine>\n</Service>\n```\n\n- className\n\n  该实现使用的Java类名称。这个类必须实现org.apache.catalina.Service接口。如果没有指定类名称，将会使用标准实现。\n\n- name\n\n  Service的显示名称，如果采用了标准的Catalina组件，将会包含日志信息。每个Service与某个特定的Server关联的名称必须是唯一的。\n\n> Connectors元素\n\n一个Connector关联一个TCP端口，负责处理Service与客户端之间的交互。默认配置定义了两个Connectors。\n\n- HTTP/1.1\n\n  处理HTTP请求，使得Tomcat成为一个HTTP服务器。客户端可以通过Connector向服务器发送HTTP请求，接收服务器端的HTTP响应信息。\n\n  ```xml\n  <Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" />\n  ```\n\n  与生产服务默认使用80端口不同，Tomcat HTTP服务默认在TCP端口8080上运行。可以选择1024到65535之间的任意数字作为端口号来运行Tomcat服务器，前提是该端口没有被任何其他应用使用。connectionTimeOut属性定义了这个connector在链接获得同意之后，获得请求URI line（请求信息）响应的最大等待时间毫秒数。默认为20秒。redirect属性会把[SSL](https://baike.baidu.com/item/ssl/320778?fr=aladdin)请求重定向到TCP的8443端口。\n\n\n- AJP/1.3\n\n  Apache JServ Protocol connector处理Tomcat服务器与Apache HTTP服务器之间的交互。\n\n  ```xml\n  <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n  ```\n\n  可以将Tomcat和Apache HTTP服务运行在一起，Apache HTTP服务器处理静态请求和PHP；Tomcat服务器负责处理Java Servlet/JSP。\n\n> 容器\n\n包含了Engine、Host、Context和Cluster的Tomcat称为容器。最高级的是Engine，最底层的是Context。某些组件，比如Realm和Value，也可以放在容器中。\n\n> Engine引擎\n\n引擎是容器中最高级别的部分。可以包含一个或多个Host。Tomcat服务器可以配置为运行在多个主机名上，包括虚拟主机。\n\n```xml\n<Engine name=\"Catalina\" defaultHost=\"localhost\">\n```\n\nCatalina引擎从HTTP connector接收HTTP请求，并根据请求头部信息中主机名或IP地址重定向到正确的主机上。\n\n- backgroundProcessorDelay\n\n  这个值表示了在这个引擎和它的子容器上调用backgroundProcess方法之间间隔的秒数，包括所有host和context。值为非负时不会调用子容器（意味着其使用自身的处理线程）。设置为正值会产生一个衍生线程。等待指定的时间之后，该线程会在这个引擎和它的所有子容器上调用backgroundProcess方法。如果没有指定，默认值为10，即会有10秒的延迟。\n\n- className\n\n  实现该引擎使用的Java类名。该类必须实现org.apache.catalina.Engine接口。如果没有指定，会使用标准值。\n\n- defaultHost\n\n  默认主机名，定义了处理指向该服务器的请求所在主机的名称，但名称不是在这个文件中配置。\n\n- jvmRoute\n\n  在负载均衡场景下必须定义该参数，来保证session affinity可用，对于集群中所有Tomcat服务器来讲定义的名称必须是唯一的，该名称将会被添加到生成的会话标示符中，因此，允许前端代理总是将特定会话转发到同一个Tomcat实例。\n\n- name\n\n  Engine的逻辑名称，用在日志和错误信息中。当在相同的Server中使用多个Service元素时，每个Engine必须制定一个唯一的名称。\n\n- startStopThreads\n\n  Engine在启动Host子元素时将会并发使用的线程数。如果设置为0，将会使用Runtime.getRuntime().availableProcessors()的值。设置为负数，将会使用Runtime.getRuntime().availableProcessors() + value的值，如果结果小于1，将会使用1个线程。如果没有指定，默认值为1。\n\n> Realm元素\n\n一个Realm（域）就是一个包含user、password和role认证（比如访问控制）的数据库。你可以在任何容器中定义Realm，例如Engine、Host、Context和Cluster。\n\n```xml\n<Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n        <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/>\n</Realm>\n```\n\n默认配置定义了一个Catalina Engine的Realm（UserDatabaseRealm），对用户访问engine的权限进行控制。其使用定义在GlobalNamingResources中，名字为UserDatabase的JNDI。\n\n除了UserDatabaseRealm以外，还有：JDBCRealm（授权用户是否可以通过JDBC驱动连接到关系型数据库）；DataSourceRealm（通过JNDI连接到数据库）；JNDIRealm（连接到一个LDAP目录）；MemoryRealm（将XML文件加载到内存）。\n\n- className\n\n  使用Java实现类的名称。这个类必须实现org.apache.catalina.Realm接口。\n\n> Hosts\n\n一个Host定义了在Engine下的一个虚拟机，反过来其又支持多个Context（web应用）。\n\n```xml\n<Host name=\"localhost\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n```\n\n默认配置定义了一个名为localhost的主机。appBase属性定义了所有webapp的根目录，在这种情况下是webapps。默认情况下，每一个webapp的URL和它所在的目录名称相同。例如，默认的Tomcat安装目录的webapps下提供了四个web应用：docs、examples、host-manager和manager。只有ROOT是个例外，它用一个空字符串定义。也就是说，它的URL是http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。\n\n- appBase\n\n  虚拟机应用的根目录。该目录是一个可能包含部署到虚拟机上web应用的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用webapps。\n\n- xmlBase\n\n  虚拟机XML根目录。该目录是一个可能包含部署到虚拟机上context XML描述符的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用conf/目录。\n\n- createDirs\n\n  如果设置为true，Tomcat将会在启动阶段，尝试创建一个由appBase和xmlBase属性定义的目录。默认值为true。如果设置为true，并且目录创建失败，将会打印出一个错误信息，但是不会终止启动过程。\n\n- autoDeploy\n\n  该属性的值指明了在Tomcat运行的时候，是否需要定义检查新的或者更新后的web应用。如果为true，Tomcat会定义检查appBase和xmlBase目录，并对找到的新web应用和context XML描述符进行部署。更新web应用或XML上下文描述符将会触发web应用的重载。默认值为true。\n\n- backgroundProcessorDeploy\n\n  表示在调用这台主机的backgroundProcess方法和它的子容器方法，包括所有的context，之间延迟的秒数。如果延迟值不是负数的话，不会调用子容器（意味着会使用它们自己的处理线程）。设置为正数会产生衍生线程。在等待指定的时间之后，线程将会在该host上调用backgroundProcess方法，包括它的所有子容器。host将会使用后台进程执行web应用部署相关的任务。如果没有指定，默认值为-1，意味着host将会依赖于它的父引擎的后台处理线程。\n\n- className\n\n  使用的Java实现类的名称。该类必须实现org.apache.catalina.Host接口。\n\n- deployIgnore\n\n  一个正则表达式，定义了在自动部署和启动时部署的情况下需要忽略的目录。这就允许我们在版本控制系统中保持自己的配置，例如，不会将.svn或者git文件夹部署到appBase目录下。该正则表达式是相对于appBase的。同时也是固定的，意味着是相对于整个文件或目录的名称进行的。因此，foo只会匹配名称为foo的文件或目录，而不会匹配foo.war等名称的文件或目录。如果想让“foo”匹配任意名称，可以使用“.\\*foo.\\*”。\n\n- deployOnStartup\n\n  指定在Tomcat启动时是否需要自动部署host下的web应用。默认值为true。\n\n- failCtxlfServletStartFails\n\n  设置为true时，如果它的任意一个load-on-startup >= 0的servlet停止自身启动后，停止启动它的每一个子context。每一个子context可能覆盖这个属性。如果没有指定，将会使用默认值false。\n\n- name\n\n  通常是虚拟主机的网络名称，注册在你的域名服务器上。无论指定的主机名称是什么样的，Tomcat在内部都会将其转换为小写。嵌套在Engine内部的Host，其中必须有一个Host的名称匹配Engine的默认Host设置。\n\n- startStopThreads\n\n  Host在启动子Context元素时会并发使用的线程数。如果自动部署被使用的话将会使用该线程池部署新的Context。值为0时将会使用Runtime.getRuntime().availableProcessors()的值。值为负数时将会使用Runtime.getRuntime().availableProcessors()加上该值得和，小于1时将会使用1个线程。如果没有指定，会使用默认值1。\n\n- undeployOldVersion\n\n  该选项的值决定Tomcat，即自动部署进程部分，是否会检查并发部署的过时web应用，任何找到的应用都会被移除。只有在autoDeploy为true的情况下才会生效。如果没有指定将会使用默认值false。\n\n> Value\n\nValue（阀门）作为请求的前置处理程序，可以在请求发送到应用之前拦截HTTP请求。可以定义在任何容器中，比如Engine、Host、Context和Cluster。默认配置中，AccessLogValue会拦截HTTP请求，并在日志文件中创建一个切入点\n\n```xml\n<Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n               prefix=\"localhost_access_log\" suffix=\".txt\"\n               pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n```\n\n- className\n\n  设置为org.apache.catalina.ha.tcp.ReplicationValue\n\n- filter\n\n  对于已知文件扩展名或url，可以在请求中使用Value通知cluster没有修改session，对于本次变化cluster没有必要通知session管理者。如果请求匹配该过滤器模型，cluster会假设session没有发生变化。一个filter样例大概是这样的filter=“.\\*.gif|.\\*.js|.\\*.jpeg|.\\*.jpg|.\\*.png|.\\*.htm|.\\*.html|.\\*.css|.\\*.txt”。filter使用java.util.regex的正则表达式。\n\n- primaryIndicator\n\n  布尔值，如果为true，replication value将会把primaryIndicatorName属性定义的名称插入到request属性中，该值无论是Boolean.TRUE或者Boolean.FALSE，都会被放入request属性中。\n\n- primaryIndicatorName\n\n  默认值为org.apache.catalina.ha.tcp.isPrimarySession，这个值定义了一个request属性的名称，值是一个布尔值，表示会话所在的服务器是否为主服务器。\n\n- statistics\n\n  布尔值，如果想让value手机请求的统计数据，设置为true，默认值为false。\n\n- RemoteAddrValue\n\n  阻截来自特定IP地址的请求。\n\n- RemoteHostValue\n\n  阻截基于主机名称的请求。\n\n- RequestDumperValue\n\n  记录了请求的详细信息。\n\n- SingleSignOnValue\n\n  当置于a下时，允许单点登录到该主机下的所有应用上。\n\n  ​\n\n### 1.5 tomcat-users.xml\n\n用于访问tomcat管理应用程序时的安全性设置，用server.xml中引用的默认的用户数据库域（UserDatabase Realm）使用它，所有的凭证默认都是被注释的，如需授权和访问控制，或配置角色，可参考以下配置。\n\n```xml\n<role rolename=\"manager\"/>\n<role rolename=\"manager-gui\"/>\n<role rolename=\"admin\"/>\n<role rolename=\"admin-gui\"/>\n<user username=\"admin\" password=\"admin\" roles=\"admin-gui,admin,manager-gui,manager\"/>\n```\n\n这样tomcat7首页上的Server Status、Manager App、Host Manager就都可以点击登录进去。\n\ntomcat6配置：\n\n```xml\n<role rolename=\"admin\"/>\n<role rolename=\"manager\"/>\n<user username=\"admin\" password=\"admin\" roles=\"admin,manager\"/>\n```\n\n\n\n### 1.6 web.xml\n\n默认的web.xml文件可被所有的web应用程序使用，这个web.xml文件会设置jspservlet以支持应用程序处理jsps，并设置一个默认的servlet来处理静态资源和html文件，它还设置默认的回话超时以及像index.jsp，index.html这类欢迎文件，并且它为最通用的扩展文件设置默认的[MIME](http://www.w3school.com.cn/media/media_mimeref.asp)类型。\n\n一般在Java工程中，web.xml用来初始化工程配置信息，比如welcome页面，filter，listener，servlet，servlet-mapping，启动加载级别等等。\n\n当应用程序被部署到tomcat时，它会用[engine name]/[host name]/[context-path name].xml创建与context.xml等效的文件，如用户也在\\$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml.default文件，在这个文件中特定主机下的所有web应用程序将对主机器虚拟环境采用一系列默认设置。\n\n下面就详细介绍一下web.xml中常用的标签及其功能。\n\n>  \\<description\\>，\\<display-name\\>，\\<icon\\>\n\n- \\<description\\>\n\n  ```xml\n  <description>项目描述</description> <!--对项目作出描述-->\n  ```\n\n- \\<display-name\\>\n\n  ```xml\n  <display-name>项目名称</display-name> <!--定义项目的名称-->\n  ```\n\n- \\<icon\\>及\\<small-icon\\>，\\<large-icon\\>\n\n  \\<icon\\> icon元素包含small-icon和large-icon两个子元素，用来指定web站台中小图标和大图标的路径。\n\n  ```xml\n  <!--small-icon元素应指向web站台中某个小图标的路径，大小为16X 16 pixel，但是图像文件必须为GIF或JPEG格式，扩展名必须为.git或.jpg-->\n  <small-icon>/路径/smallicon.gif</small-icon>\n  <!--large-icon元素应指向web站台中某个大图标路径，大小为32X 32pixel，但是图像文件必须为GIF或JPEG的格式，扩展名必须为.git或.jpg-->\n  <large-icon>/路径/largeicon.jpg</large-icon>\n  ```\n\n  例如：\n\n  ```xml\n  <display-name>Demo Example</display-name>\n  <description>JSP 2.0 Demo Example</description>\n  <icon>\n  \t<small-icon>/images/small.gif</small-icon>\n    \t<large-icon>/images/large.gif</large-icon>\n  </icon>\n  ```\n\n> \\<context-param\\>\n\n\\<context-param\\>元素含有一对参数名和参数值，用作应用的servlet上下文初始化参数。参数名在整个web应用中必须是唯一的。\n\n例如：\n\n```xml\n<context-param>\n\t<param-name>name</param-name>\n  \t<param-value>haha</param-value>\n</context-param>\n```\n\n此处设定的参数，在JSP页面可以使用\\${initParam.name}来获取。\n\n在Servlet中可以使用下列方式获取：\n\n~~~java\nString name = getServletContext().getInitParamter(\"name\");\n~~~\n\n> \\<filter\\>\n\nfilter元素用于指定web容器中的过滤器。\n\n在请求和响应对象被servlet处理之前或之后，可以使用过滤器对这两个对象进行操作。通过filter-mapping元素，过滤器被映射到一个servlet或一个URL模式。这个过滤器的filter元素和filter-mapping元素必须具有相同的名称。\n\nfilter元素用来声明filter的相关设定，filter元素除了下面介绍的子元素之外，还包括<icon\\>，\\<display-name\\>，\\<description\\>，\\<init-param\\>，其用途一样。\n\n例如：\n\n```xml\n<filter>\n\t<filter-name>encodingFilter</filter-name>\n  \t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n \t<init-param>\n  \t\t<param-name>encoding</param-name>\n      \t<param-value>UTF-8</param-value>\n  \t</init-param>\n</filter>\n```\n\n> \\<filter-mapping\\>\n\nfilter-mapping元素用来声明web应用中的过滤器映射。过滤器可被映射到一个servlet或一个URL模式。将过滤器映射到一个servlet中会造成过滤器作用于servlet上。将过滤器映射到一个URL模式中则可以将过滤器应用于任何资源，只要该资源的URL与URL模式匹配。过滤是按照部署描述符的filter-mapping元素出现的顺序执行的。\n\nfilter-mapping元素的两个主要子元素filter-name和url-pattern用来定义Filter对应的URL。还有servlet-name和dispatcher子元素，不是很常用。\n\n特别说明一下dispatcher，设置Filter对应的请求方式，有：REQUEST,INCLUDE,FORWAR,ERROR四种，默认为REQUEST。\n\n例如：\n\n```xml\n<filter-mapping>\n\t<filter-name>encodingFilter</filter-name>\n  \t<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n> \\<servlet\\>\n\n在web.xml中完成一个最常见的任务是对servlet或JSP页面给出名称和定制的URL。用servlet元素分配名称，使用servlet-mapping元素将定制的URL与刚分配的名称相关联。\n\n例如：\n\n```xml\n<servlet>\n\t<servlet-name>dispatcher</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n</servlet>\n```\n\n> \\<servlet-mapping\\>\n\nservlet-mapping元素包含两个子元素servlet-name和url-pattern，用来定义servlet所对应的URL。\n\n例如：\n\n```xml\n<servlet-mapping>\n\t<servlet-name>dispatcher</servlet-name>\n  \t<url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n\n> \\<listener\\>\n\nlistener元素用来注册一个监听器类，可以在web应用中包含该类。使用listener元素，可以收到事件什么时候发生以及用什么作为响应的通知。\n\nlistener元素用来定义Listener接口，它的主要子元素为\\<listener-class\\>\n\n例如：\n\n```xml\n<listener>\n\t<listener-class>com.gnd.web.listener.TestListener</listener-class>\n</listener>\n```\n\n> \\<session-config\\>\n\nsession-config包含一个子元素session-timeout，定义web应用中session的有效期限。\n\n例如：\n\n```xml\n<session-config>\n\t<session-timeout>900</session-timeout>\n</session-config>\n```\n\n> \\<mime-mapping\\>\n\nmime-mapping包含两个子元素extension和mime-type，定义某个扩展名和某一MIME Type做对应。\n\n\\<extension\\>扩展名名称\\</extension\\>\n\n\\<mime-type\\>MIME格式\\</mime-type\\>\n\n例如：\n\n```xml\n<mime-mapping>\n\t<extension>doc</extension>\n  \t<mime-type>application/vnd.ms-word</mime-type>\n</mime-mapping>\n<mime-mapping>\n\t<extension>xls</extension>\n  \t<mime-type>application/vnd.ms-excel</mime-type>\n</mime-mapping>\n<mime-mapping>\n\t<extension>ppt</extension>\n  \t<mime-type>application/vnd.ms-powerpoint</mime-type>\n</mime-mapping>\n\n```\n\n> \\<welcome-file-list\\>\n\nwelcome-file-list包含一个子元素welcome-file，用来定义首页列表。\n\nwelcome-file用来指定首页文件名称，服务器会按照设定的顺序来找首页。\n\n例如：\n\n```xml\n<welcome-file-list>\n\t<welcome-file>index.jsp</welcome-file>\n  \t<welcome-file>index.html</welcome-file>\n</welcome-file-list>\n```\n\n> \\<error-page\\>\n\nerror-page元素包含三个子元素error-code，exception-type和location。\n\n将错误代码后异常的种类对应到web应用资源路径。\n\n例如：\n\n```xml\n<error-page>\n\t<error-code>404</error-code>\n  \t<location>error404.jsp</location>\n</error-page>\n<error-page>\n\t<exception-type>java.lang.Exception</exception-type>\n  \t<location>error404.jsp</location>\n</error-page>\n```\n\n> \\<jsp-config\\>\n\njsp-config元素主要用来设定jsp的相关配置，jsp-config包括taglib和jsp-property-group两个子元素，其中taglib元素在JSP1.2时就已经存在，而jsp-property-group是JSP2.0新增的元素。\n\n\\<taglib\\>\n\ntaglib元素包含两个子元素taglib-uri和taglib-location，用来设定JSP网页用到的TagLibrary路径。\n\n\\<taglib-uri\\>URI\\</taglib-uri\\>\n\ntaglib-uri定义TLD文件的URI，JSP网页的taglib指令可以经由这个URI存取到TLD文件。\n\n\\<taglib-location\\>/WEB-INF/lib/xxx.tld\\</taglib-location\\>\n\nTLD文件对应web应用的存放位置。\n\n\\<jsp-property-group\\>\n\njsp-property-group元素包含8个子元素，分别为：\n\n\\<description\\>Description\\</description\\> 此设定的说明\n\n\\<display-name\\>Name\\</display-name\\>  此设定的名称\n\n\\<url-pattern\\>URL\\</url-pattern\\>  设定值所影响的范围，如*.jsp\n\n\\<el-ignored>true/false\\</el-ignored\\>  是否支持EL语法\n\n\\<scripting-invalid\\>true/false\\</scripting-invalid\\>  是否支持java代码片段<%...%>\n\n\\<page-encoding\\>UTF-8\\</page-encoding\\> 设置JSP页面的编码\n\n\\<include-prelude\\>.jspf\\</include-prelude\\> 设置JSP页面的抬头，扩展名为.jspf\n\n\\<include-coda>.jspf\\</include-coda> 设置JSP页面的结尾，扩展名为.jspf\n\n例如：\n\n```xml\n<jsp-config>\n        <taglib>\n            <taglib-uri>Taglib</taglib-uri>\n            <taglib-location>/WEB-INF/tlds/MyTaglib.tld</taglib-location>\n        </taglib>\n        <jsp-property-group>\n            <description>Configuration JSP example</description>\n            <display-name>JspConfig</display-name>\n            <url-pattern>/*</url-pattern>\n            <el-ignored>true</el-ignored>\n            <page-encoding>UTF-8</page-encoding>\n            <scripting-invalid>true</scripting-invalid>\n        </jsp-property-group>\n    </jsp-config>\n```\n\n> \\<resource-ref\\>\n\nresource-ref元素包含五个子元素description，res-ref-name，res-type，res-auth，res-sharing-scope，利用JNDI取得应用可利用资源。\n\n\\<res-auth\\>Application/Container\\</res-auth\\> 资源由Application或Container来许可。\n\n\\<res-sharing-scope/>Shareable|Unshareable\\<res-sharing-scope/> 资源是否可以共享，默认值为Shareable\n\n例如：\n\n```xml\n<resource-ref>\n        <res-ref-name>jdbc/Druid</res-ref-name>\n        <res-type>com.alibaba.druid.pool.DruidDataSource</res-type>\n        <res-auth>Container</res-auth>\n    </resource-ref>\n```\n\n### 1.7 loggin.properties\n\nJULI记录器使用默认日志配置，它默认地使用ConsoleHandler和fileHandler设置应用程序或者程序包的日志级别。\n\n## 2. 启动流程分析\n\n### 2.1 Idea调试Tomcat源码环境搭建\n\n首先下载Tomcat源码，读者可自行去[Tomcat官网](http://tomcat.apache.org/) 下载，若执行力差的同学也可直接从此处pull。\n\nTomcat源码导入到开发工具中的方法有多种，笔者采用最直接的方式，解压源码包后直接导入到开发工具中，导入之后的源码并不能直接运行，还需要几个依赖包，读者可从此处的lib目录下获取，也可自行搜集。\n\n找好依赖包也并不能让Tomcat源码正常运行，还需要为Bootstrap这个启动类增加几个启动参数。\n\n```properties\n-Dcatalina.home=/Users/chenmin/GitHub/tomcat\n-Dcatalina.base=/Users/chenmin/GitHub/tomcat\n-Djava.endorsed.dirs=/Users/chenmin/GitHub/tomcat/endorsed\n-Djava.io.tmpdir=/Users/chenmin/GitHub/tomcat/temp\n-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n-Djava.util.logging.config.file=/Users/chenmin/GitHub/tomcat/conf/logging.properties\n```\n\n上面的参数具体代表的意思就不一一详述了，其实光看名字就知道都是干嘛用的了。\n\n以上准备步骤做好之后，就可以直接运行Bootstrap类，运行Tomcat源码进行调试了。\n\n### 2.2 Tomcat Server的组成\n\n#### 2.2.1 整体说明 \n\n在上面对配置文件的说明中，通过server.xml的解释，我们知道server.xml中最顶级的元素是server，而server.xml中的每一个元素我们都可以把它看做是Tomcat中的某一个部分。所以我们可以参照着server.xml来分析源码。\n\nTomcat最顶层的容器叫Server，它代表着整个Tomcat服务器。Server中至少要包含一个Service来提供服务。Service包含两部分：Connector和Container。Connector负责网络连接，request/response的创建，并对Socket和request、response进行转换等，Container用于封装和管理Servlet，并处理具体的request请求。\n\n一个Tomcat中只有一个Server，一个Server可以有多个Service来提供服务，一个Service只有一个Container，但是可以有多个Connector（一个服务可以有多个连接）。\n\n![tomcat整体结构](https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### 2.2.2 各组件详解\n\n可结合conf/配置文件说明中的server.xml的说明来看\n\n- Server\n\n  Server代表整个Servlet容器\n\n- Service\n\n  Service是由一个或多个Connector以及一个Engine，负责处理所有Connector所获得的客户请求的集合。\n\n- Connector\n\n  Connector将在某个指定端口上侦听客户请求，并将获得的请求交给Engine来处理，从Engine处获得回应并返回给客户端。\n\n  Tomcat有两个默认的Connector，一个直接监听来自浏览器的http请求，一个监听来自其他WebServer的请求。\n\n  Coyote Http/1.1 Connector在端口8080上监听来自浏览器的http请求\n\n  Coyote AJP/1.3 Connector在端口8009上监听来自其他WebServer的servlet/jsp代理请求。\n\n- Engine\n\n  Engine下可以配置多个虚拟主机，每个虚拟主机都有一个域名，当Engine获得一个请求时，Engine会把该请求匹配到某个Host上，然后把该请求交给该Host来处理。\n\n  Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。\n\n- Host\n\n  代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配。每个虚拟主机下都可以部署一个或者多个WebApp，每个WebApp对应于一个Context，有一个ContextPath。当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。匹配的方法是“最长匹配”，所以一个path==“”的Context将成为该Host的默认Context，所有无法和其他Context的路径名匹配的请求都将最终和该默认Context匹配。\n\n- Context\n\n  一个Context对应于一个Web Application（Web应用），一个Web应用有一个或多个Servlet组成，Context在创建的时候将根据配置文件\\$CATALINA_HOME/conf/web.xml和\\$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。如果找到，则执行该类，获得请求的回应，并返回。\n\n  Tomcat各组件关系图(此图来此网上)\n\n  ![QQ截图20170913174040](https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat-startup.gif?raw=true)\n\n### 2.3 源码分析\n\n#### 2.3.1 启动总体流程\n\nTomcat里的Server由org.apache.catalina.startup.Catalina来管理，Catalina是整个Tomcat的管理类，它里面的三个方法load，start，stop分别用来管理整个服务器的生命周期，load方法用于根据conf/server.xml文件创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器，start和stop方法在内部分别调用了Server的start和stop方法，load方法内部调用了Server的init方法，这三个方法都会按容器的结构逐层调用相应的方法，比如，Server的start方法中会调用所有的Service中的start方法，Service中的start方法又会调用所有的Service中的start方法，Service中的start方法又会调用所有包含的Connectors和Container的start方法，这样这个服务器就启动了，init和stop方法也一样，这就是整个Tomcat的生命周期的管理方式。Catalina还有个await方法，await方法直接调用了Server的await方法，这个方法的作用是进入一个循环，让主线程不退出。\n\nTomcat的启动入口上面说过，是org.apache.catalina.startup.Bootstrap，作用类似于一个CatalinaAdaptor，具体的处理过程还是使用Catalina来完成的，这么做的好处是可以把启动的入口和具体的管理类分开，从而可以很方便的创建出多种启动方式，每种启动方式只需要写一个相应的CatalinaAdaptor就可以了。\n\n![tomcat启动流程分析](https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png?raw=true)\n\n*注：*图片比较模糊，如需查看清晰图片，请自行下载resources/images目录中的**tomcat启动流程分析.png** 或 resources/docs中的**Tomcat源码分析.mdl** ，使用Rational Rose等工具打开即可。\n\n#### 2.3.2 启动流程详解\n\n正常情况下启动Tomcat，就是调用Bootstrap的main方法，代码如下：\n\n```java\npublic static void main(String args[]) {\n        if (daemon == null) {\n            // Don't set daemon until init() has completed\n            // 初始化了ClassLoader，并用ClassLoader创建了Catalina实例，赋给catalinaDaemon变量\n            Bootstrap bootstrap = new Bootstrap();\n            try {\n                bootstrap.init();\n            } catch (Throwable t) {\n                handleThrowable(t);\n                t.printStackTrace();\n                return;\n            }\n            daemon = bootstrap;\n        } else {\n            // When running as a service the call to stop will be on a new\n            // thread so make sure the correct class loader is used to prevent\n            // a range of class not found exceptions.\n            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);\n        }\n        try {\n            String command = \"start\";\n            if (args.length > 0) {\n                command = args[args.length - 1];\n            }\n            if (command.equals(\"startd\")) {\n                args[args.length - 1] = \"start\";\n                daemon.load(args);\n                daemon.start();\n            } else if (command.equals(\"stopd\")) {\n                args[args.length - 1] = \"stop\";\n                daemon.stop();\n            } else if (command.equals(\"start\")) {\n                daemon.setAwait(true);\n                daemon.load(args);\n                daemon.start();\n            } else if (command.equals(\"stop\")) {\n                daemon.stopServer(args);\n            } else if (command.equals(\"configtest\")) {\n                daemon.load(args);\n                if (null==daemon.getServer()) {\n                    System.exit(1);\n                }\n                System.exit(0);\n            } else {\n                log.warn(\"Bootstrap: command \\\"\" + command + \"\\\" does not exist.\");\n            }\n        } catch (Throwable t) {\n            // Unwrap the Exception for clearer error reporting\n            if (t instanceof InvocationTargetException &&\n                    t.getCause() != null) {\n                t = t.getCause();\n            }\n            handleThrowable(t);\n            t.printStackTrace();\n            System.exit(1);\n        }\n    }\n```\n\nmain方法中，首先执行init方法初始化了Tomcat自己的类加载器，并通过类加载器创建Catalina实例，然后赋给catalinaDaemon变量，后续操作都使用catalinaDaemon来执行。\n\n后面默认执行start命令，将调用setAwait(true)，load(args)和start()这三个方法，这三个方法内部都通过反射调用了Catalina的相应方法。\n\n```java\n// org.apache.catalina.startup.Catalina\npublic void setAwait(boolean b) {\n    await = b;\n}\n```\n\nsetAwait方法用于设置Server启动完成后是否进入等待状态的标志，如果为true则进入，否则不进入。\n\n```java\n// org.apache.catalina.startup.Catalina\n/**\n  * Start a new server instance.\n  */\npublic void load() {\n    long t1 = System.nanoTime();\n    initDirs();\n    // Before digester - it may be needed\n    initNaming();\n    // Create and execute our Digester\n    Digester digester = createStartDigester();\n    InputSource inputSource = null;\n    InputStream inputStream = null;\n    File file = null;\n    try {\n        try {\n            file = configFile();\n            inputStream = new FileInputStream(file);\n            inputSource = new InputSource(file.toURI().toURL().toString());\n        } catch (Exception e) {\n          \tif (log.isDebugEnabled()) {\n            \tlog.debug(sm.getString(\"catalina.configFail\", file), e);\n          \t}\n        }\n      \tif (inputStream == null) {\n        \ttry {\n          \t\tinputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile());\n          \t\tinputSource = new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString());\n        \t} catch (Exception e) {\n          \t\tif (log.isDebugEnabled()) {\n            \t\tlog.debug(sm.getString(\"catalina.configFail\",getConfigFile()), e);\n          \t\t}\n        \t}\n      \t}\n      \t// This should be included in catalina.jar\n      \t// Alternative: don't bother with xml, just create it manually.\n      \tif (inputStream == null) {\n        \ttry {\n          \t\tinputStream = getClass().getClassLoader().getResourceAsStream(\"server-embed.xml\");\n          \t\tinputSource = new InputSource(getClass().getClassLoader().getResource(\"server-embed.xml\").toString());\n        \t} catch (Exception e) {\n          \t\tif (log.isDebugEnabled()) {\n            \t\tlog.debug(sm.getString(\"catalina.configFail\",\"server-embed.xml\"), e);\n          \t\t}\n        \t}\t\n      }\n      if (inputStream == null || inputSource == null) {\n        \tif  (file == null) {\n          \t\tlog.warn(sm.getString(\"catalina.configFail\",getConfigFile() + \"] or [server-embed.xml]\"));\n        \t} else {\n          \t\tlog.warn(sm.getString(\"catalina.configFail\",file.getAbsolutePath()));\n          \t\tif (file.exists() && !file.canRead()) {\n            \t\tlog.warn(\"Permissions incorrect, read permission is not allowed on the file.\");\n          \t\t}\n        \t}\n        \treturn;\n      \t}\n      \ttry {\n        \tinputSource.setByteStream(inputStream);\n        \tdigester.push(this);\n        \tdigester.parse(inputSource);\n      \t} catch (SAXParseException spe) {\n        \tlog.warn(\"Catalina.start using \" + getConfigFile() + \": \" + spe.getMessage());\n        \treturn;\n      \t} catch (Exception e) {\n        \tlog.warn(\"Catalina.start using \" + getConfigFile() + \": \" , e);\n        \treturn;\n      \t}\n    } finally {\n      \tif (inputStream != null) {\n        \ttry {\n          \t\tinputStream.close();\n        \t} catch (IOException e) {\n          \t// Ignore\n        \t}\n      \t}\n    }\n  \tgetServer().setCatalina(this);\n  \tgetServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());\n  \tgetServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());\n  \t// Stream redirection\n  \tinitStreams();\n  \t// Start the new server\n  \ttry {\n    \tgetServer().init();\n  \t} catch (LifecycleException e) {\n    \tif (Boolean.getBoolean(\"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\")) {\n      \t\tthrow new java.lang.Error(e);\n    \t} else {\n      \t\tlog.error(\"Catalina.start\", e);\n    \t}\n  \t}\n  \tlong t2 = System.nanoTime();\n  \tif(log.isInfoEnabled()) {\n    \tlog.info(\"Initialization processed in \" + ((t2 - t1) / 1000000) + \" ms\");\n  \t}\n}\n```\n\nCatalina的load方法根据conf/server.xml创建了Server对象，并赋值给server属性（具体是通过开源项目Digester完成的），然后调用了server的init方法。\n\n```java\n// org.apache.catalina.startup.Catalina\npublic void start() {\n  \tif (getServer() == null) {\n\t\tload();\n\t}\n    if (getServer() == null) {\n        log.fatal(\"Cannot start server. Server instance is not configured.\");\n        return;\n    }\n    long t1 = System.nanoTime();\n    // Start the new server\n    try {\n        getServer().start();\n    } catch (LifecycleException e) {\n        log.fatal(sm.getString(\"catalina.serverStartFail\"), e);\n        try {\n            getServer().destroy();\n        } catch (LifecycleException e1) {\n            log.debug(\"destroy() failed for failed Server \", e1);\n        }\n        return;\n    }\n    long t2 = System.nanoTime();\n    if(log.isInfoEnabled()) {\n        log.info(\"Server startup in \" + ((t2 - t1) / 1000000) + \" ms\");\n    }\n    // Register shutdown hook\n    if (useShutdownHook) {\n        if (shutdownHook == null) {\n            shutdownHook = new CatalinaShutdownHook();\n        }\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n        // If JULI is being used, disable JULI's shutdown hook since\n        // shutdown hooks run in parallel and log messages may be lost\n        // if JULI's hook completes before the CatalinaShutdownHook()\n        LogManager logManager = LogManager.getLogManager();\n        if (logManager instanceof ClassLoaderLogManager) {\n            ((ClassLoaderLogManager) logManager).setUseShutdownHook(false);\n        }\n    }\n    if (await) {\n        await();\n        stop();\n    }\n}\n```\n\n这里首先判断Server是否已经存在了，如果不存在则调用load方法来初始化Server，然后调用Server的start方法来启动服务器，最后注册了关闭钩子并根据await属性判断是否进入等待状态，之前我们已经将这里的await属性设置为true，所以需要进入等待状态。进入等待状态会调用await和stop两个方法，await方法会直接调用Server的await方法，Server的await方法内部会执行一个while循环，这样程序就停到了await方法，当await方法里的while循环退出时，就会执行stop方法，从而关闭服务器。\n\n代码如下：\n\n```java\n// org.apache.catalina.core.StandardServer\n@Override\npublic void await() {\n    // Negative values - don't wait on port - tomcat is embedded or we just don't like ports\n    if( port == -2 ) {\n        // undocumented yet - for embedding apps that are around, alive.\n        return;\n    }\n    if( port==-1 ) {\n        try {\n            awaitThread = Thread.currentThread();\n            while(!stopAwait) {\n                try {\n                    Thread.sleep( 10000 );\n                } catch( InterruptedException ex ) {\n                    // continue and check the flag\n                }\n            }\n        } finally {\n            awaitThread = null;\n        }\n        return;\n    }\n    // Set up a server socket to wait on\n    try {\n        awaitSocket = new ServerSocket(port, 1,InetAddress.getByName(address));\n    } catch (IOException e) {\n        log.error(\"StandardServer.await: create[\" + address+ \":\" + port+ \"]: \", e);\n        return;\n    }\n    try {\n        awaitThread = Thread.currentThread();\n        // Loop waiting for a connection and a valid command\n        while (!stopAwait) {\n            ServerSocket serverSocket = awaitSocket;\n            if (serverSocket == null) {\n                break;\n            }\n            // Wait for the next connection\n            Socket socket = null;\n            StringBuilder command = new StringBuilder();\n            try {\n                InputStream stream;\n                long acceptStartTime = System.currentTimeMillis();\n                try {\n                    socket = serverSocket.accept();\n                    socket.setSoTimeout(10 * 1000);  // Ten seconds\n                    stream = socket.getInputStream();\n                } catch (SocketTimeoutException ste) {\n                    // This should never happen but bug 56684 suggests that\n                    // it does.\n                    log.warn(sm.getString(\"standardServer.accept.timeout\",\n                                Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste);\n                    continue;\n                } catch (AccessControlException ace) {\n                    log.warn(\"StandardServer.accept security exception: \" + ace.getMessage(), ace);\n                \tcontinue;\n                } catch (IOException e) {\n                    if (stopAwait) {\n                        // Wait was aborted with socket.close()\n                        break;\n                    }\n                    log.error(\"StandardServer.await: accept: \", e);\n                    break;\n                }\n                // Read a set of characters from the socket\n                int expected = 1024; // Cut off to avoid DoS attack\n                while (expected < shutdown.length()) {\n                    if (random == null)\n                        random = new Random();\n                    expected += (random.nextInt() % 1024);\n                }\n                while (expected > 0) {\n                    int ch = -1;\n                    try {\n                        ch = stream.read();\n                    } catch (IOException e) {\n                        log.warn(\"StandardServer.await: read: \", e);\n                        ch = -1;\n                    }\n                    // Control character or EOF (-1) terminates loop\n                    if (ch < 32 || ch == 127) {\n                        break;\n                    }\n                    command.append((char) ch);\n                    expected--;\n                }\n            } finally {\n                // Close the socket now that we are done with it\n                try {\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n            // Match against our command string\n            boolean match = command.toString().equals(shutdown);\n            if (match) {                \t\t\t\t\t            \n              \tlog.info(sm.getString(\"standardServer.shutdownViaPort\"));\n\t        break;\n        } else\n                log.warn(\"StandardServer.await: Invalid command '\" + command.toString() + \"' received\");\n        }\n    } finally {\n        ServerSocket serverSocket = awaitSocket;\n        awaitThread = null;\n        awaitSocket = null;\n        // Close the server socket and return\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}\n```\n\n#### \n\n\n\n\n\n\n## 参考书籍\n\n>  [看透springMvc源代码分析与实践.pdf](链接：http://pan.baidu.com/s/1o7Zp1Q6 密码：c87j)\n\n## 推荐博客\n\n> [解析XML之Digester](http://www.jianshu.com/p/4cdc422b269b)\n\n","content":"<h2 id=\"Tomcat目录说明\"><a href=\"#Tomcat目录说明\" class=\"headerlink\" title=\"Tomcat目录说明\"></a>Tomcat目录说明<a id=\"more\"></a></h2><ul>\n<li><p>bin</p>\n<p>存放启动和关闭Tomcat的脚本文件</p>\n</li>\n<li><p>conf</p>\n<p>存放Tomcat的各种配置文件</p>\n</li>\n<li><p>lib</p>\n<p>存放Tomcat的依赖jar包</p>\n</li>\n<li><p>logs</p>\n<p>存放Tomcat的日志文件</p>\n</li>\n<li><p>temp</p>\n<p>存放Tomcat运行中产生的临时文件</p>\n</li>\n<li><p>webapps</p>\n<p>web应用所在目录，即供外界访问的web资源的存放目录</p>\n</li>\n<li><p>work</p>\n<p>Tomcat的工作目录</p>\n</li>\n</ul>\n<h2 id=\"1-conf-配置文件说明\"><a href=\"#1-conf-配置文件说明\" class=\"headerlink\" title=\"1. conf/配置文件说明\"></a>1. conf/配置文件说明</h2><h3 id=\"1-1-catalina-properties\"><a href=\"#1-1-catalina-properties\" class=\"headerlink\" title=\"1.1 catalina.properties\"></a>1.1 catalina.properties</h3><p>Tomcat的catalina.properties文件位于%CATALINA_HOME%/conf/目录下面，该文件主要配置tomcat的安全设置、类加载设置、不需要扫描的类设置、字符缓存设置四大块。</p>\n<ul>\n<li><p>安全设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.access=sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.</span><br><span class=\"line\">package.definition=sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类加载设置</p>\n<blockquote>\n<p> tomcat的类加载顺序为：</p>\n</blockquote>\n<p>Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common</p>\n<p>注: Common的配置是通过catalina.properties的commons.loader设置的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 类加载顺序：</p>\n</blockquote>\n<p>${catalina.base}/lib  未打包的类和资源文件</p>\n<p>${catalina.base}/lib/*.jar  JAR文件</p>\n<p>${catalina.home}/lib  未打包的类和文件</p>\n<p>${catalina.home}/lib/*.jar  JAR文件</p>\n<blockquote>\n<p> 默认情况下，会加载以下内容：</p>\n</blockquote>\n<ul>\n<li><em>annotations-api.jar</em> — JavaEE注释类</li>\n<li><em>catalina.jar</em> — 执行Tomcat的Catalina Servlet容器部分</li>\n<li><em>catalina-ant.jar</em> — Tomcat Catalina Ant 任务</li>\n<li><em>catalina-ha.jar</em> — 高可用包</li>\n<li><em>catalina-tribes.jar</em> — 组通信包</li>\n<li><em>ecj-\\</em>.jar* — Eclipse JDT Java 编译器</li>\n<li><em>el-api.jar</em> — EL 2.2 API.</li>\n<li><em>jasper.jar</em> — JSP 运行时编译器</li>\n<li><em>jasper-el.jar</em> — EL表达式的实现</li>\n<li><em>jsp-api.jar</em> — JSP 2.2 API.</li>\n<li><em>servlet-api.jar</em> — Servlet 3.0 API.</li>\n<li><em>tomcat-api.jar</em> — 由Tomcat定义的几个接口</li>\n<li><em>tomcat-coyote.jar</em> — Tomcat连接器和使用程序类</li>\n<li><em>tomcat-dbcp.jar</em> — 基于Apache Commons Pool和Apache Commons DBCP的数据库连接池</li>\n<li><em>tomcat-i18n-**.jar</em> — 包含其他语言的资源约束的可选JAR，默认捆绑包含在每个单独的应用中，如果不需要国际化，可以删除</li>\n<li><em>tomcat-jdbc.jar</em> — Tomcat JDBC数据库连接池</li>\n<li><em>tomcat-util.jar</em> — Tomcat的各种组件使用的常见类</li>\n<li><em>tomcat7-websocket.jar</em> — WebSocket 1.1 实现</li>\n<li><em>websocket-api.jar</em> — WebSocket 1.1 API</li>\n</ul>\n<p><em>注：</em> CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录，一个Tomcat可以通过配置CATALINA_BASE来增加多个工作目录，也就是增加多个实例。多个实例各自可以有自己的conf，logs，temp，webapps。</p>\n<blockquote>\n<p> server.loader和shared.loader</p>\n</blockquote>\n<p>在common.loader加载完毕后，tomcat启动程序会检查catalina.properties文件中配置的server.loader和shared.loader是否设置。如果设置，读取tomcat下对应的server和shared这两个目录的类库。server和shared是对应tomcat目录下的两个目录，在Tomcat中默认是没有，catalina.properties中默认也是没有设置其值。设置方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.loader=$&#123;catalina.base&#125;/server/classes,$&#123;catalina.base&#125;/server/lib/*.jar</span><br><span class=\"line\">shared.loader=$&#123;catalina.base&#125;/shared/classes,$&#123;catalina.base&#125;/shared/lib/*.jar</span><br></pre></td></tr></table></figure>\n<p>同时需要在tomcat目录下创建server和shared目录结构并将公用的、应用类放到里面。类加载顺序为：</p>\n<p>Bootstrap —&gt; System —&gt; /WEB-INF/classes —&gt; /WEB-INF/lib/*.jar —&gt; Common —&gt; Server —&gt; Shared</p>\n</li>\n<li><p>字符缓存设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># String cache configuration.</span><br><span class=\"line\">tomcat.util.buf.StringCache.byte.enabled=true</span><br><span class=\"line\">#tomcat.util.buf.StringCache.char.enabled=true</span><br><span class=\"line\">#tomcat.util.buf.StringCache.trainThreshold=500000</span><br><span class=\"line\">#tomcat.util.buf.StringCache.cacheSize=5000</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>总结：</strong> Tomcat可以通过catalina.properties的server和shared，为webapp提供公用类库。使一些公用的、不需要与webapp放在一起的设置信息单独保存，在更新webapp的war的时候无需更改webapp的设置。</p>\n<h3 id=\"1-2-catalina-policy\"><a href=\"#1-2-catalina-policy\" class=\"headerlink\" title=\"1.2 catalina.policy\"></a>1.2 catalina.policy</h3><p>包含由Java Security Manager实现的安全策略声明，它替换了安装java时带有的java.policy文件。这个文件用来防止欺骗代码或JSP执行带有像System.exit(0)这样可能影响容器的破坏性代码，只有当Tomcat用-security命令行参数启动时这个文件才会被使用。</p>\n<h3 id=\"1-3-context-xml\"><a href=\"#1-3-context-xml\" class=\"headerlink\" title=\"1.3 context.xml\"></a>1.3 context.xml</h3><p>这个通用context.xml可被所有的web应用程序使用，这个文件默认地可以设置到何处访问各web应用程序中的web.xml文件。context.xml文件的作用和server.xml中<context>标签作用相同。在tomcat5.5之后，对Context的配置不推荐在server.xml中进行配置，而是在/conf/context.xml中进行独立的配置。因为server.xml是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而context.xml文件则不然，tomcat服务器会定时去扫描这个文件。一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器。</context></p>\n<p>默认的context.xml如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Context</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class=\"tag\">&lt;/<span class=\"name\">WatchedResource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">WatchedResource</span>&gt;</span>$&#123;catalina.base&#125;/conf/web.xml<span class=\"tag\">&lt;/<span class=\"name\">WatchedResource</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以下给出一个JNDI数据源的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Resource</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbc/mysql\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">auth</span>=<span class=\"string\">\"Container\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">type</span>=<span class=\"string\">\"com.alibaba.druid.pool.DruidDataSource\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxActive</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxIdle</span>=<span class=\"string\">\"30\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxWait</span>=<span class=\"string\">\"10000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">username</span>=<span class=\"string\">\"root\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">password</span>=<span class=\"string\">\"root\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">driverClassName</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">url</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>context.xml的作用范围</p>\n</blockquote>\n<ul>\n<li><p>tomcat server级别</p>\n<p>在/conf/context.xml里配置</p>\n</li>\n<li><p>Host级别</p>\n<p>在/conf/Catalina/${hostName}里添加context.xml，继而进行配置。</p>\n</li>\n<li><p>web app级别</p>\n<p>在/conf/Catalina/\\${hostName}里添加\\${webappName}.xml，继而进行配置。</p>\n</li>\n</ul>\n<h3 id=\"1-4-server-xml\"><a href=\"#1-4-server-xml\" class=\"headerlink\" title=\"1.4 server.xml\"></a>1.4 server.xml</h3><p>tomcat的主要配置文件，解析器用这个文件在启动时根据规范创建容器。</p>\n<p>默认的server.xml如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?</span>xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span><span class=\"meta\">?&gt;</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Server</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8005\"</span> <span class=\"attr\">shutdown</span>=<span class=\"string\">\"SHUTDOWN\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.startup.VersionLoggerListener\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.core.AprLifecycleListener\"</span> <span class=\"attr\">SSLEngine</span>=<span class=\"string\">\"on\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.core.JreMemoryLeakPreventionListener\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">GlobalNamingResources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Resource</span> <span class=\"attr\">name</span>=<span class=\"string\">\"UserDatabase\"</span> <span class=\"attr\">auth</span>=<span class=\"string\">\"Container\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">type</span>=<span class=\"string\">\"org.apache.catalina.UserDatabase\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">description</span>=<span class=\"string\">\"User database that can be updated and saved\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">factory</span>=<span class=\"string\">\"org.apache.catalina.users.MemoryUserDatabaseFactory\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">pathname</span>=<span class=\"string\">\"conf/tomcat-users.xml\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">GlobalNamingResources</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Service</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Catalina\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8009\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"AJP/1.3\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Engine</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Catalina\"</span> <span class=\"attr\">defaultHost</span>=<span class=\"string\">\"localhost\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.LockOutRealm\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.UserDatabaseRealm\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">resourceName</span>=<span class=\"string\">\"UserDatabase\"</span>/&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">Realm</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Host</span> <span class=\"attr\">name</span>=<span class=\"string\">\"localhost\"</span>  <span class=\"attr\">appBase</span>=<span class=\"string\">\"webapps\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">unpackWARs</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">autoDeploy</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Valve</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.valves.AccessLogValve\"</span> <span class=\"attr\">directory</span>=<span class=\"string\">\"logs\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">prefix</span>=<span class=\"string\">\"localhost_access_log\"</span> <span class=\"attr\">suffix</span>=<span class=\"string\">\".txt\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">pattern</span>=<span class=\"string\">\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\"</span> /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">Host</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Engine</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Service</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Server是顶级元素，代表一个Tomcat实例。可以包含一个或多个Service，每个Service都有自己的Engines和Connectors。</p>\n<blockquote>\n<p>Server元素</p>\n</blockquote>\n<ul>\n<li><p>className</p>\n<p>使用Java实现类的名称。这个类必须实现org.apache.catalina.Server接口。如果没有指定类名，将会使用标准实现。</p>\n</li>\n<li><p>address</p>\n<p>server在这个TCP/IP地址上监听一个shutdown命令。如果没有指定地址，将会使用localhost。</p>\n</li>\n<li><p>port</p>\n<p>server在这个端口上监听一个shutdown命令。设置为-1表示禁用shutdown命令。</p>\n</li>\n<li><p>shutdown</p>\n<p>连接到指定端口的TCP/IP收到这个命令字符后，将会关闭Tomcat。</p>\n</li>\n</ul>\n<blockquote>\n<p>Listeners元素</p>\n</blockquote>\n<p>Server可以包含多个监听器。一个监听器监听指定事件，并对其作出响应。</p>\n<p>GlobalResourcesLifecycleListener作用于全局资源，保证JNDI对资源的可达性，比如数据库。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Listener</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>SSLEngine</p>\n<p>使用的SSLEngine名称。off：不适用<a href=\"https://baike.baidu.com/item/ssl/320778?fr=aladdin\" target=\"_blank\" rel=\"noopener\">SSL</a>，on：使用<a href=\"https://baike.baidu.com/item/ssl/320778?fr=aladdin\" target=\"_blank\" rel=\"noopener\">SSL</a>但不指定引擎。默认值是on。会初始化本地<a href=\"https://baike.baidu.com/item/ssl/320778?fr=aladdin\" target=\"_blank\" rel=\"noopener\">SSL</a>引擎，对于使用SSLEnabled属性的APR/native connector来讲，该选项必须可用。</p>\n</li>\n<li><p>SSLRandomSeed</p>\n<p>指定伪随机数生成器（PRNG）的随机数种子源，默认值为builtin。在开发环境下，可能要将其设置为/dev/urandom，以获得更快的启动速度。</p>\n</li>\n<li><p>FIPSMode</p>\n<p>设置为on会请求OpenSSL进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会保留该模式）。该设置为enter会强制OpenSSl进入FIPS模式（如果OpenSSL已经处于FIPS模式，将会产生一个错误）。设置为require要求OpenSSL已经处于FIPS模式（如果OpenSSL当前没有处于FIPS模式将会产生一个错误）。</p>\n</li>\n</ul>\n<blockquote>\n<p>GlobalNamingResources元素全局命名资源</p>\n</blockquote>\n<p>GlobalNamingResources元素定义了JNDI（Java命名和目录接口）资源，其允许Java软件客户端通过名称搜寻和查找数据。默认配置定义了一个名称为UserDatabase的JNDI，通过“conf/tomcat-users.xml”得到一个用于用户授权的内存数据库。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">GlobalNamingResources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Resource</span> <span class=\"attr\">name</span>=<span class=\"string\">\"UserDatabase\"</span> <span class=\"attr\">auth</span>=<span class=\"string\">\"Container\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">type</span>=<span class=\"string\">\"org.apache.catalina.UserDatabase\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">description</span>=<span class=\"string\">\"User database that can be updated and saved\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">factory</span>=<span class=\"string\">\"org.apache.catalina.users.MemoryUserDatabaseFactory\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">pathname</span>=<span class=\"string\">\"conf/tomcat-users.xml\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以定义其他全句话JNDI资源来实现连接池，比如MySQL数据库。</p>\n<blockquote>\n<p>Services元素</p>\n</blockquote>\n<p>一个Service可以连接一个或多个Connectors到一个引擎。默认配置定义了一个名为“Catalina”的Service，连接了两个Connectors：HTTP和AJP到当前的引擎。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Service</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Catalina\"</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span> <span class=\"attr\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8009\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"AJP/1.3\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">Engine</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Catalina\"</span> <span class=\"attr\">defaultHost</span>=<span class=\"string\">\"localhost\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.LockOutRealm\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.UserDatabaseRealm\"</span> \t\t\t\t</span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">resourceName</span>=<span class=\"string\">\"UserDatabase\"</span>/&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">Realm</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">Host</span> <span class=\"attr\">name</span>=<span class=\"string\">\"localhost\"</span>  <span class=\"attr\">appBase</span>=<span class=\"string\">\"webapps\"</span> <span class=\"attr\">unpackWARs</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">autoDeploy</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Valve</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.valves.AccessLogValve\"</span> <span class=\"attr\">directory</span>=<span class=\"string\">\"logs\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">prefix</span>=<span class=\"string\">\"localhost_access_log\"</span> <span class=\"attr\">suffix</span>=<span class=\"string\">\".txt\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">pattern</span>=<span class=\"string\">\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\"</span> /&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">Host</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">Engine</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>className</p>\n<p>该实现使用的Java类名称。这个类必须实现org.apache.catalina.Service接口。如果没有指定类名称，将会使用标准实现。</p>\n</li>\n<li><p>name</p>\n<p>Service的显示名称，如果采用了标准的Catalina组件，将会包含日志信息。每个Service与某个特定的Server关联的名称必须是唯一的。</p>\n</li>\n</ul>\n<blockquote>\n<p>Connectors元素</p>\n</blockquote>\n<p>一个Connector关联一个TCP端口，负责处理Service与客户端之间的交互。默认配置定义了两个Connectors。</p>\n<ul>\n<li><p>HTTP/1.1</p>\n<p>处理HTTP请求，使得Tomcat成为一个HTTP服务器。客户端可以通过Connector向服务器发送HTTP请求，接收服务器端的HTTP响应信息。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span> <span class=\"attr\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>与生产服务默认使用80端口不同，Tomcat HTTP服务默认在TCP端口8080上运行。可以选择1024到65535之间的任意数字作为端口号来运行Tomcat服务器，前提是该端口没有被任何其他应用使用。connectionTimeOut属性定义了这个connector在链接获得同意之后，获得请求URI line（请求信息）响应的最大等待时间毫秒数。默认为20秒。redirect属性会把<a href=\"https://baike.baidu.com/item/ssl/320778?fr=aladdin\" target=\"_blank\" rel=\"noopener\">SSL</a>请求重定向到TCP的8443端口。</p>\n</li>\n</ul>\n<ul>\n<li><p>AJP/1.3</p>\n<p>Apache JServ Protocol connector处理Tomcat服务器与Apache HTTP服务器之间的交互。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8009\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"AJP/1.3\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以将Tomcat和Apache HTTP服务运行在一起，Apache HTTP服务器处理静态请求和PHP；Tomcat服务器负责处理Java Servlet/JSP。</p>\n</li>\n</ul>\n<blockquote>\n<p>容器</p>\n</blockquote>\n<p>包含了Engine、Host、Context和Cluster的Tomcat称为容器。最高级的是Engine，最底层的是Context。某些组件，比如Realm和Value，也可以放在容器中。</p>\n<blockquote>\n<p>Engine引擎</p>\n</blockquote>\n<p>引擎是容器中最高级别的部分。可以包含一个或多个Host。Tomcat服务器可以配置为运行在多个主机名上，包括虚拟主机。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Engine</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Catalina\"</span> <span class=\"attr\">defaultHost</span>=<span class=\"string\">\"localhost\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Catalina引擎从HTTP connector接收HTTP请求，并根据请求头部信息中主机名或IP地址重定向到正确的主机上。</p>\n<ul>\n<li><p>backgroundProcessorDelay</p>\n<p>这个值表示了在这个引擎和它的子容器上调用backgroundProcess方法之间间隔的秒数，包括所有host和context。值为非负时不会调用子容器（意味着其使用自身的处理线程）。设置为正值会产生一个衍生线程。等待指定的时间之后，该线程会在这个引擎和它的所有子容器上调用backgroundProcess方法。如果没有指定，默认值为10，即会有10秒的延迟。</p>\n</li>\n<li><p>className</p>\n<p>实现该引擎使用的Java类名。该类必须实现org.apache.catalina.Engine接口。如果没有指定，会使用标准值。</p>\n</li>\n<li><p>defaultHost</p>\n<p>默认主机名，定义了处理指向该服务器的请求所在主机的名称，但名称不是在这个文件中配置。</p>\n</li>\n<li><p>jvmRoute</p>\n<p>在负载均衡场景下必须定义该参数，来保证session affinity可用，对于集群中所有Tomcat服务器来讲定义的名称必须是唯一的，该名称将会被添加到生成的会话标示符中，因此，允许前端代理总是将特定会话转发到同一个Tomcat实例。</p>\n</li>\n<li><p>name</p>\n<p>Engine的逻辑名称，用在日志和错误信息中。当在相同的Server中使用多个Service元素时，每个Engine必须制定一个唯一的名称。</p>\n</li>\n<li><p>startStopThreads</p>\n<p>Engine在启动Host子元素时将会并发使用的线程数。如果设置为0，将会使用Runtime.getRuntime().availableProcessors()的值。设置为负数，将会使用Runtime.getRuntime().availableProcessors() + value的值，如果结果小于1，将会使用1个线程。如果没有指定，默认值为1。</p>\n</li>\n</ul>\n<blockquote>\n<p>Realm元素</p>\n</blockquote>\n<p>一个Realm（域）就是一个包含user、password和role认证（比如访问控制）的数据库。你可以在任何容器中定义Realm，例如Engine、Host、Context和Cluster。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.LockOutRealm\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Realm</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.realm.UserDatabaseRealm\"</span> <span class=\"attr\">resourceName</span>=<span class=\"string\">\"UserDatabase\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Realm</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>默认配置定义了一个Catalina Engine的Realm（UserDatabaseRealm），对用户访问engine的权限进行控制。其使用定义在GlobalNamingResources中，名字为UserDatabase的JNDI。</p>\n<p>除了UserDatabaseRealm以外，还有：JDBCRealm（授权用户是否可以通过JDBC驱动连接到关系型数据库）；DataSourceRealm（通过JNDI连接到数据库）；JNDIRealm（连接到一个LDAP目录）；MemoryRealm（将XML文件加载到内存）。</p>\n<ul>\n<li><p>className</p>\n<p>使用Java实现类的名称。这个类必须实现org.apache.catalina.Realm接口。</p>\n</li>\n</ul>\n<blockquote>\n<p>Hosts</p>\n</blockquote>\n<p>一个Host定义了在Engine下的一个虚拟机，反过来其又支持多个Context（web应用）。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Host</span> <span class=\"attr\">name</span>=<span class=\"string\">\"localhost\"</span>  <span class=\"attr\">appBase</span>=<span class=\"string\">\"webapps\"</span> <span class=\"attr\">unpackWARs</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">autoDeploy</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>默认配置定义了一个名为localhost的主机。appBase属性定义了所有webapp的根目录，在这种情况下是webapps。默认情况下，每一个webapp的URL和它所在的目录名称相同。例如，默认的Tomcat安装目录的webapps下提供了四个web应用：docs、examples、host-manager和manager。只有ROOT是个例外，它用一个空字符串定义。也就是说，它的URL是<a href=\"http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/。unpackWARs属性指定了放到webapps目录下的WAR-file是否应该被解压。对于unpackWARs=“false”，Tomcat将会直接从WAR-file运行应用，而不解压，这可能导致应用运行变慢。autoDeploy属性指定了是否自动部署放到webapps目录下的应用。</a></p>\n<ul>\n<li><p>appBase</p>\n<p>虚拟机应用的根目录。该目录是一个可能包含部署到虚拟机上web应用的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用webapps。</p>\n</li>\n<li><p>xmlBase</p>\n<p>虚拟机XML根目录。该目录是一个可能包含部署到虚拟机上context XML描述符的路径名。也可能是一个指定的绝对路径名，或者是一个相对于$CATALINA_BASE目录的路径名。如果没有指定，默认会使用conf/目录。</p>\n</li>\n<li><p>createDirs</p>\n<p>如果设置为true，Tomcat将会在启动阶段，尝试创建一个由appBase和xmlBase属性定义的目录。默认值为true。如果设置为true，并且目录创建失败，将会打印出一个错误信息，但是不会终止启动过程。</p>\n</li>\n<li><p>autoDeploy</p>\n<p>该属性的值指明了在Tomcat运行的时候，是否需要定义检查新的或者更新后的web应用。如果为true，Tomcat会定义检查appBase和xmlBase目录，并对找到的新web应用和context XML描述符进行部署。更新web应用或XML上下文描述符将会触发web应用的重载。默认值为true。</p>\n</li>\n<li><p>backgroundProcessorDeploy</p>\n<p>表示在调用这台主机的backgroundProcess方法和它的子容器方法，包括所有的context，之间延迟的秒数。如果延迟值不是负数的话，不会调用子容器（意味着会使用它们自己的处理线程）。设置为正数会产生衍生线程。在等待指定的时间之后，线程将会在该host上调用backgroundProcess方法，包括它的所有子容器。host将会使用后台进程执行web应用部署相关的任务。如果没有指定，默认值为-1，意味着host将会依赖于它的父引擎的后台处理线程。</p>\n</li>\n<li><p>className</p>\n<p>使用的Java实现类的名称。该类必须实现org.apache.catalina.Host接口。</p>\n</li>\n<li><p>deployIgnore</p>\n<p>一个正则表达式，定义了在自动部署和启动时部署的情况下需要忽略的目录。这就允许我们在版本控制系统中保持自己的配置，例如，不会将.svn或者git文件夹部署到appBase目录下。该正则表达式是相对于appBase的。同时也是固定的，意味着是相对于整个文件或目录的名称进行的。因此，foo只会匹配名称为foo的文件或目录，而不会匹配foo.war等名称的文件或目录。如果想让“foo”匹配任意名称，可以使用“.*foo.*”。</p>\n</li>\n<li><p>deployOnStartup</p>\n<p>指定在Tomcat启动时是否需要自动部署host下的web应用。默认值为true。</p>\n</li>\n<li><p>failCtxlfServletStartFails</p>\n<p>设置为true时，如果它的任意一个load-on-startup &gt;= 0的servlet停止自身启动后，停止启动它的每一个子context。每一个子context可能覆盖这个属性。如果没有指定，将会使用默认值false。</p>\n</li>\n<li><p>name</p>\n<p>通常是虚拟主机的网络名称，注册在你的域名服务器上。无论指定的主机名称是什么样的，Tomcat在内部都会将其转换为小写。嵌套在Engine内部的Host，其中必须有一个Host的名称匹配Engine的默认Host设置。</p>\n</li>\n<li><p>startStopThreads</p>\n<p>Host在启动子Context元素时会并发使用的线程数。如果自动部署被使用的话将会使用该线程池部署新的Context。值为0时将会使用Runtime.getRuntime().availableProcessors()的值。值为负数时将会使用Runtime.getRuntime().availableProcessors()加上该值得和，小于1时将会使用1个线程。如果没有指定，会使用默认值1。</p>\n</li>\n<li><p>undeployOldVersion</p>\n<p>该选项的值决定Tomcat，即自动部署进程部分，是否会检查并发部署的过时web应用，任何找到的应用都会被移除。只有在autoDeploy为true的情况下才会生效。如果没有指定将会使用默认值false。</p>\n</li>\n</ul>\n<blockquote>\n<p>Value</p>\n</blockquote>\n<p>Value（阀门）作为请求的前置处理程序，可以在请求发送到应用之前拦截HTTP请求。可以定义在任何容器中，比如Engine、Host、Context和Cluster。默认配置中，AccessLogValue会拦截HTTP请求，并在日志文件中创建一个切入点</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Valve</span> <span class=\"attr\">className</span>=<span class=\"string\">\"org.apache.catalina.valves.AccessLogValve\"</span> <span class=\"attr\">directory</span>=<span class=\"string\">\"logs\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">prefix</span>=<span class=\"string\">\"localhost_access_log\"</span> <span class=\"attr\">suffix</span>=<span class=\"string\">\".txt\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">pattern</span>=<span class=\"string\">\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>className</p>\n<p>设置为org.apache.catalina.ha.tcp.ReplicationValue</p>\n</li>\n<li><p>filter</p>\n<p>对于已知文件扩展名或url，可以在请求中使用Value通知cluster没有修改session，对于本次变化cluster没有必要通知session管理者。如果请求匹配该过滤器模型，cluster会假设session没有发生变化。一个filter样例大概是这样的filter=“.*.gif|.*.js|.*.jpeg|.*.jpg|.*.png|.*.htm|.*.html|.*.css|.*.txt”。filter使用java.util.regex的正则表达式。</p>\n</li>\n<li><p>primaryIndicator</p>\n<p>布尔值，如果为true，replication value将会把primaryIndicatorName属性定义的名称插入到request属性中，该值无论是Boolean.TRUE或者Boolean.FALSE，都会被放入request属性中。</p>\n</li>\n<li><p>primaryIndicatorName</p>\n<p>默认值为org.apache.catalina.ha.tcp.isPrimarySession，这个值定义了一个request属性的名称，值是一个布尔值，表示会话所在的服务器是否为主服务器。</p>\n</li>\n<li><p>statistics</p>\n<p>布尔值，如果想让value手机请求的统计数据，设置为true，默认值为false。</p>\n</li>\n<li><p>RemoteAddrValue</p>\n<p>阻截来自特定IP地址的请求。</p>\n</li>\n<li><p>RemoteHostValue</p>\n<p>阻截基于主机名称的请求。</p>\n</li>\n<li><p>RequestDumperValue</p>\n<p>记录了请求的详细信息。</p>\n</li>\n<li><p>SingleSignOnValue</p>\n<p>当置于a下时，允许单点登录到该主机下的所有应用上。</p>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"1-5-tomcat-users-xml\"><a href=\"#1-5-tomcat-users-xml\" class=\"headerlink\" title=\"1.5 tomcat-users.xml\"></a>1.5 tomcat-users.xml</h3><p>用于访问tomcat管理应用程序时的安全性设置，用server.xml中引用的默认的用户数据库域（UserDatabase Realm）使用它，所有的凭证默认都是被注释的，如需授权和访问控制，或配置角色，可参考以下配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"manager\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"manager-gui\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"admin\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"admin-gui\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">user</span> <span class=\"attr\">username</span>=<span class=\"string\">\"admin\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"admin\"</span> <span class=\"attr\">roles</span>=<span class=\"string\">\"admin-gui,admin,manager-gui,manager\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样tomcat7首页上的Server Status、Manager App、Host Manager就都可以点击登录进去。</p>\n<p>tomcat6配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"admin\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">role</span> <span class=\"attr\">rolename</span>=<span class=\"string\">\"manager\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">user</span> <span class=\"attr\">username</span>=<span class=\"string\">\"admin\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"admin\"</span> <span class=\"attr\">roles</span>=<span class=\"string\">\"admin,manager\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-6-web-xml\"><a href=\"#1-6-web-xml\" class=\"headerlink\" title=\"1.6 web.xml\"></a>1.6 web.xml</h3><p>默认的web.xml文件可被所有的web应用程序使用，这个web.xml文件会设置jspservlet以支持应用程序处理jsps，并设置一个默认的servlet来处理静态资源和html文件，它还设置默认的回话超时以及像index.jsp，index.html这类欢迎文件，并且它为最通用的扩展文件设置默认的<a href=\"http://www.w3school.com.cn/media/media_mimeref.asp\" target=\"_blank\" rel=\"noopener\">MIME</a>类型。</p>\n<p>一般在Java工程中，web.xml用来初始化工程配置信息，比如welcome页面，filter，listener，servlet，servlet-mapping，启动加载级别等等。</p>\n<p>当应用程序被部署到tomcat时，它会用[engine name]/[host name]/[context-path name].xml创建与context.xml等效的文件，如用户也在\\$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml.default文件，在这个文件中特定主机下的所有web应用程序将对主机器虚拟环境采用一系列默认设置。</p>\n<p>下面就详细介绍一下web.xml中常用的标签及其功能。</p>\n<blockquote>\n<p> \\&lt;description>，\\&lt;display-name>，\\&lt;icon></p>\n</blockquote>\n<ul>\n<li><p>\\&lt;description></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>项目描述<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span> <span class=\"comment\">&lt;!--对项目作出描述--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\&lt;display-name></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>项目名称<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span> <span class=\"comment\">&lt;!--定义项目的名称--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\&lt;icon>及\\&lt;small-icon>，\\&lt;large-icon></p>\n<p>\\&lt;icon> icon元素包含small-icon和large-icon两个子元素，用来指定web站台中小图标和大图标的路径。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--small-icon元素应指向web站台中某个小图标的路径，大小为16X 16 pixel，但是图像文件必须为GIF或JPEG格式，扩展名必须为.git或.jpg--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">small-icon</span>&gt;</span>/路径/smallicon.gif<span class=\"tag\">&lt;/<span class=\"name\">small-icon</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--large-icon元素应指向web站台中某个大图标路径，大小为32X 32pixel，但是图像文件必须为GIF或JPEG的格式，扩展名必须为.git或.jpg--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">large-icon</span>&gt;</span>/路径/largeicon.jpg<span class=\"tag\">&lt;/<span class=\"name\">large-icon</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>Demo Example<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>JSP 2.0 Demo Example<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">icon</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">small-icon</span>&gt;</span>/images/small.gif<span class=\"tag\">&lt;/<span class=\"name\">small-icon</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">large-icon</span>&gt;</span>/images/large.gif<span class=\"tag\">&lt;/<span class=\"name\">large-icon</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">icon</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>\\&lt;context-param></p>\n</blockquote>\n<p>\\&lt;context-param>元素含有一对参数名和参数值，用作应用的servlet上下文初始化参数。参数名在整个web应用中必须是唯一的。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>haha<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>此处设定的参数，在JSP页面可以使用\\${initParam.name}来获取。</p>\n<p>在Servlet中可以使用下列方式获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = getServletContext().getInitParamter(<span class=\"string\">\"name\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;filter></p>\n</blockquote>\n<p>filter元素用于指定web容器中的过滤器。</p>\n<p>在请求和响应对象被servlet处理之前或之后，可以使用过滤器对这两个对象进行操作。通过filter-mapping元素，过滤器被映射到一个servlet或一个URL模式。这个过滤器的filter元素和filter-mapping元素必须具有相同的名称。</p>\n<p>filter元素用来声明filter的相关设定，filter元素除了下面介绍的子元素之外，还包括&lt;icon>，\\&lt;display-name>，\\&lt;description>，\\&lt;init-param>，其用途一样。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">      \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;filter-mapping></p>\n</blockquote>\n<p>filter-mapping元素用来声明web应用中的过滤器映射。过滤器可被映射到一个servlet或一个URL模式。将过滤器映射到一个servlet中会造成过滤器作用于servlet上。将过滤器映射到一个URL模式中则可以将过滤器应用于任何资源，只要该资源的URL与URL模式匹配。过滤是按照部署描述符的filter-mapping元素出现的顺序执行的。</p>\n<p>filter-mapping元素的两个主要子元素filter-name和url-pattern用来定义Filter对应的URL。还有servlet-name和dispatcher子元素，不是很常用。</p>\n<p>特别说明一下dispatcher，设置Filter对应的请求方式，有：REQUEST,INCLUDE,FORWAR,ERROR四种，默认为REQUEST。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;servlet></p>\n</blockquote>\n<p>在web.xml中完成一个最常见的任务是对servlet或JSP页面给出名称和定制的URL。用servlet元素分配名称，使用servlet-mapping元素将定制的URL与刚分配的名称相关联。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;servlet-mapping></p>\n</blockquote>\n<p>servlet-mapping元素包含两个子元素servlet-name和url-pattern，用来定义servlet所对应的URL。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;listener></p>\n</blockquote>\n<p>listener元素用来注册一个监听器类，可以在web应用中包含该类。使用listener元素，可以收到事件什么时候发生以及用什么作为响应的通知。</p>\n<p>listener元素用来定义Listener接口，它的主要子元素为\\&lt;listener-class></p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>com.gnd.web.listener.TestListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;session-config></p>\n</blockquote>\n<p>session-config包含一个子元素session-timeout，定义web应用中session的有效期限。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">session-config</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-timeout</span>&gt;</span>900<span class=\"tag\">&lt;/<span class=\"name\">session-timeout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;mime-mapping></p>\n</blockquote>\n<p>mime-mapping包含两个子元素extension和mime-type，定义某个扩展名和某一MIME Type做对应。</p>\n<p>\\&lt;extension>扩展名名称\\&lt;/extension></p>\n<p>\\&lt;mime-type>MIME格式\\&lt;/mime-type></p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mime-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span>doc<span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">mime-type</span>&gt;</span>application/vnd.ms-word<span class=\"tag\">&lt;/<span class=\"name\">mime-type</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mime-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mime-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span>xls<span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">mime-type</span>&gt;</span>application/vnd.ms-excel<span class=\"tag\">&lt;/<span class=\"name\">mime-type</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mime-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mime-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span>ppt<span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">mime-type</span>&gt;</span>application/vnd.ms-powerpoint<span class=\"tag\">&lt;/<span class=\"name\">mime-type</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mime-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;welcome-file-list></p>\n</blockquote>\n<p>welcome-file-list包含一个子元素welcome-file，用来定义首页列表。</p>\n<p>welcome-file用来指定首页文件名称，服务器会按照设定的顺序来找首页。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.html<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;error-page></p>\n</blockquote>\n<p>error-page元素包含三个子元素error-code，exception-type和location。</p>\n<p>将错误代码后异常的种类对应到web应用资源路径。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>404<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>error404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">exception-type</span>&gt;</span>java.lang.Exception<span class=\"tag\">&lt;/<span class=\"name\">exception-type</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>error404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;jsp-config></p>\n</blockquote>\n<p>jsp-config元素主要用来设定jsp的相关配置，jsp-config包括taglib和jsp-property-group两个子元素，其中taglib元素在JSP1.2时就已经存在，而jsp-property-group是JSP2.0新增的元素。</p>\n<p>\\&lt;taglib></p>\n<p>taglib元素包含两个子元素taglib-uri和taglib-location，用来设定JSP网页用到的TagLibrary路径。</p>\n<p>\\&lt;taglib-uri>URI\\&lt;/taglib-uri></p>\n<p>taglib-uri定义TLD文件的URI，JSP网页的taglib指令可以经由这个URI存取到TLD文件。</p>\n<p>\\&lt;taglib-location>/WEB-INF/lib/xxx.tld\\&lt;/taglib-location></p>\n<p>TLD文件对应web应用的存放位置。</p>\n<p>\\&lt;jsp-property-group></p>\n<p>jsp-property-group元素包含8个子元素，分别为：</p>\n<p>\\&lt;description>Description\\&lt;/description> 此设定的说明</p>\n<p>\\&lt;display-name>Name\\&lt;/display-name>  此设定的名称</p>\n<p>\\&lt;url-pattern>URL\\&lt;/url-pattern>  设定值所影响的范围，如*.jsp</p>\n<p>\\<el-ignored>true/false\\&lt;/el-ignored>  是否支持EL语法</el-ignored></p>\n<p>\\&lt;scripting-invalid>true/false\\&lt;/scripting-invalid>  是否支持java代码片段&lt;%…%&gt;</p>\n<p>\\&lt;page-encoding>UTF-8\\&lt;/page-encoding> 设置JSP页面的编码</p>\n<p>\\&lt;include-prelude>.jspf\\&lt;/include-prelude> 设置JSP页面的抬头，扩展名为.jspf</p>\n<p>\\<include-coda>.jspf\\</include-coda> 设置JSP页面的结尾，扩展名为.jspf</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp-config</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">taglib</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">taglib-uri</span>&gt;</span>Taglib<span class=\"tag\">&lt;/<span class=\"name\">taglib-uri</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">taglib-location</span>&gt;</span>/WEB-INF/tlds/MyTaglib.tld<span class=\"tag\">&lt;/<span class=\"name\">taglib-location</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">taglib</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jsp-property-group</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Configuration JSP example<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>JspConfig<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">el-ignored</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">el-ignored</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">page-encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">page-encoding</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scripting-invalid</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">scripting-invalid</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jsp-property-group</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>\\&lt;resource-ref></p>\n</blockquote>\n<p>resource-ref元素包含五个子元素description，res-ref-name，res-type，res-auth，res-sharing-scope，利用JNDI取得应用可利用资源。</p>\n<p>\\&lt;res-auth>Application/Container\\&lt;/res-auth> 资源由Application或Container来许可。</p>\n<p>\\<res-sharing-scope>Shareable|Unshareable\\<res-sharing-scope> 资源是否可以共享，默认值为Shareable</res-sharing-scope></res-sharing-scope></p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource-ref</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">res-ref-name</span>&gt;</span>jdbc/Druid<span class=\"tag\">&lt;/<span class=\"name\">res-ref-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">res-type</span>&gt;</span>com.alibaba.druid.pool.DruidDataSource<span class=\"tag\">&lt;/<span class=\"name\">res-type</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">res-auth</span>&gt;</span>Container<span class=\"tag\">&lt;/<span class=\"name\">res-auth</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resource-ref</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-7-loggin-properties\"><a href=\"#1-7-loggin-properties\" class=\"headerlink\" title=\"1.7 loggin.properties\"></a>1.7 loggin.properties</h3><p>JULI记录器使用默认日志配置，它默认地使用ConsoleHandler和fileHandler设置应用程序或者程序包的日志级别。</p>\n<h2 id=\"2-启动流程分析\"><a href=\"#2-启动流程分析\" class=\"headerlink\" title=\"2. 启动流程分析\"></a>2. 启动流程分析</h2><h3 id=\"2-1-Idea调试Tomcat源码环境搭建\"><a href=\"#2-1-Idea调试Tomcat源码环境搭建\" class=\"headerlink\" title=\"2.1 Idea调试Tomcat源码环境搭建\"></a>2.1 Idea调试Tomcat源码环境搭建</h3><p>首先下载Tomcat源码，读者可自行去<a href=\"http://tomcat.apache.org/\" target=\"_blank\" rel=\"noopener\">Tomcat官网</a> 下载，若执行力差的同学也可直接从此处pull。</p>\n<p>Tomcat源码导入到开发工具中的方法有多种，笔者采用最直接的方式，解压源码包后直接导入到开发工具中，导入之后的源码并不能直接运行，还需要几个依赖包，读者可从此处的lib目录下获取，也可自行搜集。</p>\n<p>找好依赖包也并不能让Tomcat源码正常运行，还需要为Bootstrap这个启动类增加几个启动参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dcatalina.home=/Users/chenmin/GitHub/tomcat</span><br><span class=\"line\">-Dcatalina.base=/Users/chenmin/GitHub/tomcat</span><br><span class=\"line\">-Djava.endorsed.dirs=/Users/chenmin/GitHub/tomcat/endorsed</span><br><span class=\"line\">-Djava.io.tmpdir=/Users/chenmin/GitHub/tomcat/temp</span><br><span class=\"line\">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">-Djava.util.logging.config.file=/Users/chenmin/GitHub/tomcat/conf/logging.properties</span><br></pre></td></tr></table></figure>\n<p>上面的参数具体代表的意思就不一一详述了，其实光看名字就知道都是干嘛用的了。</p>\n<p>以上准备步骤做好之后，就可以直接运行Bootstrap类，运行Tomcat源码进行调试了。</p>\n<h3 id=\"2-2-Tomcat-Server的组成\"><a href=\"#2-2-Tomcat-Server的组成\" class=\"headerlink\" title=\"2.2 Tomcat Server的组成\"></a>2.2 Tomcat Server的组成</h3><h4 id=\"2-2-1-整体说明\"><a href=\"#2-2-1-整体说明\" class=\"headerlink\" title=\"2.2.1 整体说明\"></a>2.2.1 整体说明</h4><p>在上面对配置文件的说明中，通过server.xml的解释，我们知道server.xml中最顶级的元素是server，而server.xml中的每一个元素我们都可以把它看做是Tomcat中的某一个部分。所以我们可以参照着server.xml来分析源码。</p>\n<p>Tomcat最顶层的容器叫Server，它代表着整个Tomcat服务器。Server中至少要包含一个Service来提供服务。Service包含两部分：Connector和Container。Connector负责网络连接，request/response的创建，并对Socket和request、response进行转换等，Container用于封装和管理Servlet，并处理具体的request请求。</p>\n<p>一个Tomcat中只有一个Server，一个Server可以有多个Service来提供服务，一个Service只有一个Container，但是可以有多个Connector（一个服务可以有多个连接）。</p>\n<p><img src=\"https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"tomcat整体结构\"></p>\n<h4 id=\"2-2-2-各组件详解\"><a href=\"#2-2-2-各组件详解\" class=\"headerlink\" title=\"2.2.2 各组件详解\"></a>2.2.2 各组件详解</h4><p>可结合conf/配置文件说明中的server.xml的说明来看</p>\n<ul>\n<li><p>Server</p>\n<p>Server代表整个Servlet容器</p>\n</li>\n<li><p>Service</p>\n<p>Service是由一个或多个Connector以及一个Engine，负责处理所有Connector所获得的客户请求的集合。</p>\n</li>\n<li><p>Connector</p>\n<p>Connector将在某个指定端口上侦听客户请求，并将获得的请求交给Engine来处理，从Engine处获得回应并返回给客户端。</p>\n<p>Tomcat有两个默认的Connector，一个直接监听来自浏览器的http请求，一个监听来自其他WebServer的请求。</p>\n<p>Coyote Http/1.1 Connector在端口8080上监听来自浏览器的http请求</p>\n<p>Coyote AJP/1.3 Connector在端口8009上监听来自其他WebServer的servlet/jsp代理请求。</p>\n</li>\n<li><p>Engine</p>\n<p>Engine下可以配置多个虚拟主机，每个虚拟主机都有一个域名，当Engine获得一个请求时，Engine会把该请求匹配到某个Host上，然后把该请求交给该Host来处理。</p>\n<p>Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。</p>\n</li>\n<li><p>Host</p>\n<p>代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配。每个虚拟主机下都可以部署一个或者多个WebApp，每个WebApp对应于一个Context，有一个ContextPath。当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。匹配的方法是“最长匹配”，所以一个path==“”的Context将成为该Host的默认Context，所有无法和其他Context的路径名匹配的请求都将最终和该默认Context匹配。</p>\n</li>\n<li><p>Context</p>\n<p>一个Context对应于一个Web Application（Web应用），一个Web应用有一个或多个Servlet组成，Context在创建的时候将根据配置文件\\$CATALINA_HOME/conf/web.xml和\\$WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。如果找到，则执行该类，获得请求的回应，并返回。</p>\n<p>Tomcat各组件关系图(此图来此网上)</p>\n<p><img src=\"https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat-startup.gif?raw=true\" alt=\"QQ截图20170913174040\"></p>\n</li>\n</ul>\n<h3 id=\"2-3-源码分析\"><a href=\"#2-3-源码分析\" class=\"headerlink\" title=\"2.3 源码分析\"></a>2.3 源码分析</h3><h4 id=\"2-3-1-启动总体流程\"><a href=\"#2-3-1-启动总体流程\" class=\"headerlink\" title=\"2.3.1 启动总体流程\"></a>2.3.1 启动总体流程</h4><p>Tomcat里的Server由org.apache.catalina.startup.Catalina来管理，Catalina是整个Tomcat的管理类，它里面的三个方法load，start，stop分别用来管理整个服务器的生命周期，load方法用于根据conf/server.xml文件创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器，start和stop方法在内部分别调用了Server的start和stop方法，load方法内部调用了Server的init方法，这三个方法都会按容器的结构逐层调用相应的方法，比如，Server的start方法中会调用所有的Service中的start方法，Service中的start方法又会调用所有的Service中的start方法，Service中的start方法又会调用所有包含的Connectors和Container的start方法，这样这个服务器就启动了，init和stop方法也一样，这就是整个Tomcat的生命周期的管理方式。Catalina还有个await方法，await方法直接调用了Server的await方法，这个方法的作用是进入一个循环，让主线程不退出。</p>\n<p>Tomcat的启动入口上面说过，是org.apache.catalina.startup.Bootstrap，作用类似于一个CatalinaAdaptor，具体的处理过程还是使用Catalina来完成的，这么做的好处是可以把启动的入口和具体的管理类分开，从而可以很方便的创建出多种启动方式，每种启动方式只需要写一个相应的CatalinaAdaptor就可以了。</p>\n<p><img src=\"https://github.com/ArtIsLong/apache-tomcat-8.5.16-src/blob/master/resources/images/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png?raw=true\" alt=\"tomcat启动流程分析\"></p>\n<p><em>注：</em>图片比较模糊，如需查看清晰图片，请自行下载resources/images目录中的<strong>tomcat启动流程分析.png</strong> 或 resources/docs中的<strong>Tomcat源码分析.mdl</strong> ，使用Rational Rose等工具打开即可。</p>\n<h4 id=\"2-3-2-启动流程详解\"><a href=\"#2-3-2-启动流程详解\" class=\"headerlink\" title=\"2.3.2 启动流程详解\"></a>2.3.2 启动流程详解</h4><p>正常情况下启动Tomcat，就是调用Bootstrap的main方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (daemon == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Don't set daemon until init() has completed</span></span><br><span class=\"line\">            <span class=\"comment\">// 初始化了ClassLoader，并用ClassLoader创建了Catalina实例，赋给catalinaDaemon变量</span></span><br><span class=\"line\">            Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                bootstrap.init();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                handleThrowable(t);</span><br><span class=\"line\">                t.printStackTrace();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            daemon = bootstrap;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// When running as a service the call to stop will be on a new</span></span><br><span class=\"line\">            <span class=\"comment\">// thread so make sure the correct class loader is used to prevent</span></span><br><span class=\"line\">            <span class=\"comment\">// a range of class not found exceptions.</span></span><br><span class=\"line\">            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String command = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                command = args[args.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (command.equals(<span class=\"string\">\"startd\"</span>)) &#123;</span><br><span class=\"line\">                args[args.length - <span class=\"number\">1</span>] = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">                daemon.load(args);</span><br><span class=\"line\">                daemon.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (command.equals(<span class=\"string\">\"stopd\"</span>)) &#123;</span><br><span class=\"line\">                args[args.length - <span class=\"number\">1</span>] = <span class=\"string\">\"stop\"</span>;</span><br><span class=\"line\">                daemon.stop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (command.equals(<span class=\"string\">\"start\"</span>)) &#123;</span><br><span class=\"line\">                daemon.setAwait(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                daemon.load(args);</span><br><span class=\"line\">                daemon.start();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (command.equals(<span class=\"string\">\"stop\"</span>)) &#123;</span><br><span class=\"line\">                daemon.stopServer(args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (command.equals(<span class=\"string\">\"configtest\"</span>)) &#123;</span><br><span class=\"line\">                daemon.load(args);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>==daemon.getServer()) &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">\"Bootstrap: command \\\"\"</span> + command + <span class=\"string\">\"\\\" does not exist.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Unwrap the Exception for clearer error reporting</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t <span class=\"keyword\">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class=\"line\">                    t.getCause() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                t = t.getCause();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handleThrowable(t);</span><br><span class=\"line\">            t.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>main方法中，首先执行init方法初始化了Tomcat自己的类加载器，并通过类加载器创建Catalina实例，然后赋给catalinaDaemon变量，后续操作都使用catalinaDaemon来执行。</p>\n<p>后面默认执行start命令，将调用setAwait(true)，load(args)和start()这三个方法，这三个方法内部都通过反射调用了Catalina的相应方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.apache.catalina.startup.Catalina</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAwait</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    await = b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setAwait方法用于设置Server启动完成后是否进入等待状态的标志，如果为true则进入，否则不进入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.apache.catalina.startup.Catalina</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Start a new server instance.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">    initDirs();</span><br><span class=\"line\">    <span class=\"comment\">// Before digester - it may be needed</span></span><br><span class=\"line\">    initNaming();</span><br><span class=\"line\">    <span class=\"comment\">// Create and execute our Digester</span></span><br><span class=\"line\">    Digester digester = createStartDigester();</span><br><span class=\"line\">    InputSource inputSource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    InputStream inputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    File file = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            file = configFile();</span><br><span class=\"line\">            inputStream = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">            inputSource = <span class=\"keyword\">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          \t<span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">            \tlog.debug(sm.getString(<span class=\"string\">\"catalina.configFail\"</span>, file), e);</span><br><span class=\"line\">          \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (inputStream == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          \t\tinputStream = getClass().getClassLoader().getResourceAsStream(getConfigFile());</span><br><span class=\"line\">          \t\tinputSource = <span class=\"keyword\">new</span> InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString());</span><br><span class=\"line\">        \t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          \t\t<span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">            \t\tlog.debug(sm.getString(<span class=\"string\">\"catalina.configFail\"</span>,getConfigFile()), e);</span><br><span class=\"line\">          \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// This should be included in catalina.jar</span></span><br><span class=\"line\">      \t<span class=\"comment\">// Alternative: don't bother with xml, just create it manually.</span></span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (inputStream == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          \t\tinputStream = getClass().getClassLoader().getResourceAsStream(<span class=\"string\">\"server-embed.xml\"</span>);</span><br><span class=\"line\">          \t\tinputSource = <span class=\"keyword\">new</span> InputSource(getClass().getClassLoader().getResource(<span class=\"string\">\"server-embed.xml\"</span>).toString());</span><br><span class=\"line\">        \t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          \t\t<span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</span><br><span class=\"line\">            \t\tlog.debug(sm.getString(<span class=\"string\">\"catalina.configFail\"</span>,<span class=\"string\">\"server-embed.xml\"</span>), e);</span><br><span class=\"line\">          \t\t&#125;</span><br><span class=\"line\">        \t&#125;\t</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (inputStream == <span class=\"keyword\">null</span> || inputSource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>  (file == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t\tlog.warn(sm.getString(<span class=\"string\">\"catalina.configFail\"</span>,getConfigFile() + <span class=\"string\">\"] or [server-embed.xml]\"</span>));</span><br><span class=\"line\">        \t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          \t\tlog.warn(sm.getString(<span class=\"string\">\"catalina.configFail\"</span>,file.getAbsolutePath()));</span><br><span class=\"line\">          \t\t<span class=\"keyword\">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class=\"line\">            \t\tlog.warn(<span class=\"string\">\"Permissions incorrect, read permission is not allowed on the file.\"</span>);</span><br><span class=\"line\">          \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \tinputSource.setByteStream(inputStream);</span><br><span class=\"line\">        \tdigester.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        \tdigester.parse(inputSource);</span><br><span class=\"line\">      \t&#125; <span class=\"keyword\">catch</span> (SAXParseException spe) &#123;</span><br><span class=\"line\">        \tlog.warn(<span class=\"string\">\"Catalina.start using \"</span> + getConfigFile() + <span class=\"string\">\": \"</span> + spe.getMessage());</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">      \t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        \tlog.warn(<span class=\"string\">\"Catalina.start using \"</span> + getConfigFile() + <span class=\"string\">\": \"</span> , e);</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (inputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          \t\tinputStream.close();</span><br><span class=\"line\">        \t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// Ignore</span></span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \tgetServer().setCatalina(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  \tgetServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class=\"line\">  \tgetServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class=\"line\">  \t<span class=\"comment\">// Stream redirection</span></span><br><span class=\"line\">  \tinitStreams();</span><br><span class=\"line\">  \t<span class=\"comment\">// Start the new server</span></span><br><span class=\"line\">  \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    \tgetServer().init();</span><br><span class=\"line\">  \t&#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (Boolean.getBoolean(<span class=\"string\">\"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\"</span>)) &#123;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> java.lang.Error(e);</span><br><span class=\"line\">    \t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \t\tlog.error(<span class=\"string\">\"Catalina.start\"</span>, e);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">long</span> t2 = System.nanoTime();</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(log.isInfoEnabled()) &#123;</span><br><span class=\"line\">    \tlog.info(<span class=\"string\">\"Initialization processed in \"</span> + ((t2 - t1) / <span class=\"number\">1000000</span>) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Catalina的load方法根据conf/server.xml创建了Server对象，并赋值给server属性（具体是通过开源项目Digester完成的），然后调用了server的init方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.apache.catalina.startup.Catalina</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span> (getServer() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tload();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getServer() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        log.fatal(<span class=\"string\">\"Cannot start server. Server instance is not configured.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">    <span class=\"comment\">// Start the new server</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        getServer().start();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (LifecycleException e) &#123;</span><br><span class=\"line\">        log.fatal(sm.getString(<span class=\"string\">\"catalina.serverStartFail\"</span>), e);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getServer().destroy();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (LifecycleException e1) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"destroy() failed for failed Server \"</span>, e1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> t2 = System.nanoTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(log.isInfoEnabled()) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"Server startup in \"</span> + ((t2 - t1) / <span class=\"number\">1000000</span>) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Register shutdown hook</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (useShutdownHook) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shutdownHook == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            shutdownHook = <span class=\"keyword\">new</span> CatalinaShutdownHook();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class=\"line\">        <span class=\"comment\">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class=\"line\">        <span class=\"comment\">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class=\"line\">        <span class=\"comment\">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class=\"line\">        LogManager logManager = LogManager.getLogManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logManager <span class=\"keyword\">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class=\"line\">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (await) &#123;</span><br><span class=\"line\">        await();</span><br><span class=\"line\">        stop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里首先判断Server是否已经存在了，如果不存在则调用load方法来初始化Server，然后调用Server的start方法来启动服务器，最后注册了关闭钩子并根据await属性判断是否进入等待状态，之前我们已经将这里的await属性设置为true，所以需要进入等待状态。进入等待状态会调用await和stop两个方法，await方法会直接调用Server的await方法，Server的await方法内部会执行一个while循环，这样程序就停到了await方法，当await方法里的while循环退出时，就会执行stop方法，从而关闭服务器。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.apache.catalina.core.StandardServer</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Negative values - don't wait on port - tomcat is embedded or we just don't like ports</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( port == -<span class=\"number\">2</span> ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// undocumented yet - for embedding apps that are around, alive.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( port==-<span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            awaitThread = Thread.currentThread();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stopAwait) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep( <span class=\"number\">10000</span> );</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>( InterruptedException ex ) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// continue and check the flag</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            awaitThread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set up a server socket to wait on</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        awaitSocket = <span class=\"keyword\">new</span> ServerSocket(port, <span class=\"number\">1</span>,InetAddress.getByName(address));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">\"StandardServer.await: create[\"</span> + address+ <span class=\"string\">\":\"</span> + port+ <span class=\"string\">\"]: \"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        awaitThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// Loop waiting for a connection and a valid command</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopAwait) &#123;</span><br><span class=\"line\">            ServerSocket serverSocket = awaitSocket;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (serverSocket == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// Wait for the next connection</span></span><br><span class=\"line\">            Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            StringBuilder command = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                InputStream stream;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> acceptStartTime = System.currentTimeMillis();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    socket = serverSocket.accept();</span><br><span class=\"line\">                    socket.setSoTimeout(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);  <span class=\"comment\">// Ten seconds</span></span><br><span class=\"line\">                    stream = socket.getInputStream();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SocketTimeoutException ste) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// This should never happen but bug 56684 suggests that</span></span><br><span class=\"line\">                    <span class=\"comment\">// it does.</span></span><br><span class=\"line\">                    log.warn(sm.getString(<span class=\"string\">\"standardServer.accept.timeout\"</span>,</span><br><span class=\"line\">                                Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste);</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (AccessControlException ace) &#123;</span><br><span class=\"line\">                    log.warn(<span class=\"string\">\"StandardServer.accept security exception: \"</span> + ace.getMessage(), ace);</span><br><span class=\"line\">                \t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (stopAwait) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Wait was aborted with socket.close()</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"StandardServer.await: accept: \"</span>, e);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Read a set of characters from the socket</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> expected = <span class=\"number\">1024</span>; <span class=\"comment\">// Cut off to avoid DoS attack</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (expected &lt; shutdown.length()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (random == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">                    expected += (random.nextInt() % <span class=\"number\">1024</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (expected &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ch = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        ch = stream.read();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        log.warn(<span class=\"string\">\"StandardServer.await: read: \"</span>, e);</span><br><span class=\"line\">                        ch = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// Control character or EOF (-1) terminates loop</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ch &lt; <span class=\"number\">32</span> || ch == <span class=\"number\">127</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    command.append((<span class=\"keyword\">char</span>) ch);</span><br><span class=\"line\">                    expected--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Close the socket now that we are done with it</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (socket != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        socket.close();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// Match against our command string</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> match = command.toString().equals(shutdown);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (match) &#123;                \t\t\t\t\t            </span><br><span class=\"line\">              \tlog.info(sm.getString(<span class=\"string\">\"standardServer.shutdownViaPort\"</span>));</span><br><span class=\"line\">\t        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                log.warn(<span class=\"string\">\"StandardServer.await: Invalid command '\"</span> + command.toString() + <span class=\"string\">\"' received\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ServerSocket serverSocket = awaitSocket;</span><br><span class=\"line\">        awaitThread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        awaitSocket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Close the server socket and return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (serverSocket != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                serverSocket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>#### </p>\n<h2 id=\"参考书籍\"><a href=\"#参考书籍\" class=\"headerlink\" title=\"参考书籍\"></a>参考书籍</h2><blockquote>\n<p> <a href=\"链接：http://pan.baidu.com/s/1o7Zp1Q6 密码：c87j\">看透springMvc源代码分析与实践.pdf</a></p>\n</blockquote>\n<h2 id=\"推荐博客\"><a href=\"#推荐博客\" class=\"headerlink\" title=\"推荐博客\"></a>推荐博客</h2><blockquote>\n<p><a href=\"http://www.jianshu.com/p/4cdc422b269b\" target=\"_blank\" rel=\"noopener\">解析XML之Digester</a></p>\n</blockquote>\n","slug":"Tomcat源码分析","updated":"2018-10-08T08:38:46.000Z","comments":true,"link":"","permalink":"/2018/03/21/Tomcat源码分析/","excerpt":"Tomcat目录说明","categories":[{"name":"中间件","slug":"中间件","permalink":"/categories/中间件/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"/tags/Tomcat/"}]},{"title":"redis常用配置","date":"2018-02-08T14:51:33.000Z","path":"2018/02/08/redis系统学习/","text":"1、基本配置 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程1daemonize no 当Redis以守护进程方式运行时，Redis会默认把pid写入/var/run/redis.pid文件，可以通过pidfile指定 1pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379 1port 6379 绑定主机地址 1bind 127.0.0.1 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 1timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose 1loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null 1logfile stdout 设置数据库的数量，默认数据库有16个（0-15），默认使用0，可以使用SELECT \\&lt;dbid> 命令在连接上指定数据库id 1databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 1save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件 123save 900 1save 300 10save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但是会导致数据库文件变大 1rdbcompression yes 指定本地数据库文件名，默认值为dump.rdb 1dbfilename dump.rdb 指定本地数据库存放目录 1dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 1slaveof &lt;masterip&gt; &lt;masterport&gt; 当master服务设置了密码保护时，slav服务连接master的密码 1masterauth &lt;master-password&gt; 如果配置了连接密码，客户端在链接Redis时需要通过AUTH \\&lt;password>命令提供密码，默认关闭 1requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不做限制。当客户端连接数达到限制时，Redis会关闭新的连接并像客户端返回max number of clients reached错误信息 1maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然达到最大内存限制，将无法再进行写操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放到swap区 1maxmemory &lt;bytes&gt; 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件同步的，所以有的数据会在一段时间内只存在于内存中，默认为no 1appendonly no 指定更新日志文件名，默认为appendonly.aof 1appendfilename &quot;appendonly.aof&quot; 指定更新日志条件，共有3个可选值 no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync() 将数据写到磁盘（慢，安全） everysec：表示每次同步一次（折衷，默认值） 1appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动缓存到内存中 1vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 1vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0 1vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，如果存储很多小对象，page大小最好设置为32或者64bytes，如果存储很多的大对象，则可以使用更大的page，如果不确定，就使用默认值 1vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存 1vm-pages 134217728 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4 1vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 1glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 12hash-max-zipmap-entries 64hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启 1activerehashing yes 2、常用操作（高级）Redis官网命令详解 2.1 事务操作Redis的事务也有两种，乐观锁和悲观锁。 悲观锁，直接给这个key加锁，这个key只能当前连接可以操作。 乐观锁，给这个key加锁，只要这个key的值没有更改就可以了。 Redis的事务中，默认启用的是乐观锁，只负责监测key有没有变动。 12345watch key1 key2 监听key有没有变化，如果有变化，则事务取消，在multi之前使用unwatch key1 key2 不加具体key时，取消所有key的监听。multi 开启事务...discard/exec 取消事务/提交事务 注意：如果在exec时，命令语法有问题，这时所有的语句都得不到执行。如果语法本身没问题，但是适用的对象有问题，exec之后，会执行正确的语句，并跳过有问题的语句。 2.2 消息的发布与订阅使用办法： 订阅端：subscribe 频道名称 psubscribe 支持表达式匹配的频道 返回值为订阅到消息的客户端数量 发布端：publish 频道名称 发布内容 2.3 Redis持久化配置 持久化 把数据存储于断电后不会丢失的设备中，通常是硬盘 常见的持久化方式 主从：通过主服务器往内存中写，从服务器做保存和持久化 日志：操作生成相关日志，并通过日志来恢复数据，couchDB对于数据内容，不修改，只追加，则文件本身就是日志，不会丢失数据。 2.3.1 rdb快照持久化 rdb工作原理 每隔N分钟或N次写操作后，从内存dump数据形成rdb文件，压缩放在备份目录 rdb快照相关参数 12345678save 900 1 #刷新快照到磁盘中，必须满足两者要求才会触发，即900秒之内至少1个关键字发生变化save 300 10 #必须是300秒之内至少10个关键字发生变化save 60 10000 #必须是60秒之内至少10000个关键字发生变化stop-writes-on-bgsave-error yes #后台存储错误停止写rdbrdbcompression yes #使用LZF压缩rdb文件rdbchecksum yes #导入rdb恢复时数据时，要不要校验rdb的完整性dbfilename dump.rdb #设置rdb文件名dir ./ #设置工作目录，rdb文件会写入该目录 rdb的缺陷 在上一个保存点刚结束，下个保存点还没到时如果断电，将会丢失1-N分钟的数据 rdb的优势 由于导出的是一个内存的二进制文件，所以rdb文件的恢复速度超级快 2.3.2 aof日志持久化 aof工作原理 redis客户端连接redis服务器后所进行的每一条命令的操作都逐条记录到aof日志中，在恢复数据时，只需要将日志中记录的命令都依次执行一遍即可。 aof配置参数 123456789appendonly yes #是否打开aof日志功能appendfilename &quot;appendonly.aof&quot; #设置aof文件名appendfsync everysec #折衷方案，每秒写一次appendfsync no #写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof，同步频率低，速度快appendfsync always #每一个命令都立即同步到aof，安全，速度慢no-appendfsync-on-rewrite no #正在到处rbd快照的过程中，要不要停止同步aofauto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小，增长率100%时进行重写auto-aof-rewrite-min-size 64mb #aof文件，至少超过64M时进行重写# 上面两个aof重写规则同时满足aof才会进行重写 aof的缺陷 由于项目使用redis，就是图redis的读写速度快，但是如果频繁写磁盘，也会拉低效率的，而且越往后，aof日志文件会越来越大的。 aof的优势 使用日志记录操作，能有效的保证数据的完整性，就算太巧合了，在刚执行了命令还没来得及同步aof时断电了，那也只会丢失当前的一条命令。 aof重写 把内存中的数据，逆化成命令写到aof日志里，以解决aof日志过大的问题。 2.3.3 总结1、在dump过程中，aof如果停止同步，数据不会丢失，因为所有的操作会缓存在队列里，dump完成后，统一操作 2、如果rdb和aof文件都存在，它会采用谁优先就用谁来恢复数据，也就是会用aof 3、对于rdb和aof两种持久化方式，没有绝对的谁好谁坏，所以可以两者同时用，效果更优 4、rdb和aof相比，rdb的数据恢复更快，因为rdb的数据是内存映射，可以直接载入到内存，而aof是一条条的命令，需要逐条执行 2.4 Redis主从复制此处使用 4.0.2 的版本，搭建一主两从的Redis集群。 环境准备 从此处下载redis-4.0.2.tar.gz，解压之后，编译源码进行安装。 1234$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz$ tar -zxvf redis-4.0.2.tar.gz$ cd redis-4.0.2$ make &amp;&amp; make install 在用户家目录下新建redis相关目录 12345$ cd ~$ make redis$ cd redis$ mkdir master# mkdir slave 然后拷贝redis-4.0.2目录中的redis.conf配置文件到master，修改为redis_master.conf，slave中拷贝两份，分别命名为redis_slave1.conf，redis_slave2.conf。 接下来修改配置文件内容（只贴出关键几个点，其他辅助内容请读者自行修改）：redis_master.conf 12port 7000daemonize yes redis_slave1.conf 123port 7001daemonize yesslaveof localhost 7000 redis_slave2.conf 123port 7002daemonize yesslaveof localhost 7000 分别启动三个节点： 123$ ./redis-4.0.2/src/redis-server ./master/redis_master.conf$ ./redis-4.0.2/src/redis-server ./slave/redis_slave1.conf$ ./redis-4.0.2/src/redis-server ./slave/redis_slave2.conf 登录进master节点，查看主从模式是否正常启动(主节点上能显示出两个从节点即可) 12$ ./redis-4.0.2/src/redis-cli&gt; info replication 2.5 三主三从三哨兵集群模式redis编译安装和上面一样 2.5.1 环境准备master 1192.168.10.100:6380,192.168.10.100:6381,192.168.10.100:6382 slave 1192.168.10.100:6383,192.168.10.100:6384,192.168.10.100:6385 sentinel 1192.168.10.100:26380,192.168.10.100:26381,192.168.10.100:26382 2.5.2 修改配置文件手动在服务器上新建6380,6381,6382,6383,6384,6385几个目录，将redis.conf配置文件每个目录拷贝一份（批量拷贝文件时，最好参考linux中xargs命令；当然，也可以cp多执行几次）。 redis.conf配置文件修改 1234567891011121314151617181920# 端口分别为6380,6381,6382,6383,6384,6385port 6380# 默认端口为127.0.0.1，改为本机地址则为任意服务器都可以访问，若只指定服务器访问，则改为指定服务器ip即可，由于当前是一台服务器上的伪集群，所以配置本机ip地址。bind 192.168.10.100# Redis后台运行daemonize yes# pidfile文件对应存放目录(redis节点进程号)pidfile /home/admin/redis/cluster/6380/redis.pid# 操作日志logfile &quot;/home/admin/redis/cluster/6380/redis.log&quot;# 数据文件存放目录dir /home/admin/redis/cluster/6380/# 是否开启集群(重点)cluster-enabled yes# 集群节点配置，集群首次启动自动生成cluster-config-file nodes.conf# 集群节点连接超时时间cluster-node-timeout 15000# aof日志开启，可做为日志记录，也可借此恢复数据appendonly yes 其他节点类似。 然后启动每一个节点 123456$ ./redis-4.0.2/src/redis-server ./cluster/7000/redis.conf$ ./redis-4.0.2/src/redis-server ./cluster/7001/redis.conf$ ./redis-4.0.2/src/redis-server ./cluster/7002/redis.conf$ ./redis-4.0.2/src/redis-server ./cluster/7003/redis.conf$ ./redis-4.0.2/src/redis-server ./cluster/7004/redis.conf$ ./redis-4.0.2/src/redis-server ./cluster/7005/redis.conf 2.5.3 创建集群这里创建集群借助于redis自己提供的一个集群创建工具redis-trib.rb（依赖于ruby环境） 1$ ./redis-4.0.2/src/redis-trib.rb create --replicas 1 192.168.10.100:6380 192.168.10.100:6381 192.168.10.100:6382 192.168.10.100:6383 192.168.10.100:6384 192.168.10.100:6385 根据提示完成集群创建 接下来验证集群是否搭建成功，连接其中一个节点 1234567891011121314$ ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 6380&gt; cluster nodesdcebbc47abd482363f221020dd1be714a498b841 192.168.10.110:6382 master - 01524568524063 3 connected 10923-1638333eaf24ca33b4f5bcc37c2a7434bddaf5432f057 192.168.10.110:6380 myself,master - 0 0 1connected 0-546051ed0849bf29de0221eb3b9b4ccbebfd341593ad 192.168.10.110:6384 slave409b146c1fc86acfd6198c491cf77eaf8c8c7c04 0 1524568525066 5 connectede29d4537e924f0e29f5155536a636b35a44a8c24 192.168.10.110:6383 slave33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 0 1524568523562 4 connecteddc4f070c42f9002e1c54bb6019ee4c34331570cc 192.168.10.110:6385 slavedcebbc47abd482363f221020dd1be714a498b841 0 1524568523062 6 connected409b146c1fc86acfd6198c491cf77eaf8c8c7c04 192.168.10.110:6381 master - 01524568524063 2 connected 5461-10922 输入info replication可查看节点信息。 2.5.4 哨兵搭建新建sentinel/26380,26381,26382目录，将redis家目录下的sentinel.conf文件拷贝到每个目录中 sentinel.conf 123456789bind 192.168.10.100port 26380daemonize yesdir &quot;/home/admin/redis/cluster/sentinel/26380&quot;# 故障转移配置# 表示哨兵集群中，至少有两个节点认为Redis节点挂掉，则将节点从集群中剔除sentinel monitor mymaster 192.168.10.100 6380 2sentinel config-epoch mymaster 0sentinel leader-epoch mymaster 0 其他的类似 启动哨兵 123$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26380/sentinel.conf$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26381/sentinel.conf$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26382/sentinel.conf 查看哨兵节点信息 12345678$ ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 26380&gt; info Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=cpicmaster,status=ok,address=192.168.10.110:6380,slaves=1,sentinels=3","raw":"---\n\nlayout: post\n\ntitle: redis常用配置\n\ntoc: true\n\ndate: 2018-02-08 22:51:33\n\ntags: Redis\n\ncategories: Redis\n\ndescription:\n\n---\n\n## 1、基本配置\n\n> Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n<!--more-->\n~~~properties\ndaemonize no\n~~~\n\n> 当Redis以守护进程方式运行时，Redis会默认把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n\n~~~properties\npidfile /var/run/redis.pid\n~~~\n\n> 指定Redis监听端口，默认端口为6379\n\n~~~properties\nport 6379\n~~~\n\n> 绑定主机地址\n\n~~~properties\nbind 127.0.0.1\n~~~\n\n> 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n\n~~~properties\ntimeout 300\n~~~\n\n> 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n\n~~~properties\nloglevel verbose\n~~~\n\n> 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n\n~~~properties\nlogfile stdout\n~~~\n\n> 设置数据库的数量，默认数据库有16个（0-15），默认使用0，可以使用SELECT \\<dbid\\> 命令在连接上指定数据库id\n\n~~~properties\ndatabases 16\n~~~\n\n> 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n~~~properties\nsave <seconds> <changes>\n~~~\n\n> Redis默认配置文件中提供了三个条件\n\n~~~properties\nsave 900 1\nsave 300 10\nsave 60 10000\n~~~\n\n分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改\n\n> 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但是会导致数据库文件变大\n\n~~~properties\nrdbcompression yes\n~~~\n\n> 指定本地数据库文件名，默认值为dump.rdb\n\n~~~properties\ndbfilename dump.rdb\n~~~\n\n> 指定本地数据库存放目录\n\n~~~properties\ndir ./\n~~~\n\n> 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n~~~properties\nslaveof <masterip> <masterport>\n~~~\n\n> 当master服务设置了密码保护时，slav服务连接master的密码\n\n~~~properties\nmasterauth <master-password>\n~~~\n\n> 如果配置了连接密码，客户端在链接Redis时需要通过AUTH \\<password\\>命令提供密码，默认关闭\n\n~~~properties\nrequirepass foobared\n~~~\n\n> 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不做限制。当客户端连接数达到限制时，Redis会关闭新的连接并像客户端返回max number of clients reached错误信息\n\n~~~properties\nmaxclients 128\n~~~\n\n> 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然达到最大内存限制，将无法再进行写操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放到swap区\n\n~~~properties\nmaxmemory <bytes>\n~~~\n\n> 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件同步的，所以有的数据会在一段时间内只存在于内存中，默认为no\n\n~~~properties\nappendonly no\n~~~\n\n> 指定更新日志文件名，默认为appendonly.aof\n\n~~~properties\nappendfilename \"appendonly.aof\"\n~~~\n\n> 指定更新日志条件，共有3个可选值\n\nno：表示等操作系统进行数据缓存同步到磁盘（快）\n\nalways：表示每次更新操作后手动调用fsync() 将数据写到磁盘（慢，安全）\n\neverysec：表示每次同步一次（折衷，默认值）\n\n~~~properties\nappendfsync everysec\n~~~\n\n> 指定是否启用虚拟内存机制，默认值为no，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动缓存到内存中\n\n~~~properties\nvm-enabled no\n~~~\n\n> 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n\n~~~properties\nvm-swap-file /tmp/redis.swap\n~~~\n\n> 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0\n\n~~~properties\nvm-max-memory 0\n~~~\n\n> Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，如果存储很多小对象，page大小最好设置为32或者64bytes，如果存储很多的大对象，则可以使用更大的page，如果不确定，就使用默认值\n\n~~~properties\nvm-page-size 32\n~~~\n\n> 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存\n\n~~~properties\nvm-pages 134217728\n~~~\n\n> 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4\n\n~~~properties\nvm-max-threads 4\n~~~\n\n> 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n\n~~~properties\nglueoutputbuf yes\n~~~\n\n> 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n~~~properties\nhash-max-zipmap-entries 64\nhash-max-zipmap-value 512\n~~~\n\n> 指定是否激活重置哈希，默认为开启\n\n~~~properties\nactiverehashing yes\n~~~\n\n## 2、常用操作（高级）\n\n[Redis官网命令详解](https://redis.io/commands)\n\n### 2.1 事务操作\n\nRedis的事务也有两种，乐观锁和悲观锁。\n\n悲观锁，直接给这个key加锁，这个key只能当前连接可以操作。\n\n乐观锁，给这个key加锁，只要这个key的值没有更改就可以了。\n\nRedis的事务中，默认启用的是乐观锁，只负责监测key有没有变动。\n\n~~~properties\nwatch key1 key2  监听key有没有变化，如果有变化，则事务取消，在multi之前使用\nunwatch key1 key2  不加具体key时，取消所有key的监听。\nmulti  开启事务\n...\ndiscard/exec  取消事务/提交事务\n~~~\n\n注意：如果在exec时，命令语法有问题，这时所有的语句都得不到执行。如果语法本身没问题，但是适用的对象有问题，exec之后，会执行正确的语句，并跳过有问题的语句。\n\n### 2.2 消息的发布与订阅\n\n使用办法：\n\n订阅端：subscribe  频道名称\n\npsubscribe 支持表达式匹配的频道\n\n返回值为订阅到消息的客户端数量\n\n发布端：publish  频道名称  发布内容\n\n### 2.3 Redis持久化配置\n\n> 持久化\n\n把数据存储于断电后不会丢失的设备中，通常是硬盘\n\n> 常见的持久化方式\n\n主从：通过主服务器往内存中写，从服务器做保存和持久化\n\n日志：操作生成相关日志，并通过日志来恢复数据，couchDB对于数据内容，不修改，只追加，则文件本身就是日志，不会丢失数据。\n\n#### 2.3.1 rdb快照持久化\n\n> rdb工作原理\n\n每隔N分钟或N次写操作后，从内存dump数据形成rdb文件，压缩放在备份目录\n\n> rdb快照相关参数\n\n~~~properties\nsave 900 1 #刷新快照到磁盘中，必须满足两者要求才会触发，即900秒之内至少1个关键字发生变化\nsave 300 10 #必须是300秒之内至少10个关键字发生变化\nsave 60 10000 #必须是60秒之内至少10000个关键字发生变化\nstop-writes-on-bgsave-error yes #后台存储错误停止写rdb\nrdbcompression yes #使用LZF压缩rdb文件\nrdbchecksum yes #导入rdb恢复时数据时，要不要校验rdb的完整性\ndbfilename dump.rdb #设置rdb文件名\ndir ./ #设置工作目录，rdb文件会写入该目录\n~~~\n\n> rdb的缺陷\n\n在上一个保存点刚结束，下个保存点还没到时如果断电，将会丢失1-N分钟的数据\n\n> rdb的优势\n\n由于导出的是一个内存的二进制文件，所以rdb文件的恢复速度超级快\n\n#### 2.3.2 aof日志持久化\n\n> aof工作原理\n\nredis客户端连接redis服务器后所进行的每一条命令的操作都逐条记录到aof日志中，在恢复数据时，只需要将日志中记录的命令都依次执行一遍即可。\n\n> aof配置参数\n\n~~~properties\nappendonly yes #是否打开aof日志功能\nappendfilename \"appendonly.aof\"  #设置aof文件名\nappendfsync everysec #折衷方案，每秒写一次\nappendfsync no #写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof，同步频率低，速度快\nappendfsync always #每一个命令都立即同步到aof，安全，速度慢\nno-appendfsync-on-rewrite no #正在到处rbd快照的过程中，要不要停止同步aof\nauto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小，增长率100%时进行重写\nauto-aof-rewrite-min-size 64mb  #aof文件，至少超过64M时进行重写\n# 上面两个aof重写规则同时满足aof才会进行重写\n~~~\n\n> aof的缺陷\n\n由于项目使用redis，就是图redis的读写速度快，但是如果频繁写磁盘，也会拉低效率的，而且越往后，aof日志文件会越来越大的。\n\n> aof的优势\n\n使用日志记录操作，能有效的保证数据的完整性，就算太巧合了，在刚执行了命令还没来得及同步aof时断电了，那也只会丢失当前的一条命令。\n\n> aof重写\n\n把内存中的数据，逆化成命令写到aof日志里，以解决aof日志过大的问题。\n\n#### 2.3.3 总结\n\n1、在dump过程中，aof如果停止同步，数据不会丢失，因为所有的操作会缓存在队列里，dump完成后，统一操作\n\n2、如果rdb和aof文件都存在，它会采用谁优先就用谁来恢复数据，也就是会用aof\n\n3、对于rdb和aof两种持久化方式，没有绝对的谁好谁坏，所以可以两者同时用，效果更优\n\n4、rdb和aof相比，rdb的数据恢复更快，因为rdb的数据是内存映射，可以直接载入到内存，而aof是一条条的命令，需要逐条执行\n\n### 2.4 Redis主从复制\n\n此处使用 4.0.2 的版本，搭建一主两从的Redis集群。\n\n> 环境准备\n\n从[此处](http://download.redis.io/releases/redis-4.0.2.tar.gz)下载redis-4.0.2.tar.gz，解压之后，编译源码进行安装。\n\n~~~shell\n$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz\n$ tar -zxvf redis-4.0.2.tar.gz\n$ cd redis-4.0.2\n$ make && make install\n~~~\n\n在用户家目录下新建redis相关目录\n\n```shell\n$ cd ~\n$ make redis\n$ cd redis\n$ mkdir master\n# mkdir slave\n```\n\n然后拷贝redis-4.0.2目录中的redis.conf配置文件到master，修改为redis_master.conf，slave中拷贝两份，分别命名为redis_slave1.conf，redis_slave2.conf。\n\n接下来修改配置文件内容（只贴出关键几个点，其他辅助内容请读者自行修改）：redis_master.conf\n\n~~~properties\nport 7000\ndaemonize yes\n~~~\n\nredis_slave1.conf\n\n~~~properties\nport 7001\ndaemonize yes\nslaveof localhost 7000\n~~~\n\nredis_slave2.conf\n\n```properties\nport 7002\ndaemonize yes\nslaveof localhost 7000\n```\n\n分别启动三个节点：\n\n~~~shell\n$ ./redis-4.0.2/src/redis-server ./master/redis_master.conf\n$ ./redis-4.0.2/src/redis-server ./slave/redis_slave1.conf\n$ ./redis-4.0.2/src/redis-server ./slave/redis_slave2.conf\n~~~\n\n登录进master节点，查看主从模式是否正常启动(主节点上能显示出两个从节点即可)\n\n~~~shell\n$ ./redis-4.0.2/src/redis-cli\n> info replication\n~~~\n\n### 2.5 三主三从三哨兵集群模式\n\nredis编译安装和上面一样\n\n#### 2.5.1 环境准备\n\nmaster\n\n```\n192.168.10.100:6380,192.168.10.100:6381,192.168.10.100:6382\n```\n\nslave\n\n```\n192.168.10.100:6383,192.168.10.100:6384,192.168.10.100:6385\n```\n\nsentinel\n\n```\n192.168.10.100:26380,192.168.10.100:26381,192.168.10.100:26382\n```\n\n#### 2.5.2 修改配置文件\n\n手动在服务器上新建6380,6381,6382,6383,6384,6385几个目录，将redis.conf配置文件每个目录拷贝一份（批量拷贝文件时，最好参考linux中xargs命令；当然，也可以cp多执行几次）。\n\nredis.conf配置文件修改\n\n```properties\n# 端口分别为6380,6381,6382,6383,6384,6385\nport 6380\n# 默认端口为127.0.0.1，改为本机地址则为任意服务器都可以访问，若只指定服务器访问，则改为指定服务器ip即可，由于当前是一台服务器上的伪集群，所以配置本机ip地址。\nbind 192.168.10.100\n# Redis后台运行\ndaemonize yes\n# pidfile文件对应存放目录(redis节点进程号)\npidfile /home/admin/redis/cluster/6380/redis.pid\n# 操作日志\nlogfile \"/home/admin/redis/cluster/6380/redis.log\"\n# 数据文件存放目录\ndir /home/admin/redis/cluster/6380/\n# 是否开启集群(重点)\ncluster-enabled yes\n# 集群节点配置，集群首次启动自动生成\ncluster-config-file nodes.conf\n# 集群节点连接超时时间\ncluster-node-timeout 15000\n# aof日志开启，可做为日志记录，也可借此恢复数据\nappendonly yes\n```\n\n其他节点类似。\n\n然后启动每一个节点\n\n```shell\n$ ./redis-4.0.2/src/redis-server ./cluster/7000/redis.conf\n$ ./redis-4.0.2/src/redis-server ./cluster/7001/redis.conf\n$ ./redis-4.0.2/src/redis-server ./cluster/7002/redis.conf\n$ ./redis-4.0.2/src/redis-server ./cluster/7003/redis.conf\n$ ./redis-4.0.2/src/redis-server ./cluster/7004/redis.conf\n$ ./redis-4.0.2/src/redis-server ./cluster/7005/redis.conf\n```\n\n#### 2.5.3 创建集群\n\n这里创建集群借助于redis自己提供的一个集群创建工具redis-trib.rb（依赖于ruby环境）\n\n```shell\n$ ./redis-4.0.2/src/redis-trib.rb create --replicas 1 192.168.10.100:6380 192.168.10.100:6381 192.168.10.100:6382 192.168.10.100:6383 192.168.10.100:6384 192.168.10.100:6385\n```\n\n根据提示完成集群创建\n\n接下来验证集群是否搭建成功，连接其中一个节点\n\n```shell\n$ ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 6380\n> cluster nodes\ndcebbc47abd482363f221020dd1be714a498b841 192.168.10.110:6382 master - 0\n1524568524063 3 connected 10923-16383\n33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 192.168.10.110:6380 myself,master - 0 0 1\nconnected 0-5460\n51ed0849bf29de0221eb3b9b4ccbebfd341593ad 192.168.10.110:6384 slave\n409b146c1fc86acfd6198c491cf77eaf8c8c7c04 0 1524568525066 5 connected\ne29d4537e924f0e29f5155536a636b35a44a8c24 192.168.10.110:6383 slave\n33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 0 1524568523562 4 connected\ndc4f070c42f9002e1c54bb6019ee4c34331570cc 192.168.10.110:6385 slave\ndcebbc47abd482363f221020dd1be714a498b841 0 1524568523062 6 connected\n409b146c1fc86acfd6198c491cf77eaf8c8c7c04 192.168.10.110:6381 master - 0\n1524568524063 2 connected 5461-10922\n```\n\n输入info replication可查看节点信息。\n\n#### 2.5.4 哨兵搭建\n\n新建sentinel/26380,26381,26382目录，将redis家目录下的sentinel.conf文件拷贝到每个目录中\n\nsentinel.conf\n\n```properties\nbind 192.168.10.100\nport 26380\ndaemonize yes\ndir \"/home/admin/redis/cluster/sentinel/26380\"\n# 故障转移配置\n# 表示哨兵集群中，至少有两个节点认为Redis节点挂掉，则将节点从集群中剔除\nsentinel monitor mymaster 192.168.10.100 6380 2\nsentinel config-epoch mymaster 0\nsentinel leader-epoch mymaster 0\n```\n\n其他的类似\n\n启动哨兵\n\n```shell\n$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26380/sentinel.conf\n$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26381/sentinel.conf\n$ ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26382/sentinel.conf\n```\n\n查看哨兵节点信息\n\n```shell\n$ ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 26380\n> info Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=cpicmaster,status=ok,address=192.168.10.110:6380,slaves=1,sentinels=3\n```\n\n\n\n","content":"<h2 id=\"1、基本配置\"><a href=\"#1、基本配置\" class=\"headerlink\" title=\"1、基本配置\"></a>1、基本配置</h2><blockquote>\n<p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daemonize no</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>当Redis以守护进程方式运行时，Redis会默认把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定Redis监听端口，默认端口为6379</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 6379</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>绑定主机地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout 300</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loglevel verbose</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logfile stdout</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置数据库的数量，默认数据库有16个（0-15），默认使用0，可以使用SELECT \\&lt;dbid> 命令在连接上指定数据库id</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">databases 16</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save &lt;seconds&gt; &lt;changes&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Redis默认配置文件中提供了三个条件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<p>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改</p>\n<blockquote>\n<p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但是会导致数据库文件变大</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rdbcompression yes</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定本地数据库文件名，默认值为dump.rdb</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定本地数据库存放目录</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir ./</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当master服务设置了密码保护时，slav服务连接master的密码</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果配置了连接密码，客户端在链接Redis时需要通过AUTH \\&lt;password>命令提供密码，默认关闭</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requirepass foobared</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0，表示不做限制。当客户端连接数达到限制时，Redis会关闭新的连接并像客户端返回max number of clients reached错误信息</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxclients 128</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然达到最大内存限制，将无法再进行写操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放到swap区</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件同步的，所以有的数据会在一段时间内只存在于内存中，默认为no</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly no</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定更新日志文件名，默认为appendonly.aof</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定更新日志条件，共有3个可选值</p>\n</blockquote>\n<p>no：表示等操作系统进行数据缓存同步到磁盘（快）</p>\n<p>always：表示每次更新操作后手动调用fsync() 将数据写到磁盘（慢，安全）</p>\n<p>everysec：表示每次同步一次（折衷，默认值）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendfsync everysec</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定是否启用虚拟内存机制，默认值为no，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动缓存到内存中</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-enabled no</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-swap-file /tmp/redis.swap</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-max-memory 0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，如果存储很多小对象，page大小最好设置为32或者64bytes，如果存储很多的大对象，则可以使用更大的page，如果不确定，就使用默认值</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-page-size 32</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-pages 134217728</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm-max-threads 4</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glueoutputbuf yes</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash-max-zipmap-entries 64</span><br><span class=\"line\">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定是否激活重置哈希，默认为开启</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activerehashing yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、常用操作（高级）\"><a href=\"#2、常用操作（高级）\" class=\"headerlink\" title=\"2、常用操作（高级）\"></a>2、常用操作（高级）</h2><p><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"noopener\">Redis官网命令详解</a></p>\n<h3 id=\"2-1-事务操作\"><a href=\"#2-1-事务操作\" class=\"headerlink\" title=\"2.1 事务操作\"></a>2.1 事务操作</h3><p>Redis的事务也有两种，乐观锁和悲观锁。</p>\n<p>悲观锁，直接给这个key加锁，这个key只能当前连接可以操作。</p>\n<p>乐观锁，给这个key加锁，只要这个key的值没有更改就可以了。</p>\n<p>Redis的事务中，默认启用的是乐观锁，只负责监测key有没有变动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch key1 key2  监听key有没有变化，如果有变化，则事务取消，在multi之前使用</span><br><span class=\"line\">unwatch key1 key2  不加具体key时，取消所有key的监听。</span><br><span class=\"line\">multi  开启事务</span><br><span class=\"line\">...</span><br><span class=\"line\">discard/exec  取消事务/提交事务</span><br></pre></td></tr></table></figure>\n<p>注意：如果在exec时，命令语法有问题，这时所有的语句都得不到执行。如果语法本身没问题，但是适用的对象有问题，exec之后，会执行正确的语句，并跳过有问题的语句。</p>\n<h3 id=\"2-2-消息的发布与订阅\"><a href=\"#2-2-消息的发布与订阅\" class=\"headerlink\" title=\"2.2 消息的发布与订阅\"></a>2.2 消息的发布与订阅</h3><p>使用办法：</p>\n<p>订阅端：subscribe  频道名称</p>\n<p>psubscribe 支持表达式匹配的频道</p>\n<p>返回值为订阅到消息的客户端数量</p>\n<p>发布端：publish  频道名称  发布内容</p>\n<h3 id=\"2-3-Redis持久化配置\"><a href=\"#2-3-Redis持久化配置\" class=\"headerlink\" title=\"2.3 Redis持久化配置\"></a>2.3 Redis持久化配置</h3><blockquote>\n<p>持久化</p>\n</blockquote>\n<p>把数据存储于断电后不会丢失的设备中，通常是硬盘</p>\n<blockquote>\n<p>常见的持久化方式</p>\n</blockquote>\n<p>主从：通过主服务器往内存中写，从服务器做保存和持久化</p>\n<p>日志：操作生成相关日志，并通过日志来恢复数据，couchDB对于数据内容，不修改，只追加，则文件本身就是日志，不会丢失数据。</p>\n<h4 id=\"2-3-1-rdb快照持久化\"><a href=\"#2-3-1-rdb快照持久化\" class=\"headerlink\" title=\"2.3.1 rdb快照持久化\"></a>2.3.1 rdb快照持久化</h4><blockquote>\n<p>rdb工作原理</p>\n</blockquote>\n<p>每隔N分钟或N次写操作后，从内存dump数据形成rdb文件，压缩放在备份目录</p>\n<blockquote>\n<p>rdb快照相关参数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1 #刷新快照到磁盘中，必须满足两者要求才会触发，即900秒之内至少1个关键字发生变化</span><br><span class=\"line\">save 300 10 #必须是300秒之内至少10个关键字发生变化</span><br><span class=\"line\">save 60 10000 #必须是60秒之内至少10000个关键字发生变化</span><br><span class=\"line\">stop-writes-on-bgsave-error yes #后台存储错误停止写rdb</span><br><span class=\"line\">rdbcompression yes #使用LZF压缩rdb文件</span><br><span class=\"line\">rdbchecksum yes #导入rdb恢复时数据时，要不要校验rdb的完整性</span><br><span class=\"line\">dbfilename dump.rdb #设置rdb文件名</span><br><span class=\"line\">dir ./ #设置工作目录，rdb文件会写入该目录</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rdb的缺陷</p>\n</blockquote>\n<p>在上一个保存点刚结束，下个保存点还没到时如果断电，将会丢失1-N分钟的数据</p>\n<blockquote>\n<p>rdb的优势</p>\n</blockquote>\n<p>由于导出的是一个内存的二进制文件，所以rdb文件的恢复速度超级快</p>\n<h4 id=\"2-3-2-aof日志持久化\"><a href=\"#2-3-2-aof日志持久化\" class=\"headerlink\" title=\"2.3.2 aof日志持久化\"></a>2.3.2 aof日志持久化</h4><blockquote>\n<p>aof工作原理</p>\n</blockquote>\n<p>redis客户端连接redis服务器后所进行的每一条命令的操作都逐条记录到aof日志中，在恢复数据时，只需要将日志中记录的命令都依次执行一遍即可。</p>\n<blockquote>\n<p>aof配置参数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes #是否打开aof日志功能</span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot;  #设置aof文件名</span><br><span class=\"line\">appendfsync everysec #折衷方案，每秒写一次</span><br><span class=\"line\">appendfsync no #写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof，同步频率低，速度快</span><br><span class=\"line\">appendfsync always #每一个命令都立即同步到aof，安全，速度慢</span><br><span class=\"line\">no-appendfsync-on-rewrite no #正在到处rbd快照的过程中，要不要停止同步aof</span><br><span class=\"line\">auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小，增长率100%时进行重写</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb  #aof文件，至少超过64M时进行重写</span><br><span class=\"line\"># 上面两个aof重写规则同时满足aof才会进行重写</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>aof的缺陷</p>\n</blockquote>\n<p>由于项目使用redis，就是图redis的读写速度快，但是如果频繁写磁盘，也会拉低效率的，而且越往后，aof日志文件会越来越大的。</p>\n<blockquote>\n<p>aof的优势</p>\n</blockquote>\n<p>使用日志记录操作，能有效的保证数据的完整性，就算太巧合了，在刚执行了命令还没来得及同步aof时断电了，那也只会丢失当前的一条命令。</p>\n<blockquote>\n<p>aof重写</p>\n</blockquote>\n<p>把内存中的数据，逆化成命令写到aof日志里，以解决aof日志过大的问题。</p>\n<h4 id=\"2-3-3-总结\"><a href=\"#2-3-3-总结\" class=\"headerlink\" title=\"2.3.3 总结\"></a>2.3.3 总结</h4><p>1、在dump过程中，aof如果停止同步，数据不会丢失，因为所有的操作会缓存在队列里，dump完成后，统一操作</p>\n<p>2、如果rdb和aof文件都存在，它会采用谁优先就用谁来恢复数据，也就是会用aof</p>\n<p>3、对于rdb和aof两种持久化方式，没有绝对的谁好谁坏，所以可以两者同时用，效果更优</p>\n<p>4、rdb和aof相比，rdb的数据恢复更快，因为rdb的数据是内存映射，可以直接载入到内存，而aof是一条条的命令，需要逐条执行</p>\n<h3 id=\"2-4-Redis主从复制\"><a href=\"#2-4-Redis主从复制\" class=\"headerlink\" title=\"2.4 Redis主从复制\"></a>2.4 Redis主从复制</h3><p>此处使用 4.0.2 的版本，搭建一主两从的Redis集群。</p>\n<blockquote>\n<p>环境准备</p>\n</blockquote>\n<p>从<a href=\"http://download.redis.io/releases/redis-4.0.2.tar.gz\" target=\"_blank\" rel=\"noopener\">此处</a>下载redis-4.0.2.tar.gz，解压之后，编译源码进行安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -zxvf redis-4.0.2.tar.gz</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> redis-4.0.2</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>\n<p>在用户家目录下新建redis相关目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> ~</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> make redis</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> redis</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir slave</span></span><br></pre></td></tr></table></figure>\n<p>然后拷贝redis-4.0.2目录中的redis.conf配置文件到master，修改为redis_master.conf，slave中拷贝两份，分别命名为redis_slave1.conf，redis_slave2.conf。</p>\n<p>接下来修改配置文件内容（只贴出关键几个点，其他辅助内容请读者自行修改）：redis_master.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7000</span><br><span class=\"line\">daemonize yes</span><br></pre></td></tr></table></figure>\n<p>redis_slave1.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7001</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\">slaveof localhost 7000</span><br></pre></td></tr></table></figure>\n<p>redis_slave2.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7002</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\">slaveof localhost 7000</span><br></pre></td></tr></table></figure>\n<p>分别启动三个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./master/redis_master.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./slave/redis_slave1.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./slave/redis_slave2.conf</span></span><br></pre></td></tr></table></figure>\n<p>登录进master节点，查看主从模式是否正常启动(主节点上能显示出两个从节点即可)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-cli</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> info replication</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-三主三从三哨兵集群模式\"><a href=\"#2-5-三主三从三哨兵集群模式\" class=\"headerlink\" title=\"2.5 三主三从三哨兵集群模式\"></a>2.5 三主三从三哨兵集群模式</h3><p>redis编译安装和上面一样</p>\n<h4 id=\"2-5-1-环境准备\"><a href=\"#2-5-1-环境准备\" class=\"headerlink\" title=\"2.5.1 环境准备\"></a>2.5.1 环境准备</h4><p>master</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6380</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6381</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6382</span></span><br></pre></td></tr></table></figure>\n<p>slave</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6383</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6384</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:6385</span></span><br></pre></td></tr></table></figure>\n<p>sentinel</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:26380</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:26381</span>,192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.10</span><span class=\"selector-class\">.100</span><span class=\"selector-pseudo\">:26382</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-修改配置文件\"><a href=\"#2-5-2-修改配置文件\" class=\"headerlink\" title=\"2.5.2 修改配置文件\"></a>2.5.2 修改配置文件</h4><p>手动在服务器上新建6380,6381,6382,6383,6384,6385几个目录，将redis.conf配置文件每个目录拷贝一份（批量拷贝文件时，最好参考linux中xargs命令；当然，也可以cp多执行几次）。</p>\n<p>redis.conf配置文件修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 端口分别为6380,6381,6382,6383,6384,6385</span><br><span class=\"line\">port 6380</span><br><span class=\"line\"># 默认端口为127.0.0.1，改为本机地址则为任意服务器都可以访问，若只指定服务器访问，则改为指定服务器ip即可，由于当前是一台服务器上的伪集群，所以配置本机ip地址。</span><br><span class=\"line\">bind 192.168.10.100</span><br><span class=\"line\"># Redis后台运行</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\"># pidfile文件对应存放目录(redis节点进程号)</span><br><span class=\"line\">pidfile /home/admin/redis/cluster/6380/redis.pid</span><br><span class=\"line\"># 操作日志</span><br><span class=\"line\">logfile &quot;/home/admin/redis/cluster/6380/redis.log&quot;</span><br><span class=\"line\"># 数据文件存放目录</span><br><span class=\"line\">dir /home/admin/redis/cluster/6380/</span><br><span class=\"line\"># 是否开启集群(重点)</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\"># 集群节点配置，集群首次启动自动生成</span><br><span class=\"line\">cluster-config-file nodes.conf</span><br><span class=\"line\"># 集群节点连接超时时间</span><br><span class=\"line\">cluster-node-timeout 15000</span><br><span class=\"line\"># aof日志开启，可做为日志记录，也可借此恢复数据</span><br><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<p>其他节点类似。</p>\n<p>然后启动每一个节点</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7000/redis.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7001/redis.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7002/redis.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7003/redis.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7004/redis.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-server ./cluster/7005/redis.conf</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-3-创建集群\"><a href=\"#2-5-3-创建集群\" class=\"headerlink\" title=\"2.5.3 创建集群\"></a>2.5.3 创建集群</h4><p>这里创建集群借助于redis自己提供的一个集群创建工具redis-trib.rb（依赖于ruby环境）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-trib.rb create --replicas 1 192.168.10.100:6380 192.168.10.100:6381 192.168.10.100:6382 192.168.10.100:6383 192.168.10.100:6384 192.168.10.100:6385</span></span><br></pre></td></tr></table></figure>\n<p>根据提示完成集群创建</p>\n<p>接下来验证集群是否搭建成功，连接其中一个节点</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 6380</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> cluster nodes</span></span><br><span class=\"line\">dcebbc47abd482363f221020dd1be714a498b841 192.168.10.110:6382 master - 0</span><br><span class=\"line\">1524568524063 3 connected 10923-16383</span><br><span class=\"line\">33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 192.168.10.110:6380 myself,master - 0 0 1</span><br><span class=\"line\">connected 0-5460</span><br><span class=\"line\">51ed0849bf29de0221eb3b9b4ccbebfd341593ad 192.168.10.110:6384 slave</span><br><span class=\"line\">409b146c1fc86acfd6198c491cf77eaf8c8c7c04 0 1524568525066 5 connected</span><br><span class=\"line\">e29d4537e924f0e29f5155536a636b35a44a8c24 192.168.10.110:6383 slave</span><br><span class=\"line\">33eaf24ca33b4f5bcc37c2a7434bddaf5432f057 0 1524568523562 4 connected</span><br><span class=\"line\">dc4f070c42f9002e1c54bb6019ee4c34331570cc 192.168.10.110:6385 slave</span><br><span class=\"line\">dcebbc47abd482363f221020dd1be714a498b841 0 1524568523062 6 connected</span><br><span class=\"line\">409b146c1fc86acfd6198c491cf77eaf8c8c7c04 192.168.10.110:6381 master - 0</span><br><span class=\"line\">1524568524063 2 connected 5461-10922</span><br></pre></td></tr></table></figure>\n<p>输入info replication可查看节点信息。</p>\n<h4 id=\"2-5-4-哨兵搭建\"><a href=\"#2-5-4-哨兵搭建\" class=\"headerlink\" title=\"2.5.4 哨兵搭建\"></a>2.5.4 哨兵搭建</h4><p>新建sentinel/26380,26381,26382目录，将redis家目录下的sentinel.conf文件拷贝到每个目录中</p>\n<p>sentinel.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bind 192.168.10.100</span><br><span class=\"line\">port 26380</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\">dir &quot;/home/admin/redis/cluster/sentinel/26380&quot;</span><br><span class=\"line\"># 故障转移配置</span><br><span class=\"line\"># 表示哨兵集群中，至少有两个节点认为Redis节点挂掉，则将节点从集群中剔除</span><br><span class=\"line\">sentinel monitor mymaster 192.168.10.100 6380 2</span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br></pre></td></tr></table></figure>\n<p>其他的类似</p>\n<p>启动哨兵</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26380/sentinel.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26381/sentinel.conf</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-sentinel ./cluster/sentinel/26382/sentinel.conf</span></span><br></pre></td></tr></table></figure>\n<p>查看哨兵节点信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./redis-4.0.2/src/redis-cli -h 192.168.10.110 -p 26380</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> info Sentinel</span></span><br><span class=\"line\">sentinel_masters:1</span><br><span class=\"line\">sentinel_tilt:0</span><br><span class=\"line\">sentinel_running_scripts:0</span><br><span class=\"line\">sentinel_scripts_queue_length:0</span><br><span class=\"line\">sentinel_simulate_failure_flags:0</span><br><span class=\"line\">master0:name=cpicmaster,status=ok,address=192.168.10.110:6380,slaves=1,sentinels=3</span><br></pre></td></tr></table></figure>\n","slug":"redis系统学习","updated":"2018-08-07T15:41:03.000Z","comments":true,"link":"","permalink":"/2018/02/08/redis系统学习/","excerpt":"1、基本配置 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程","categories":[{"name":"Redis","slug":"Redis","permalink":"/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"}]},{"title":"对前后台分离的思考","date":"2018-01-04T03:17:33.000Z","path":"2018/01/04/对前后台分离的思考/","text":"前言传统的javaweb项目，在开发的过程中，没有明确的分工，后台人员即要写后台，也要做数据库，更要写页面，而且传统的javaweb项目，大多都是jsp，有时候没有明确的规范，jsp页面加入大量的java代码，导致项目前后台杂乱不堪。 随着时代的发展，各种前后台框架的出现，前段知识大量增加，如果还保持着传统项目架构，后端人员工作量大大增加，需要学习的知识也同步增加，最终造成的结果就是啥都懂一点，啥都不精。 慢慢的，前后端分离架构出现了，前端人员专心研究前端的事，后端人员专心提高后端的事，正所谓术业有专攻。 正文前后端分离，大体上就是前端页面和后端的交互只通过json。页面的跳转等都由前端控制，后端只负责为页面提供数据。 在公司为期将近一年的开发中，各种新项目，老项目都渐渐的采用前后端分离架构，对这种架构模式也有了一点初步的认识，接下来就说说我在项目中对前后端分离的各种体会。 首先，先说说在开发中，因为前后端分离产生的一些问题。 在开发中，因为基本上前端都是那种特别纯粹的前端人员，也就是只懂前端，不了解java，不了解oracle，不了解业务，不了解网络协议等等各种基础知识即特性，在开发中出现了各种问题，比如请求中cookie丢失不知如何处理，功能开发完成之后不知如何测试，不懂业务导致不知道自己做出的页面到底对不对等等各种问题，而且由于后台只提供数据，不做页面跳转，所以在和传统项目做SSO单点登录的时候更麻烦。 当然，前后台分离也并不是没有好处。 开发人员的职能划分更加明确，前后端人员各自考虑自己职能范围内的事，比如前端人员可以专心提高页面的用户体验，而后端人员则专注于接口开发和后台性能 前后端能够同步进行，事先定义好接口，前后端同步进行，到后面只需要进行对接联调即可 前台基本上采用静态页面，响应速度快 前后端分离了，可以分开部署，也可以分开做负载处理 针对前后端分离架构的项目准备工作由于前后端分离，前后端由不同的人员去开发，所以项目的准备工作一定要做到位。 项目必须要有详细的API，并且能够测试数据，以便前端人员能够在最短的时间内拿到正确的API，swagger就挺不错的，后端API有改动时，能够实时反映出来。 对于页面功能，最好有明确的模型图 在项目开始时，前后端人员必须都对业务有所了解，“脱离业务的项目架构都是耍流氓”，忘记出自哪里了。 目前大概只有这些体会了，后面有更深的理解，会继续补充。","raw":"---\ntitle: 对前后台分离的思考\ndate: 2018-01-04 11:17:33\ntoc: true\ncategories: 思考\ntags: 项目架构,前后端分离\ndescription: 前后台分离架构的认识与思考\n---\n\n### 前言\n\n传统的javaweb项目，在开发的过程中，没有明确的分工，后台人员即要写后台，也要做数据库，更要写页面，而且传统的javaweb项目，大多都是jsp，有时候没有明确的规范，jsp页面加入大量的java代码，导致项目前后台杂乱不堪。\n\n随着时代的发展，各种前后台框架的出现，前段知识大量增加，如果还保持着传统项目架构，后端人员工作量大大增加，需要学习的知识也同步增加，最终造成的结果就是啥都懂一点，啥都不精。\n\n慢慢的，前后端分离架构出现了，前端人员专心研究前端的事，后端人员专心提高后端的事，正所谓术业有专攻。\n<!--more-->\n### 正文\n\n前后端分离，大体上就是前端页面和后端的交互只通过json。页面的跳转等都由前端控制，后端只负责为页面提供数据。\n\n在公司为期将近一年的开发中，各种新项目，老项目都渐渐的采用前后端分离架构，对这种架构模式也有了一点初步的认识，接下来就说说我在项目中对前后端分离的各种体会。\n\n首先，先说说在开发中，因为前后端分离产生的一些问题。\n\n在开发中，因为基本上前端都是那种特别纯粹的前端人员，也就是只懂前端，不了解java，不了解oracle，不了解业务，不了解网络协议等等各种基础知识即特性，在开发中出现了各种问题，比如请求中cookie丢失不知如何处理，功能开发完成之后不知如何测试，不懂业务导致不知道自己做出的页面到底对不对等等各种问题，而且由于后台只提供数据，不做页面跳转，所以在和传统项目做SSO单点登录的时候更麻烦。\n\n当然，前后台分离也并不是没有好处。\n\n1. 开发人员的职能划分更加明确，前后端人员各自考虑自己职能范围内的事，比如前端人员可以专心提高页面的用户体验，而后端人员则专注于接口开发和后台性能\n2. 前后端能够同步进行，事先定义好接口，前后端同步进行，到后面只需要进行对接联调即可\n3. 前台基本上采用静态页面，响应速度快\n4. 前后端分离了，可以分开部署，也可以分开做负载处理\n\n### 针对前后端分离架构的项目准备工作\n\n由于前后端分离，前后端由不同的人员去开发，所以项目的准备工作一定要做到位。\n\n1. 项目必须要有详细的API，并且能够测试数据，以便前端人员能够在最短的时间内拿到正确的API，swagger就挺不错的，后端API有改动时，能够实时反映出来。\n2. 对于页面功能，最好有明确的模型图\n3. 在项目开始时，前后端人员必须都对业务有所了解，“脱离业务的项目架构都是耍流氓”，忘记出自哪里了。\n\n目前大概只有这些体会了，后面有更深的理解，会继续补充。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>传统的javaweb项目，在开发的过程中，没有明确的分工，后台人员即要写后台，也要做数据库，更要写页面，而且传统的javaweb项目，大多都是jsp，有时候没有明确的规范，jsp页面加入大量的java代码，导致项目前后台杂乱不堪。</p>\n<p>随着时代的发展，各种前后台框架的出现，前段知识大量增加，如果还保持着传统项目架构，后端人员工作量大大增加，需要学习的知识也同步增加，最终造成的结果就是啥都懂一点，啥都不精。</p>\n<p>慢慢的，前后端分离架构出现了，前端人员专心研究前端的事，后端人员专心提高后端的事，正所谓术业有专攻。<br><a id=\"more\"></a></p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>前后端分离，大体上就是前端页面和后端的交互只通过json。页面的跳转等都由前端控制，后端只负责为页面提供数据。</p>\n<p>在公司为期将近一年的开发中，各种新项目，老项目都渐渐的采用前后端分离架构，对这种架构模式也有了一点初步的认识，接下来就说说我在项目中对前后端分离的各种体会。</p>\n<p>首先，先说说在开发中，因为前后端分离产生的一些问题。</p>\n<p>在开发中，因为基本上前端都是那种特别纯粹的前端人员，也就是只懂前端，不了解java，不了解oracle，不了解业务，不了解网络协议等等各种基础知识即特性，在开发中出现了各种问题，比如请求中cookie丢失不知如何处理，功能开发完成之后不知如何测试，不懂业务导致不知道自己做出的页面到底对不对等等各种问题，而且由于后台只提供数据，不做页面跳转，所以在和传统项目做SSO单点登录的时候更麻烦。</p>\n<p>当然，前后台分离也并不是没有好处。</p>\n<ol>\n<li>开发人员的职能划分更加明确，前后端人员各自考虑自己职能范围内的事，比如前端人员可以专心提高页面的用户体验，而后端人员则专注于接口开发和后台性能</li>\n<li>前后端能够同步进行，事先定义好接口，前后端同步进行，到后面只需要进行对接联调即可</li>\n<li>前台基本上采用静态页面，响应速度快</li>\n<li>前后端分离了，可以分开部署，也可以分开做负载处理</li>\n</ol>\n<h3 id=\"针对前后端分离架构的项目准备工作\"><a href=\"#针对前后端分离架构的项目准备工作\" class=\"headerlink\" title=\"针对前后端分离架构的项目准备工作\"></a>针对前后端分离架构的项目准备工作</h3><p>由于前后端分离，前后端由不同的人员去开发，所以项目的准备工作一定要做到位。</p>\n<ol>\n<li>项目必须要有详细的API，并且能够测试数据，以便前端人员能够在最短的时间内拿到正确的API，swagger就挺不错的，后端API有改动时，能够实时反映出来。</li>\n<li>对于页面功能，最好有明确的模型图</li>\n<li>在项目开始时，前后端人员必须都对业务有所了解，“脱离业务的项目架构都是耍流氓”，忘记出自哪里了。</li>\n</ol>\n<p>目前大概只有这些体会了，后面有更深的理解，会继续补充。</p>\n","slug":"对前后台分离的思考","updated":"2018-08-07T15:41:15.000Z","comments":true,"link":"","permalink":"/2018/01/04/对前后台分离的思考/","excerpt":"前言传统的javaweb项目，在开发的过程中，没有明确的分工，后台人员即要写后台，也要做数据库，更要写页面，而且传统的javaweb项目，大多都是jsp，有时候没有明确的规范，jsp页面加入大量的java代码，导致项目前后台杂乱不堪。 随着时代的发展，各种前后台框架的出现，前段知识大量增加，如果还保持着传统项目架构，后端人员工作量大大增加，需要学习的知识也同步增加，最终造成的结果就是啥都懂一点，啥都不精。 慢慢的，前后端分离架构出现了，前端人员专心研究前端的事，后端人员专心提高后端的事，正所谓术业有专攻。","categories":[{"name":"思考","slug":"思考","permalink":"/categories/思考/"}],"tags":[{"name":"项目架构,前后端分离","slug":"项目架构-前后端分离","permalink":"/tags/项目架构-前后端分离/"}]},{"title":"SpringBoot启动原理分析","date":"2017-12-09T14:30:56.000Z","path":"2017/12/09/SpringBoot启动原理分析/","text":"前言用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。 此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。 正文核心注解@SpringBootApplication每个SpringBoot应用，都有一个入口类，标注@SpringBootApplication注解。 123456@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 点开@SpringBootApplication的源码，可以看到这个注解其实包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。 下面对这三个注解简单解释解释。 @SpringBootConfiguration 对于这个注解不做解释，将这个注解点进去，发现还有@Configuration注解，对于@Configuration注解，用过Spring或SpringBoot的基本上都不陌生，标注了@Configuration的类相当于Spring中的配置XML，不过SpringBoot社区推荐使用JavaConfig，所以@Configuration就构建出了一个基础JavaConfig的Ioc容器。 @EnableAutoConfiguration Spring中有很多Enable*的注解，表示开启某项东西，如@EnableSchuduling。所以看这个注解的名字就知道是开启自动配置。这是一个复合注解，其中最主要的还是@Import，借助于EnableAutoConfigurationImportSelector，将所有符合自动配置条件的Bean加载到Ioc容器里。 SpringBoot加载自动配置的方式有两种（目前我知道的）： 在classpath下新建META-INF/spring.factories文件，将标注了@Configuration的类的全路径配置到此文件中，如： 123org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.quartz.config.QuartzBeanConfiguration,\\ com.quartz.config.QuartzAutoConfiguration 在启动时，通过SpringFactoriesLoader工具类，将所有META-INF目录下的spring.factories文件中的配置类加载到Ioc容器里。 使用@Import，将配置类加载到Ioc容器里。 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;QuartzAutoConfiguration.class&#125;)public @interface EnableQuartz &#123;&#125; 使用@Import导入的类必须满足以下任意一个要求： 导入的类使用@Configuration进行标注 导入的类中至少有一个使用@Bean标准的方法 导入的类实现了ImportSelector接口 导入的类实现了ImportBeanDefinitionRegistrar接口 @ComponentScan 看到这个注解，可以回想一下以前使用SpringMVC时，xml配置文件里的一个标签 1&lt;context:component-scan base-package=\"\" /&gt; 不过这个注解一般不需要手动指定扫描的包路径，它默认会从标注了@ComponentScan的类所在包往下查找，将标注了如@Component，@Service等Bean加载到Ioc容器里。 自动配置核心类SpringFactoriesLoader上面在说@EnableAutoConfiguration的时候有说META-INF下的spring.factories文件，那么这个文件是怎么被spring加载到的呢，其实就是SpringFactoriesLoader类。 SpringFactoriesLoader是一个供Spring内部使用的通用工厂装载器，SpringFactoriesLoader里有两个方法， 1234// 加载工厂类并实例化public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;&#125;// 加载工厂类的类名public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;&#125; 在这个SpringBoot应用启动过程中，SpringFactoriesLoader做了以下几件事： 加载所有META-INF/spring.factories中的Initializer 加载所有META-INF/spring.factories中的Listener 加载EnvironmentPostProcessor（允许在Spring应用构建之前定制环境配置） 接下来加载Properties和YAML的PropertySourceLoader（针对SpringBoot的两种配置文件的加载器） 各种异常情况的FailureAnalyzer（异常解释器） 加载SpringBoot内部实现的各种AutoConfiguration 模板引擎TemplateAvailabilityProvider（如Freemarker、Thymeleaf、Jsp、Velocity等） 总得来说，SpringFactoriesLoader和@EnableAutoConfiguration配合起来，整体功能就是查找spring.factories文件，加载自动配置类。 整体启动流程在我们执行入口类的main方法之后，运行SpringApplication.run，后面new了一个SpringApplication对象，然后执行它的run方法。 123public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123; return new SpringApplication(sources).run(args);&#125; 初始化SpringApplication类创建一个SpringApplication对象时，会调用它自己的initialize方法 1234567891011121314private void initialize(Object[] sources) &#123; if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; // 根据标志类javax.servlet.Servlet,org.springframework.web.context.ConfigurableWebApplicationContext是否存在，判断是否是web环境 this.webEnvironment = deduceWebEnvironment(); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationContextInitializer，并实例化 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationListener，并实例化 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获取执行当前main方法的类，也就是启动类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 注 ： 各方法内部执行逻辑就不做说明了，比较简单，需要的读者可自行点进源码查看 执行核心run方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public ConfigurableApplicationContext run(String... args) &#123; // 启动任务执行的时间监听器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; // 设置系统java.awt.headless属性，确定是否开启headless模式(默认开启headless模式) configureHeadlessProperty(); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化 SpringApplicationRunListeners listeners = getRunListeners(args); // 开始广播启动 listeners.started(); try &#123; // 创建SpringBoot默认启动参数对象 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 根据启动参数创建并配置Environment(所有有效的配置，如Profile)，并遍历所有的listeners，广播启动环境已准备 ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments); // 打印启动图案 Banner printedBanner = printBanner(environment); // 根据标志类(上面有提到过)，创建对应类型的ApplicationContext context = createApplicationContext(); // 创建异常解析器(当启动失败时，由此解析器处理失败结果) analyzers = new FailureAnalyzers(context); // 准备Spring上下文环境 // 在这个方法中，主要完成了以下几件事： // 1、设置SpringBoot的环境配置(Environment) // 2、注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader // 3、加载ApplicationContextInitializer初始化器，并进行初始化 // 4、统一将上面的Environment、BeanNameGenerator、ResourceLoader使用默认的Bean注册器进行注册 prepareContext(context, environment, listeners, applicationArguments,printedBanner); // 注册一个关闭Spring容器的钩子 refreshContext(context); // 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法 // ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组 afterRefresh(context, applicationArguments); // 通知所有listener，Spring容器启动完成 listeners.finished(context, null); // 停止时间监听器 stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; // 启动有异常时，调用异常解析器解析异常信息，根据异常级别，判断是否退出Spring容器 handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; run方法整体执行流程总结 获取所有的","raw":"---\nlayout: post\ntitle: SpringBoot启动原理分析\ntoc: true\ndate: 2017-12-09 22:30:56\ntags: SpringBoot\ncategories: SpringBoot\ndescription:\n---\n\n## 前言\n\n用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。\n\n此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。<!--more-->\n\n## 正文\n\n### 核心注解@SpringBootApplication\n\n每个SpringBoot应用，都有一个入口类，标注@SpringBootApplication注解。\n\n~~~java\n@SpringBootApplication\npublic class DemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n~~~\n\n点开@SpringBootApplication的源码，可以看到这个注解其实包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。\n\n下面对这三个注解简单解释解释。\n\n- @SpringBootConfiguration\n\n  对于这个注解不做解释，将这个注解点进去，发现还有@Configuration注解，对于@Configuration注解，用过Spring或SpringBoot的基本上都不陌生，标注了@Configuration的类相当于Spring中的配置XML，不过SpringBoot社区推荐使用JavaConfig，所以@Configuration就构建出了一个基础JavaConfig的Ioc容器。\n\n- @EnableAutoConfiguration\n\n  Spring中有很多Enable*的注解，表示开启某项东西，如@EnableSchuduling。所以看这个注解的名字就知道是开启自动配置。这是一个复合注解，其中最主要的还是@Import，借助于EnableAutoConfigurationImportSelector，将所有符合自动配置条件的Bean加载到Ioc容器里。\n\n  SpringBoot加载自动配置的方式有两种（目前我知道的）：\n\n  - 在classpath下新建META-INF/spring.factories文件，将标注了@Configuration的类的全路径配置到此文件中，如：\n\n    ~~~spring.factories\n    org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n     com.quartz.config.QuartzBeanConfiguration,\\\n     com.quartz.config.QuartzAutoConfiguration\n    ~~~\n\n    在启动时，通过SpringFactoriesLoader工具类，将所有META-INF目录下的spring.factories文件中的配置类加载到Ioc容器里。\n\n  - 使用@Import，将配置类加载到Ioc容器里。\n\n    ~~~java\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Import({QuartzAutoConfiguration.class})\n    public @interface EnableQuartz {\n    }\n    ~~~\n\n    使用@Import导入的类必须满足以下任意一个要求：\n\n    1. 导入的类使用@Configuration进行标注\n    2. 导入的类中至少有一个使用@Bean标准的方法\n    3. 导入的类实现了ImportSelector接口\n    4. 导入的类实现了ImportBeanDefinitionRegistrar接口\n\n- @ComponentScan\n\n  看到这个注解，可以回想一下以前使用SpringMVC时，xml配置文件里的一个标签\n\n  ```xml\n  <context:component-scan base-package=\"\" />\n  ```\n\n  不过这个注解一般不需要手动指定扫描的包路径，它默认会从标注了@ComponentScan的类所在包往下查找，将标注了如@Component，@Service等Bean加载到Ioc容器里。\n\n\n### 自动配置核心类SpringFactoriesLoader\n\n上面在说@EnableAutoConfiguration的时候有说META-INF下的spring.factories文件，那么这个文件是怎么被spring加载到的呢，其实就是SpringFactoriesLoader类。\n\nSpringFactoriesLoader是一个供Spring内部使用的通用工厂装载器，SpringFactoriesLoader里有两个方法，\n\n~~~java\n// 加载工厂类并实例化\npublic static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {}\n// 加载工厂类的类名\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {}\n~~~\n\n在这个SpringBoot应用启动过程中，SpringFactoriesLoader做了以下几件事：\n\n1. 加载所有META-INF/spring.factories中的Initializer\n2. 加载所有META-INF/spring.factories中的Listener\n3. 加载EnvironmentPostProcessor（允许在Spring应用构建之前定制环境配置）\n4. 接下来加载Properties和YAML的PropertySourceLoader（针对SpringBoot的两种配置文件的加载器）\n5. 各种异常情况的FailureAnalyzer（异常解释器）\n6. 加载SpringBoot内部实现的各种AutoConfiguration\n7. 模板引擎TemplateAvailabilityProvider（如Freemarker、Thymeleaf、Jsp、Velocity等）\n\n总得来说，SpringFactoriesLoader和@EnableAutoConfiguration配合起来，整体功能就是查找spring.factories文件，加载自动配置类。\n\n## 整体启动流程\n\n在我们执行入口类的main方法之后，运行SpringApplication.run，后面new了一个SpringApplication对象，然后执行它的run方法。\n\n~~~java\npublic static ConfigurableApplicationContext run(Object[] sources, String[] args) {\n\treturn new SpringApplication(sources).run(args);\n}\n~~~\n\n### 初始化SpringApplication类\n\n创建一个SpringApplication对象时，会调用它自己的initialize方法\n\n~~~java\nprivate void initialize(Object[] sources) {\n\tif (sources != null && sources.length > 0) {\n\t\tthis.sources.addAll(Arrays.asList(sources));\n\t}\n  \t// 根据标志类javax.servlet.Servlet,org.springframework.web.context.ConfigurableWebApplicationContext是否存在，判断是否是web环境\n\tthis.webEnvironment = deduceWebEnvironment();\n  \t// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationContextInitializer，并实例化\n\tsetInitializers((Collection) getSpringFactoriesInstances(\n\t\t\tApplicationContextInitializer.class));\n  \t// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationListener，并实例化\n\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n  \t// 获取执行当前main方法的类，也就是启动类\n\tthis.mainApplicationClass = deduceMainApplicationClass();\n}\n~~~\n\n**注 ：** 各方法内部执行逻辑就不做说明了，比较简单，需要的读者可自行点进源码查看\n\n### 执行核心run方法\n\n~~~java\npublic ConfigurableApplicationContext run(String... args) {\n  \t// 启动任务执行的时间监听器\n\tStopWatch stopWatch = new StopWatch();\n\tstopWatch.start();\n  \t\n\tConfigurableApplicationContext context = null;\n\tFailureAnalyzers analyzers = null;\n  \t// 设置系统java.awt.headless属性，确定是否开启headless模式(默认开启headless模式)\n\tconfigureHeadlessProperty();\n  \t// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化\n\tSpringApplicationRunListeners listeners = getRunListeners(args);\n  \t// 开始广播启动\n\tlisteners.started();\n\ttry {\n        // 创建SpringBoot默认启动参数对象\n\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 根据启动参数创建并配置Environment(所有有效的配置，如Profile)，并遍历所有的listeners，广播启动环境已准备\n\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);\n        // 打印启动图案\n\t\tBanner printedBanner = printBanner(environment);\n        // 根据标志类(上面有提到过)，创建对应类型的ApplicationContext\n\t\tcontext = createApplicationContext();\n        // 创建异常解析器(当启动失败时，由此解析器处理失败结果)\n\t\tanalyzers = new FailureAnalyzers(context);\n        // 准备Spring上下文环境\n        // 在这个方法中，主要完成了以下几件事：\n        // \t1、设置SpringBoot的环境配置(Environment)\n        // \t2、注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader\n        //\t3、加载ApplicationContextInitializer初始化器，并进行初始化\n        //\t4、统一将上面的Environment、BeanNameGenerator、ResourceLoader使用默认的Bean注册器进行注册\n\t\tprepareContext(context, environment, listeners, applicationArguments,printedBanner);\n        // 注册一个关闭Spring容器的钩子\n\t\trefreshContext(context);\n        // 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法\n        // ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组\n\t\tafterRefresh(context, applicationArguments);\n        // 通知所有listener，Spring容器启动完成\n\t\tlisteners.finished(context, null);\n        // 停止时间监听器\n\t\tstopWatch.stop();\n\t\tif (this.logStartupInfo) {\n\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t}\n\t\treturn context;\n\t} catch (Throwable ex) {\n        // 启动有异常时，调用异常解析器解析异常信息，根据异常级别，判断是否退出Spring容器\n\t\thandleRunFailure(context, listeners, analyzers, ex);\n\t\tthrow new IllegalStateException(ex);\n\t}\n}\n~~~\n\n#### run方法整体执行流程总结\n\n- 获取所有的\n\n","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。</p>\n<p>此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。<a id=\"more\"></a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"核心注解-SpringBootApplication\"><a href=\"#核心注解-SpringBootApplication\" class=\"headerlink\" title=\"核心注解@SpringBootApplication\"></a>核心注解@SpringBootApplication</h3><p>每个SpringBoot应用，都有一个入口类，标注@SpringBootApplication注解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(DemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点开@SpringBootApplication的源码，可以看到这个注解其实包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。</p>\n<p>下面对这三个注解简单解释解释。</p>\n<ul>\n<li><p>@SpringBootConfiguration</p>\n<p>对于这个注解不做解释，将这个注解点进去，发现还有@Configuration注解，对于@Configuration注解，用过Spring或SpringBoot的基本上都不陌生，标注了@Configuration的类相当于Spring中的配置XML，不过SpringBoot社区推荐使用JavaConfig，所以@Configuration就构建出了一个基础JavaConfig的Ioc容器。</p>\n</li>\n<li><p>@EnableAutoConfiguration</p>\n<p>Spring中有很多Enable*的注解，表示开启某项东西，如@EnableSchuduling。所以看这个注解的名字就知道是开启自动配置。这是一个复合注解，其中最主要的还是@Import，借助于EnableAutoConfigurationImportSelector，将所有符合自动配置条件的Bean加载到Ioc容器里。</p>\n<p>SpringBoot加载自动配置的方式有两种（目前我知道的）：</p>\n<ul>\n<li><p>在classpath下新建META-INF/spring.factories文件，将标注了@Configuration的类的全路径配置到此文件中，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\"> com.quartz.config.QuartzBeanConfiguration,\\</span><br><span class=\"line\"> com.quartz.config.QuartzAutoConfiguration</span><br></pre></td></tr></table></figure>\n<p>在启动时，通过SpringFactoriesLoader工具类，将所有META-INF目录下的spring.factories文件中的配置类加载到Ioc容器里。</p>\n</li>\n<li><p>使用@Import，将配置类加载到Ioc容器里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;QuartzAutoConfiguration.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableQuartz &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用@Import导入的类必须满足以下任意一个要求：</p>\n<ol>\n<li>导入的类使用@Configuration进行标注</li>\n<li>导入的类中至少有一个使用@Bean标准的方法</li>\n<li>导入的类实现了ImportSelector接口</li>\n<li>导入的类实现了ImportBeanDefinitionRegistrar接口</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>@ComponentScan</p>\n<p>看到这个注解，可以回想一下以前使用SpringMVC时，xml配置文件里的一个标签</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>不过这个注解一般不需要手动指定扫描的包路径，它默认会从标注了@ComponentScan的类所在包往下查找，将标注了如@Component，@Service等Bean加载到Ioc容器里。</p>\n</li>\n</ul>\n<h3 id=\"自动配置核心类SpringFactoriesLoader\"><a href=\"#自动配置核心类SpringFactoriesLoader\" class=\"headerlink\" title=\"自动配置核心类SpringFactoriesLoader\"></a>自动配置核心类SpringFactoriesLoader</h3><p>上面在说@EnableAutoConfiguration的时候有说META-INF下的spring.factories文件，那么这个文件是怎么被spring加载到的呢，其实就是SpringFactoriesLoader类。</p>\n<p>SpringFactoriesLoader是一个供Spring内部使用的通用工厂装载器，SpringFactoriesLoader里有两个方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载工厂类并实例化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">loadFactories</span><span class=\"params\">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 加载工厂类的类名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个SpringBoot应用启动过程中，SpringFactoriesLoader做了以下几件事：</p>\n<ol>\n<li>加载所有META-INF/spring.factories中的Initializer</li>\n<li>加载所有META-INF/spring.factories中的Listener</li>\n<li>加载EnvironmentPostProcessor（允许在Spring应用构建之前定制环境配置）</li>\n<li>接下来加载Properties和YAML的PropertySourceLoader（针对SpringBoot的两种配置文件的加载器）</li>\n<li>各种异常情况的FailureAnalyzer（异常解释器）</li>\n<li>加载SpringBoot内部实现的各种AutoConfiguration</li>\n<li>模板引擎TemplateAvailabilityProvider（如Freemarker、Thymeleaf、Jsp、Velocity等）</li>\n</ol>\n<p>总得来说，SpringFactoriesLoader和@EnableAutoConfiguration配合起来，整体功能就是查找spring.factories文件，加载自动配置类。</p>\n<h2 id=\"整体启动流程\"><a href=\"#整体启动流程\" class=\"headerlink\" title=\"整体启动流程\"></a>整体启动流程</h2><p>在我们执行入口类的main方法之后，运行SpringApplication.run，后面new了一个SpringApplication对象，然后执行它的run方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplication(sources).run(args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化SpringApplication类\"><a href=\"#初始化SpringApplication类\" class=\"headerlink\" title=\"初始化SpringApplication类\"></a>初始化SpringApplication类</h3><p>创建一个SpringApplication对象时，会调用它自己的initialize方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(Object[] sources)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sources != <span class=\"keyword\">null</span> &amp;&amp; sources.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  \t<span class=\"comment\">// 根据标志类javax.servlet.Servlet,org.springframework.web.context.ConfigurableWebApplicationContext是否存在，判断是否是web环境</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class=\"line\">  \t<span class=\"comment\">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationContextInitializer，并实例化</span></span><br><span class=\"line\">\tsetInitializers((Collection) getSpringFactoriesInstances(</span><br><span class=\"line\">\t\t\tApplicationContextInitializer.class));</span><br><span class=\"line\">  \t<span class=\"comment\">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationListener，并实例化</span></span><br><span class=\"line\">\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取执行当前main方法的类，也就是启动类</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注 ：</strong> 各方法内部执行逻辑就不做说明了，比较简单，需要的读者可自行点进源码查看</p>\n<h3 id=\"执行核心run方法\"><a href=\"#执行核心run方法\" class=\"headerlink\" title=\"执行核心run方法\"></a>执行核心run方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 启动任务执行的时间监听器</span></span><br><span class=\"line\">\tStopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</span><br><span class=\"line\">\tstopWatch.start();</span><br><span class=\"line\">  \t</span><br><span class=\"line\">\tConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tFailureAnalyzers analyzers = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  \t<span class=\"comment\">// 设置系统java.awt.headless属性，确定是否开启headless模式(默认开启headless模式)</span></span><br><span class=\"line\">\tconfigureHeadlessProperty();</span><br><span class=\"line\">  \t<span class=\"comment\">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化</span></span><br><span class=\"line\">\tSpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class=\"line\">  \t<span class=\"comment\">// 开始广播启动</span></span><br><span class=\"line\">\tlisteners.started();</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建SpringBoot默认启动参数对象</span></span><br><span class=\"line\">\t\tApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</span><br><span class=\"line\">        <span class=\"comment\">// 根据启动参数创建并配置Environment(所有有效的配置，如Profile)，并遍历所有的listeners，广播启动环境已准备</span></span><br><span class=\"line\">\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);</span><br><span class=\"line\">        <span class=\"comment\">// 打印启动图案</span></span><br><span class=\"line\">\t\tBanner printedBanner = printBanner(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 根据标志类(上面有提到过)，创建对应类型的ApplicationContext</span></span><br><span class=\"line\">\t\tcontext = createApplicationContext();</span><br><span class=\"line\">        <span class=\"comment\">// 创建异常解析器(当启动失败时，由此解析器处理失败结果)</span></span><br><span class=\"line\">\t\tanalyzers = <span class=\"keyword\">new</span> FailureAnalyzers(context);</span><br><span class=\"line\">        <span class=\"comment\">// 准备Spring上下文环境</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这个方法中，主要完成了以下几件事：</span></span><br><span class=\"line\">        <span class=\"comment\">// \t1、设置SpringBoot的环境配置(Environment)</span></span><br><span class=\"line\">        <span class=\"comment\">// \t2、注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader</span></span><br><span class=\"line\">        <span class=\"comment\">//\t3、加载ApplicationContextInitializer初始化器，并进行初始化</span></span><br><span class=\"line\">        <span class=\"comment\">//\t4、统一将上面的Environment、BeanNameGenerator、ResourceLoader使用默认的Bean注册器进行注册</span></span><br><span class=\"line\">\t\tprepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br><span class=\"line\">        <span class=\"comment\">// 注册一个关闭Spring容器的钩子</span></span><br><span class=\"line\">\t\trefreshContext(context);</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法</span></span><br><span class=\"line\">        <span class=\"comment\">// ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组</span></span><br><span class=\"line\">\t\tafterRefresh(context, applicationArguments);</span><br><span class=\"line\">        <span class=\"comment\">// 通知所有listener，Spring容器启动完成</span></span><br><span class=\"line\">\t\tlisteners.finished(context, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 停止时间监听器</span></span><br><span class=\"line\">\t\tstopWatch.stop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</span><br><span class=\"line\">\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> context;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动有异常时，调用异常解析器解析异常信息，根据异常级别，判断是否退出Spring容器</span></span><br><span class=\"line\">\t\thandleRunFailure(context, listeners, analyzers, ex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"run方法整体执行流程总结\"><a href=\"#run方法整体执行流程总结\" class=\"headerlink\" title=\"run方法整体执行流程总结\"></a>run方法整体执行流程总结</h4><ul>\n<li>获取所有的</li>\n</ul>\n","slug":"SpringBoot启动原理分析","updated":"2018-10-08T08:43:39.000Z","comments":true,"link":"","permalink":"/2017/12/09/SpringBoot启动原理分析/","excerpt":"前言用了差不多两年的SpringBoot了，可以说对SpringBoot已经很熟了，但是仔细一想SpringBoot的启动流程，还是让自己有点懵逼，不得不说是自己工作和学习的失误，所以以此文对SpringBoot的启动流程略作记录。 此文的SpringBoot启动流程分析是基于SpringBoot 1.x的，SpringBoot 2.x的启动流程与1.x的略有不同，后续再进行补充分析。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/tags/SpringBoot/"}]},{"title":"lombok常用注解","date":"2017-09-07T15:43:12.000Z","path":"2017/09/07/lombok使用/","text":"Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as val, and much more. 这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。 下面简单介绍一些在开发中常用的注解。 Lombok常用注解@Getter可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。 @Setter和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。 @ToString只能标注到类上，相当于是重写此类的toString方法。 @EqualsAndHashCode只能标注到类上，相当于是重写此类的hashCode和equals方法。 @NoArgsConstructor只能标注到类上，生成无参的构造方法。 @Data只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。 @Value只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。 @AllArgsConstructor只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。 @RequiredArgsConstructor只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如： 1234@RequiredArgsConstructor(staticName = \"passwd\")public class User &#123; @NonNull private String password;&#125; 上面代码编译后对应下面的代码 12345678public class User &#123; private User(String password) &#123; this.password = password; &#125; public static User passwd(String password) &#123; return new User(password); &#125;&#125; @Builder只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下： 1User buildUser = User.builder().password(\"haha\").username(\"gaga\").build(); 可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及Guava的com.google.common.collect 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class UserBuilder &#123; private String username; private String password; private ArrayList&lt;String&gt; projects; UserBuilder() &#123; &#125; public User.UserBuilder username(String username) &#123; this.username = username; return this; &#125; public User.UserBuilder password(String password) &#123; this.password = password; return this; &#125; public User.UserBuilder project(String project) &#123; if (this.projects == null) this.projects = new ArrayList&lt;String&gt;(); this.projects.add(project); return this; &#125; public User.UserBuilder projects(Collection&lt;? extends String&gt; projects) &#123; if (this.projects == null) this.projects = new ArrayList&lt;String&gt;(); this.projects.addAll(projects); return this; &#125; public User.UserBuilder clearProjects() &#123; if (this.projects != null) this.projects.clear(); return this; &#125; public User build() &#123; Set&lt;String&gt; projects; switch (this.projects == null ? 0 : this.projects.size()) &#123; case 0: projects = java.util.Collections.emptySet(); break; case 1: projects = java.util.Collections.singleton(this.projects.get(0)); break; default: projects = new java.util.LinkedHashSet&lt;String&gt;(this.projects.size() &lt; 1073741824 ? 1 + this.projects.size() + (this.projects.size() - 3) / 3 : Integer.MAX_VALUE); projects.addAll(this.projects); projects = java.util.Collections.unmodifiableSet(projects); &#125; return new User(username, password, projects); &#125; public String toString() &#123; return \"User.UserBuilder(username=\" + this.username + \", password=\" + this.password + \", projects=\" + this.projects + \")\"; &#125; &#125; @Accessors可标注在类或属性上，当然最实用的功能还是标注到类上。 标注到类上，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如： 1new User().setPassword(\"gaga\").setUsername(\"haha\"); fluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如： 123User user = new User().password(\"gaga\").username(\"haha\");String password = user.password();String username = user.username(); 标注到属性上，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。 如： 1234@Accessors(prefix = \"a\")@Getter@Setterprivate String aUsername = \"gaga\"; 编译之后为 123456public String getUsername() &#123; return aUsername;&#125;public void setUsername(String aUsername) &#123; this.aUsername = aUsername;&#125; 以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。","raw":"---\n\nlayout: post\n\ntitle: lombok常用注解\n\ntoc: true\n\ndate: 2017-09-07 23:43:12\n\ntags: 开发工具框架\n\ncategories: 开发工具框架\n\ndescription:\n\n---\n\n\n[Project Lombok](https://projectlombok.org/) is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as `val`, and much more.\n\n这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。<!--more-->\n\n下面简单介绍一些在开发中常用的注解。\n\n## Lombok常用注解\n\n### @Getter\n\n可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。\n\n### @Setter\n\n和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。\n\n### @ToString\n\n只能标注到类上，相当于是重写此类的toString方法。\n\n### @EqualsAndHashCode\n\n只能标注到类上，相当于是重写此类的hashCode和equals方法。\n\n### @NoArgsConstructor\n\n只能标注到类上，生成无参的构造方法。\n\n### @Data\n\n只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。\n\n### @Value\n\n只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。\n\n### @AllArgsConstructor\n\n只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。\n\n### @RequiredArgsConstructor\n\n只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如：\n\n```java\n@RequiredArgsConstructor(staticName = \"passwd\")\npublic class User {\n    @NonNull private String password;\n}\n```\n\n上面代码编译后对应下面的代码\n\n```java\npublic class User {\n\tprivate User(String password) {\n\t\tthis.password = password;\n\t}\n    public static User passwd(String password) {\n    \treturn new User(password);\n    }\n}\n```\n\n### @Builder\n\n只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：\n\n```java\nUser buildUser = User.builder().password(\"haha\").username(\"gaga\").build();\n```\n\n可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及[Guava](https://github.com/google/guava)的`com.google.common.collect` 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。\n\n```java\npublic static class UserBuilder {\n        private String username;\n        private String password;\n        private ArrayList<String> projects;\n        UserBuilder() {\n        }\n        public User.UserBuilder username(String username) {\n            this.username = username;\n            return this;\n        }\n        public User.UserBuilder password(String password) {\n            this.password = password;\n            return this;\n        }\n        public User.UserBuilder project(String project) {\n            if (this.projects == null) this.projects = new ArrayList<String>();\n            this.projects.add(project);\n            return this;\n        }\n        public User.UserBuilder projects(Collection<? extends String> projects) {\n            if (this.projects == null) this.projects = new ArrayList<String>();\n            this.projects.addAll(projects);\n            return this;\n        }\n        public User.UserBuilder clearProjects() {\n            if (this.projects != null)\n                this.projects.clear();\n            return this;\n        }\n        public User build() {\n            Set<String> projects;\n            switch (this.projects == null ? 0 : this.projects.size()) {\n                case 0:\n                    projects = java.util.Collections.emptySet();\n                    break;\n                case 1:\n                    projects = java.util.Collections.singleton(this.projects.get(0));\n                    break;\n                default:\n                    projects = new java.util.LinkedHashSet<String>(this.projects.size() < 1073741824 ? 1 + this.projects.size() + (this.projects.size() - 3) / 3 : Integer.MAX_VALUE);\n                    projects.addAll(this.projects);\n                    projects = java.util.Collections.unmodifiableSet(projects);\n            }\n            return new User(username, password, projects);\n        }\n        public String toString() {\n            return \"User.UserBuilder(username=\" + this.username + \", password=\" + this.password + \", projects=\" + this.projects + \")\";\n        }\n    }\n```\n\n### @Accessors\n\n可标注在类或属性上，当然最实用的功能还是标注到类上。\n\n**标注到类上**，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如：\n\n```java\nnew User().setPassword(\"gaga\").setUsername(\"haha\");\n```\n\nfluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：\n\n```java\nUser user = new User().password(\"gaga\").username(\"haha\");\nString password = user.password();\nString username = user.username();\n```\n\n**标注到属性上**，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。\n\n如：\n\n```java\n@Accessors(prefix = \"a\")\n@Getter\n@Setter\nprivate String aUsername = \"gaga\";\n```\n\n编译之后为\n\n```java\npublic String getUsername() {\n  \treturn aUsername;\n}\npublic void setUsername(String aUsername) {\n  \tthis.aUsername = aUsername;\n}\n```\n\n以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。\n\n\n\n\n\n\n\n\n\n","content":"<p><a href=\"https://projectlombok.org/\" target=\"_blank\" rel=\"noopener\">Project Lombok</a> is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as <code>val</code>, and much more.</p>\n<p>这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。<a id=\"more\"></a></p>\n<p>下面简单介绍一些在开发中常用的注解。</p>\n<h2 id=\"Lombok常用注解\"><a href=\"#Lombok常用注解\" class=\"headerlink\" title=\"Lombok常用注解\"></a>Lombok常用注解</h2><h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"@Getter\"></a>@Getter</h3><p>可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。</p>\n<h3 id=\"Setter\"><a href=\"#Setter\" class=\"headerlink\" title=\"@Setter\"></a>@Setter</h3><p>和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。</p>\n<h3 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"@ToString\"></a>@ToString</h3><p>只能标注到类上，相当于是重写此类的toString方法。</p>\n<h3 id=\"EqualsAndHashCode\"><a href=\"#EqualsAndHashCode\" class=\"headerlink\" title=\"@EqualsAndHashCode\"></a>@EqualsAndHashCode</h3><p>只能标注到类上，相当于是重写此类的hashCode和equals方法。</p>\n<h3 id=\"NoArgsConstructor\"><a href=\"#NoArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor\"></a>@NoArgsConstructor</h3><p>只能标注到类上，生成无参的构造方法。</p>\n<h3 id=\"Data\"><a href=\"#Data\" class=\"headerlink\" title=\"@Data\"></a>@Data</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。</p>\n<h3 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a>@Value</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。</p>\n<h3 id=\"AllArgsConstructor\"><a href=\"#AllArgsConstructor\" class=\"headerlink\" title=\"@AllArgsConstructor\"></a>@AllArgsConstructor</h3><p>只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。</p>\n<h3 id=\"RequiredArgsConstructor\"><a href=\"#RequiredArgsConstructor\" class=\"headerlink\" title=\"@RequiredArgsConstructor\"></a>@RequiredArgsConstructor</h3><p>只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span>(staticName = <span class=\"string\">\"passwd\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码编译后对应下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">User</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> User <span class=\"title\">passwd</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Builder\"><a href=\"#Builder\" class=\"headerlink\" title=\"@Builder\"></a>@Builder</h3><p>只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User buildUser = User.builder().password(<span class=\"string\">\"haha\"</span>).username(<span class=\"string\">\"gaga\"</span>).build();</span><br></pre></td></tr></table></figure>\n<p>可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及<a href=\"https://github.com/google/guava\" target=\"_blank\" rel=\"noopener\">Guava</a>的<code>com.google.common.collect</code> 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> ArrayList&lt;String&gt; projects;</span><br><span class=\"line\">        UserBuilder() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">username</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">password</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">project</span><span class=\"params\">(String project)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span>) <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.projects.add(project);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">projects</span><span class=\"params\">(Collection&lt;? extends String&gt; projects)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span>) <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.projects.addAll(projects);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">clearProjects</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.projects.clear();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            Set&lt;String&gt; projects;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : <span class=\"keyword\">this</span>.projects.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                    projects = java.util.Collections.emptySet();</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    projects = java.util.Collections.singleton(<span class=\"keyword\">this</span>.projects.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    projects = <span class=\"keyword\">new</span> java.util.LinkedHashSet&lt;String&gt;(<span class=\"keyword\">this</span>.projects.size() &lt; <span class=\"number\">1073741824</span> ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.projects.size() + (<span class=\"keyword\">this</span>.projects.size() - <span class=\"number\">3</span>) / <span class=\"number\">3</span> : Integer.MAX_VALUE);</span><br><span class=\"line\">                    projects.addAll(<span class=\"keyword\">this</span>.projects);</span><br><span class=\"line\">                    projects = java.util.Collections.unmodifiableSet(projects);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(username, password, projects);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"User.UserBuilder(username=\"</span> + <span class=\"keyword\">this</span>.username + <span class=\"string\">\", password=\"</span> + <span class=\"keyword\">this</span>.password + <span class=\"string\">\", projects=\"</span> + <span class=\"keyword\">this</span>.projects + <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Accessors\"><a href=\"#Accessors\" class=\"headerlink\" title=\"@Accessors\"></a>@Accessors</h3><p>可标注在类或属性上，当然最实用的功能还是标注到类上。</p>\n<p><strong>标注到类上</strong>，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> User().setPassword(<span class=\"string\">\"gaga\"</span>).setUsername(<span class=\"string\">\"haha\"</span>);</span><br></pre></td></tr></table></figure>\n<p>fluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User().password(<span class=\"string\">\"gaga\"</span>).username(<span class=\"string\">\"haha\"</span>);</span><br><span class=\"line\">String password = user.password();</span><br><span class=\"line\">String username = user.username();</span><br></pre></td></tr></table></figure>\n<p><strong>标注到属性上</strong>，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。</p>\n<p>如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Accessors</span>(prefix = <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String aUsername = <span class=\"string\">\"gaga\"</span>;</span><br></pre></td></tr></table></figure>\n<p>编译之后为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> aUsername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String aUsername)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.aUsername = aUsername;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。</p>\n","slug":"lombok使用","updated":"2018-08-07T15:35:36.000Z","comments":true,"link":"","permalink":"/2017/09/07/lombok使用/","excerpt":"Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as val, and much more. 这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。","categories":[{"name":"开发工具框架","slug":"开发工具框架","permalink":"/categories/开发工具框架/"}],"tags":[{"name":"开发工具框架","slug":"开发工具框架","permalink":"/tags/开发工具框架/"}]},{"title":"lombok常用注解","date":"2017-09-07T15:43:12.000Z","path":"2017/09/07/常用排序算法-Java版/","text":"LombokProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as val, and much more. 这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。 下面简单介绍一些在开发中常用的注解。 Lombok常用注解@Getter可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。 @Setter和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。 @ToString只能标注到类上，相当于是重写此类的toString方法。 @EqualsAndHashCode只能标注到类上，相当于是重写此类的hashCode和equals方法。 @NoArgsConstructor只能标注到类上，生成无参的构造方法。 @Data只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。 @Value只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。 @AllArgsConstructor只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。 @RequiredArgsConstructor只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如： 1234@RequiredArgsConstructor(staticName = \"passwd\")public class User &#123; @NonNull private String password;&#125; 上面代码编译后对应下面的代码 12345678public class User &#123; private User(String password) &#123; this.password = password; &#125; public static User passwd(String password) &#123; return new User(password); &#125;&#125; @Builder只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下： 1User buildUser = User.builder().password(\"haha\").username(\"gaga\").build(); 可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及Guava的com.google.common.collect 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class UserBuilder &#123; private String username; private String password; private ArrayList&lt;String&gt; projects; UserBuilder() &#123; &#125; public User.UserBuilder username(String username) &#123; this.username = username; return this; &#125; public User.UserBuilder password(String password) &#123; this.password = password; return this; &#125; public User.UserBuilder project(String project) &#123; if (this.projects == null) this.projects = new ArrayList&lt;String&gt;(); this.projects.add(project); return this; &#125; public User.UserBuilder projects(Collection&lt;? extends String&gt; projects) &#123; if (this.projects == null) this.projects = new ArrayList&lt;String&gt;(); this.projects.addAll(projects); return this; &#125; public User.UserBuilder clearProjects() &#123; if (this.projects != null) this.projects.clear(); return this; &#125; public User build() &#123; Set&lt;String&gt; projects; switch (this.projects == null ? 0 : this.projects.size()) &#123; case 0: projects = java.util.Collections.emptySet(); break; case 1: projects = java.util.Collections.singleton(this.projects.get(0)); break; default: projects = new java.util.LinkedHashSet&lt;String&gt;(this.projects.size() &lt; 1073741824 ? 1 + this.projects.size() + (this.projects.size() - 3) / 3 : Integer.MAX_VALUE); projects.addAll(this.projects); projects = java.util.Collections.unmodifiableSet(projects); &#125; return new User(username, password, projects); &#125; public String toString() &#123; return \"User.UserBuilder(username=\" + this.username + \", password=\" + this.password + \", projects=\" + this.projects + \")\"; &#125; &#125; @Accessors可标注在类或属性上，当然最实用的功能还是标注到类上。 标注到类上，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如： 1new User().setPassword(\"gaga\").setUsername(\"haha\"); fluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如： 123User user = new User().password(\"gaga\").username(\"haha\");String password = user.password();String username = user.username(); 标注到属性上，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。 如： 1234@Accessors(prefix = \"a\")@Getter@Setterprivate String aUsername = \"gaga\"; 编译之后为 123456public String getUsername() &#123; return aUsername;&#125;public void setUsername(String aUsername) &#123; this.aUsername = aUsername;&#125; 以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。","raw":"---\n\nlayout: post\n\ntitle: lombok常用注解\n\ntoc: true\n\ndate: 2017-09-07 23:43:12\n\ntags: 开发工具框架\n\ncategories: 开发工具框架\n\ndescription:\n\n---\n\n\n# Lombok\n\n[Project Lombok](https://projectlombok.org/) is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as `val`, and much more.\n\n这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。<!--more-->\n\n下面简单介绍一些在开发中常用的注解。\n\n## Lombok常用注解\n\n### @Getter\n\n可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。\n\n### @Setter\n\n和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。\n\n### @ToString\n\n只能标注到类上，相当于是重写此类的toString方法。\n\n### @EqualsAndHashCode\n\n只能标注到类上，相当于是重写此类的hashCode和equals方法。\n\n### @NoArgsConstructor\n\n只能标注到类上，生成无参的构造方法。\n\n### @Data\n\n只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。\n\n### @Value\n\n只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。\n\n### @AllArgsConstructor\n\n只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。\n\n### @RequiredArgsConstructor\n\n只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如：\n\n```java\n@RequiredArgsConstructor(staticName = \"passwd\")\npublic class User {\n    @NonNull private String password;\n}\n```\n\n上面代码编译后对应下面的代码\n\n```java\npublic class User {\n\tprivate User(String password) {\n\t\tthis.password = password;\n\t}\n    public static User passwd(String password) {\n    \treturn new User(password);\n    }\n}\n```\n\n### @Builder\n\n只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：\n\n```java\nUser buildUser = User.builder().password(\"haha\").username(\"gaga\").build();\n```\n\n可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及[Guava](https://github.com/google/guava)的`com.google.common.collect` 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。\n\n```java\npublic static class UserBuilder {\n        private String username;\n        private String password;\n        private ArrayList<String> projects;\n        UserBuilder() {\n        }\n        public User.UserBuilder username(String username) {\n            this.username = username;\n            return this;\n        }\n        public User.UserBuilder password(String password) {\n            this.password = password;\n            return this;\n        }\n        public User.UserBuilder project(String project) {\n            if (this.projects == null) this.projects = new ArrayList<String>();\n            this.projects.add(project);\n            return this;\n        }\n        public User.UserBuilder projects(Collection<? extends String> projects) {\n            if (this.projects == null) this.projects = new ArrayList<String>();\n            this.projects.addAll(projects);\n            return this;\n        }\n        public User.UserBuilder clearProjects() {\n            if (this.projects != null)\n                this.projects.clear();\n            return this;\n        }\n        public User build() {\n            Set<String> projects;\n            switch (this.projects == null ? 0 : this.projects.size()) {\n                case 0:\n                    projects = java.util.Collections.emptySet();\n                    break;\n                case 1:\n                    projects = java.util.Collections.singleton(this.projects.get(0));\n                    break;\n                default:\n                    projects = new java.util.LinkedHashSet<String>(this.projects.size() < 1073741824 ? 1 + this.projects.size() + (this.projects.size() - 3) / 3 : Integer.MAX_VALUE);\n                    projects.addAll(this.projects);\n                    projects = java.util.Collections.unmodifiableSet(projects);\n            }\n            return new User(username, password, projects);\n        }\n        public String toString() {\n            return \"User.UserBuilder(username=\" + this.username + \", password=\" + this.password + \", projects=\" + this.projects + \")\";\n        }\n    }\n```\n\n### @Accessors\n\n可标注在类或属性上，当然最实用的功能还是标注到类上。\n\n**标注到类上**，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如：\n\n```java\nnew User().setPassword(\"gaga\").setUsername(\"haha\");\n```\n\nfluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：\n\n```java\nUser user = new User().password(\"gaga\").username(\"haha\");\nString password = user.password();\nString username = user.username();\n```\n\n**标注到属性上**，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。\n\n如：\n\n```java\n@Accessors(prefix = \"a\")\n@Getter\n@Setter\nprivate String aUsername = \"gaga\";\n```\n\n编译之后为\n\n```java\npublic String getUsername() {\n  \treturn aUsername;\n}\npublic void setUsername(String aUsername) {\n  \tthis.aUsername = aUsername;\n}\n```\n\n以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h1><p><a href=\"https://projectlombok.org/\" target=\"_blank\" rel=\"noopener\">Project Lombok</a> is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as <code>val</code>, and much more.</p>\n<p>这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。<a id=\"more\"></a></p>\n<p>下面简单介绍一些在开发中常用的注解。</p>\n<h2 id=\"Lombok常用注解\"><a href=\"#Lombok常用注解\" class=\"headerlink\" title=\"Lombok常用注解\"></a>Lombok常用注解</h2><h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"@Getter\"></a>@Getter</h3><p>可标注到类或属性上，标注到类上表示此类中的所有属性生成getter方法，标注到某个属性上，表示此属性生成getter方法。</p>\n<h3 id=\"Setter\"><a href=\"#Setter\" class=\"headerlink\" title=\"@Setter\"></a>@Setter</h3><p>和@Getter类似，可标注到类或属性上，标注到类上表示此类中的所有属性生成setter方法，标注到某个属性上，表示此属性生成setter方法。</p>\n<h3 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"@ToString\"></a>@ToString</h3><p>只能标注到类上，相当于是重写此类的toString方法。</p>\n<h3 id=\"EqualsAndHashCode\"><a href=\"#EqualsAndHashCode\" class=\"headerlink\" title=\"@EqualsAndHashCode\"></a>@EqualsAndHashCode</h3><p>只能标注到类上，相当于是重写此类的hashCode和equals方法。</p>\n<h3 id=\"NoArgsConstructor\"><a href=\"#NoArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor\"></a>@NoArgsConstructor</h3><p>只能标注到类上，生成无参的构造方法。</p>\n<h3 id=\"Data\"><a href=\"#Data\" class=\"headerlink\" title=\"@Data\"></a>@Data</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能。</p>\n<h3 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a>@Value</h3><p>只能标注到类上，综合@Getter，@Setter，@ToString，@EqualsAndHashCode，@NoArgsConstructor五个注解的功能，和@Data不同的是，默认将所有属性定义成final的，也就是只会生成getter方法，不会生成setter方法，如果不需要final，则给属性加上@NonFinal注解即可。</p>\n<h3 id=\"AllArgsConstructor\"><a href=\"#AllArgsConstructor\" class=\"headerlink\" title=\"@AllArgsConstructor\"></a>@AllArgsConstructor</h3><p>只能标注到类上，生成包含所有属性的构造方法，使用此注解时建议和@NoArgsConstructor结合使用，否则此类将没有无参的构造方法。</p>\n<h3 id=\"RequiredArgsConstructor\"><a href=\"#RequiredArgsConstructor\" class=\"headerlink\" title=\"@RequiredArgsConstructor\"></a>@RequiredArgsConstructor</h3><p>只能标注到类上，会生成一个包含常量，和标识了@NotNull的变量 的构造方法。生成的构造方法是private，如何想要对外提供使用可以使用staticName选项生成一个static方法。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span>(staticName = <span class=\"string\">\"passwd\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码编译后对应下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">User</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> User <span class=\"title\">passwd</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Builder\"><a href=\"#Builder\" class=\"headerlink\" title=\"@Builder\"></a>@Builder</h3><p>只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User buildUser = User.builder().password(<span class=\"string\">\"haha\"</span>).username(<span class=\"string\">\"gaga\"</span>).build();</span><br></pre></td></tr></table></figure>\n<p>可配合@Singular注解使用，@Singular注解使用在jdk内部集合类型的属性，Map类型的属性以及<a href=\"https://github.com/google/guava\" target=\"_blank\" rel=\"noopener\">Guava</a>的<code>com.google.common.collect</code> 的属性上。例如 未标注@Singular的属性，一般setter时，会直接覆盖原来的引用，标注了@Singular的属性，集合属性支持添加操作，会在属性原来的基础上增加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserBuilder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> ArrayList&lt;String&gt; projects;</span><br><span class=\"line\">        UserBuilder() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">username</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">password</span><span class=\"params\">(String password)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">project</span><span class=\"params\">(String project)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span>) <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.projects.add(project);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">projects</span><span class=\"params\">(Collection&lt;? extends String&gt; projects)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span>) <span class=\"keyword\">this</span>.projects = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.projects.addAll(projects);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> User.<span class=\"function\">UserBuilder <span class=\"title\">clearProjects</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.projects != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.projects.clear();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            Set&lt;String&gt; projects;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.projects == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : <span class=\"keyword\">this</span>.projects.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                    projects = java.util.Collections.emptySet();</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                    projects = java.util.Collections.singleton(<span class=\"keyword\">this</span>.projects.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    projects = <span class=\"keyword\">new</span> java.util.LinkedHashSet&lt;String&gt;(<span class=\"keyword\">this</span>.projects.size() &lt; <span class=\"number\">1073741824</span> ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.projects.size() + (<span class=\"keyword\">this</span>.projects.size() - <span class=\"number\">3</span>) / <span class=\"number\">3</span> : Integer.MAX_VALUE);</span><br><span class=\"line\">                    projects.addAll(<span class=\"keyword\">this</span>.projects);</span><br><span class=\"line\">                    projects = java.util.Collections.unmodifiableSet(projects);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(username, password, projects);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"User.UserBuilder(username=\"</span> + <span class=\"keyword\">this</span>.username + <span class=\"string\">\", password=\"</span> + <span class=\"keyword\">this</span>.password + <span class=\"string\">\", projects=\"</span> + <span class=\"keyword\">this</span>.projects + <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Accessors\"><a href=\"#Accessors\" class=\"headerlink\" title=\"@Accessors\"></a>@Accessors</h3><p>可标注在类或属性上，当然最实用的功能还是标注到类上。</p>\n<p><strong>标注到类上</strong>，chain属性设置为true时，类的所有属性的setter方法返回值将为this，用来支持setter方法的链式写法。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> User().setPassword(<span class=\"string\">\"gaga\"</span>).setUsername(<span class=\"string\">\"haha\"</span>);</span><br></pre></td></tr></table></figure>\n<p>fluent属性设置为true时，类的所有getter，setter方法将省略get和set前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User().password(<span class=\"string\">\"gaga\"</span>).username(<span class=\"string\">\"haha\"</span>);</span><br><span class=\"line\">String password = user.password();</span><br><span class=\"line\">String username = user.username();</span><br></pre></td></tr></table></figure>\n<p><strong>标注到属性上</strong>，使用prefix设置需要省略的属性生成getter，setter方法时的前缀，且属性必须为驼峰式命名。</p>\n<p>如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Accessors</span>(prefix = <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String aUsername = <span class=\"string\">\"gaga\"</span>;</span><br></pre></td></tr></table></figure>\n<p>编译之后为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> aUsername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String aUsername)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.aUsername = aUsername;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上一些常用的lombok的用法介绍完了，在日常的开发或者自己的练习中，使用lombok并结合各版本的jdk特性，将更大的提高开发效率，提高开发质量。</p>\n","slug":"常用排序算法-Java版","updated":"2018-09-30T00:50:03.000Z","comments":true,"link":"","permalink":"/2017/09/07/常用排序算法-Java版/","excerpt":"LombokProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as val, and much more. 这是lombok官网的解释，大概意思是说lombok项目是一个java库，会自动处理代码的编译，比如你不用写getter方法，它就会自动帮你实现。","categories":[{"name":"开发工具框架","slug":"开发工具框架","permalink":"/categories/开发工具框架/"}],"tags":[{"name":"开发工具框架","slug":"开发工具框架","permalink":"/tags/开发工具框架/"}]},{"title":"Docker学习笔记","date":"2017-06-16T11:24:41.000Z","path":"2017/06/16/Docker学习笔记/","text":"[TOC] Docker基本操作Docker简介Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。 Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布 在服务型环境中部署和调整数据库或其他的后台应用 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境 Docker的优点 简化程序 Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。过去需要数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。 避免选择恐惧症 Docker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个镜像部署。 节省开支 云计算时代的到来，使开发者不必为了追求效果而配置高额的硬件，Docker改变了高性能必然高价格的思维定势。Docker与云的结合，让云空间得到更充分的利用，不仅解决了硬件管理的问题，也改变了虚拟化的方式。 Centos的Docker安装与启动 检查Linux版本 1[docker@localhost ~]$ uname -r Docker要求Centos系统的内核版本高于3.10 安装Docker 切换到root用户，更新系统 1[root@localhost ~]# yum update 安装Docker 1[root@localhost ~]# yum -y install docker Docker软件包和依赖包已经包含在默认的Centos-Extras软件源里了。 如果这种方式不能安装，也可使用下面的命令进行安装 1[root@localhost ~]# curl -fsSL https://get.docker.com/ | sh 执行这个脚本后会添加docker.repo源并安装Docker 注：若安装失败，重新使用上面命令安装时有时会报错，只需要去家目录下的.docker目录中将docker的相关文件删除，然后重新执行命令下载即可。 启动Docker服务 1[root@localhost ~]# service docker start 测试 1[docker@localhost ~]$ docker run hello-world 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器中运行 Docker的基本使用 查看Docker常用命令 1[docker@localhost ~]$ docker 或者 1[docker@localhost ~]$ docker --help 如我们需要查看其中某个命令的使用方法，可使用以下命令 1[docker@localhost ~]$ docker run --help 运行一个web应用 我们在Docker容器中运行一个Python Flask应用来运行一个web应用 1[docker@localhost ~]$ docker run -d -P training/webapp python app.py 我们先来看看之前执行docker run –help命令后的结果吧 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS: 代表run命令的一些参数 IMAGE: 镜像名 COMMAND: 运行镜像之后要执行的命令 ARG…: 命令需要的一些参数 好了，我们现在来看看刚刚我们运行一个web应用的命令 -d, –detach=false Run container in background and print container ID 让容器在后台运行，默认是关闭的 -P, –publish-all=false Publish all exposed ports to random ports 让容器内部使用的网络端口映射到我们使用的主机上，默认是关闭的 注意: 我们这里用的是大写的-P 小写的-p手动将容器端口映射到宿主机上的端口，如 1[docker@localhost ~]$ docker run -d -p 5000:5000 training/webapp python app.py 查看WEB应用容器查看正在运行的容器123[docker@localhost ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf5d5071807a8 training/webapp \"python app.py\" 13 seconds ago Up 12 seconds 0.0.0.0:32768-&gt;5000/tcp prickly_davinci 查看所有已构建的容器1docker ps -a 包括正在运行，已停止的等多个容器。 结果中有容器ID，镜像名，端口，容器名等信息，其中端口显示了prickly_davinci容器端口的映射情况，此时映射的端口是容器自动做的映射，如果我们运行时没使用-P，而是使用-p手动映射，此处则显示手动指定的端口。其次容器名称此处为容器自动指定的，我们可以通过–name来手动指定，如 1[docker@localhost ~]$ docker run -d -p 5000:5000 --name webapp training/webapp python app.py 上面默认都是绑定tcp端口，如果要绑定UDP端口，可以在端口后面加上/udp 1[docker@localhost ~]$ docker run -d -p 5000:5000/udp --name webapp training/webapp python app.py 查看容器端口映射 使用容器ID查看容器端口映射情况 12[docker@localhost ~]$ docker port f5d5071807a85000/tcp -&gt; 0.0.0.0:32768 使用容器名称查看端口映射情况 12[docker@localhost ~]$ docker port prickly_davinci5000/tcp -&gt; 0.0.0.0:32768 查看具体某个端口的映射情况 12[docker@localhost docker]$ docker port tomcat 80800.0.0.0:8080 接下来凡是使用容器标识操作的都使用容器名称，并且容器ID也支持相同的命令操 查看WEB应用程序日志1[docker@localhost ~]$ docker logs -f modest_banach -f: 让docker logs像使用tail -f一样来输出容器内部的标准输出 查看WEB应用程序容器的进程1[docker@localhost ~]$ docker top modest_banach 检查WEB应用程序1[docker@localhost ~]$ docker inspect modest_banach 停止WEB应用程序1[docker@localhost ~]$ docker stop modest_banach 启动WEB应用容器1[docker@localhost ~]$ docker start modest_banach 重启WEB应用容器1[docker@localhost ~]$ docker restart modest_banach 注：正在运行的容器我们可以使用restart来重启 移除WEB应用容器1[docker@localhost ~]$ docker rm modest_banach 注：移除容器时，容器必须是停止状态。 Docker镜像的使用查看本地镜像列表12[docker@localhost ~]$ docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 各个选项说明： REPOSITORY: 表示镜像的仓库源 TAG: 镜像的标签 IMAGE ID: 镜像ID CREATED: 镜像创建时间 SIZE: 镜像大小 同一个仓库源可以有多个TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10,14.04等多个不同的版本，我们可以使用REPOSITORY:TAG来定义不同的镜像，如 1[docker@localhost ~]$ docker run -t -i ubuntu:15.10 /bin/bash 如果不指定镜像的版本标签，docker将默认使用latest镜像 获取一个新的镜像1[docker@localhost ~]$ docker pull ubuntu:15.10 查找镜像12[docker@localhost ~]$ docker search httpdNAME DESCRIPTION STARS OFFICIAL AUTOMATED NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否是docker官方发布 拖取镜像1[docker@localhost ~]$ docker pull httpd 运行镜像1[docker@localhost ~]$ docker run httpd 自定义镜像创建镜像当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改： 1、从已经创建的容器中更新镜像，并且提交这个镜像 2、使用Dockerfile指令来创建一个新的镜像 更新镜像在更新镜像之前，我们先用以下命令启动容器，在容器中使用apt-get update命令更新，完成操作后使用exit退出容器。 12[docker@localhost ~]$ docker run -t -i ubuntu:15.10 /bin/bashroot@2d60a31b8bdf:/# apt-get update 提交容器副本12[docker@localhost ~]$ docker commit -m=\"has update\" -a=\"ubuntu/update\" 2d60a31b8bdf ubuntu:v2ea547a1aa6de52e24092ff3ca13ae7ae58cd35123e2e58e6f3d784208af7ef5e -m: 提交的描述信息 -a: 指定镜像作者 2d60a31b8bdf: 容器ID runoob/ubuntu:v2: 指定要创建的目标镜像名 构建镜像创建Dockerfile，使用docker build命令来创建一个新的镜像 1234567891011[docker@localhost docker]$ cat DockerfileFROM centos:6.7MAINTAINER Fisher \"artislong@haha.com\"RUN /bin/echo 'root:123456' |chpasswdRUN useradd dockerRUN /bin/echo 'docker:123456' |chpasswdRUN /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" &gt;/etc/default/localEXPOSE 22EXPOSE 80CMD /usr/sbin/sshd -D Dockerfile是一个文本格式的配置文件，它由一行行命令语句（指令）组成，并且支持以#开头的注释行 每个指令都会在镜像上创建一个新的层，每个指令的前缀都必须大写。 第一条FROM，指定使用哪个镜像源 RUN指令告诉docker在镜像内执行命令，安装了什么。。。 然后我们通过Dockerfile文件来构建一个镜像 1[docker@localhost docker]$ docker build -t runoob/centos:6.7 . 千万不要忽略最后面的 “.”，它表示使用当前目录下的Dockerfile文件 -t: 指定要创建的目标镜像名 ​ 我们可以使用新的镜像来创建容器 123[docker@localhost docker]$ docker run -t -i runoob/centos:6.7 /bin/bash[root@ebd742bf9af0 /]# id dockeruid=500(docker) gid=500(docker) groups=500(docker) 从上面看到新镜像已经包含了我们创建的用户docker 设置镜像标签1[docker@localhost docker]$ docker tag f38a8f197ee4 runoob/centos:dev docker tag 镜像ID，镜像源名和新的标签名 Docker安装Nginx创建Nginx目录，用于存放后面相关文件1[docker@localhost ~]$ mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf www目录将映射为nginx容器配置的虚拟目录 logs目录将映射为nginx容器的日志目录 conf目录里的配置文件将映射为nginx容器的配置文件 查找Docker Hub上的nginx镜像1[docker@localhost nginx]$ docker search nginx 拉取官方nginx镜像1[docker@localhost nginx]$ docker pull nginx 查看nginx本地镜像1[docker@localhost nginx]$ docker images nginx 使用nginx镜像运行容器1[docker@localhost nginx]$ docker run -i -t -d -p 80:8081 --name nginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs -d nginx -p 80:8081: 将容器的80端口映射到宿主机的8081端口 -name nginx: 将容器命名为nginx -v $PWD/www:/www: 将主机中当前目录下的www目录挂载到容器的/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf: 将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs: 将主机中当前目录下的logs挂载到容器的/wwwlogs 查看容器启动情况1[docker@localhost nginx]$ docker ps 通过浏览器访问访问路径为: http://主机ip:8081/ ，就可访问nginx Docker安装Tomcat创建tomcat的相关目录1[docker@localhost ~]$ mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf 查找Docker Hub上的tomcat镜像1[docker@localhost ~]$ docker search tomcat 拉取官方tomcat镜像1[docker@localhost ~]$ docker pull tomcat 创建测试文件 在~/tomcat/webapps目录下创建test目录 1[docker@localhost webapps]$ mkdir test 进入test目录，编写测试页面 1[docker@localhost test]$ vi index.html index.html文件内容： 12345678910&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;docker中的tomcat测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello, World! &lt;br&gt; 哈哈哈哈，运行成功啦啦啦啦啦 &lt;/body&gt;&lt;/html&gt; 运行tomcat容器 1[docker@localhost tomcat]$ docker run --name tomcat -p 8080:8080 -v $PWD/webapps/test:/usr/local/tomcat/webapps/test -d tomcat 命令说明： -v $PWD/webapps/test:/usr/local/tomcat/webapps/test: 将主机中当前目录下的test挂载到容器的/test 启动成功后，在浏览器访问：http://主机ip:8080/test/index.html即可访问刚才编写的测试页面 —————————————————————————分割线———————————————————————– Dockerfile镜像制作Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。 基本结构Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。 一般Dockerfile文件分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。 1234567891011121314# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author:docker_user# Command format: Instruction [arguments / command] ..# 第一行必须制定基于的基础镜像FROM ubuntu# 维护者信息MAINTAINER docker_user docker_user@email.com# 镜像的操作指令RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo \"\\ndaemon off;\" &gt;&gt; /etc/nginx/nginx.conf# 容器启动时执行指令CMD /usr/sbin/nginx Dockerfile文件编写时，一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息 后面则是镜像操作指令，例如RUN指令，镜像增加新的一层，并提交。最后是CMD指令，来指定运行容器时的操作命令。 以下有两个摘自书上的Dockerfile例子： 123456# Ngnix# # VERSION 0.0.1FROM ubuntuMAINTAINER Victor Vieux &lt;victor@docker.com&gt;RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server 此Dockerfile文件是在ubuntu父镜像基础上安装inotify-tools、nginx、apache2、openssh-server软件，从而创建一个新的Nginx镜像 注 ：inotify-tools是为linux下inotify文件监控工具提供的一套c的开发接口库函数，同时还提供了一系列的命令行工具，这些工具可以用来监控文件系统的事件。 12345678910111213# Firefox over VNC# # VERSION 0.3FROM ubuntu# Install vnc, xvfb in order to reate a 'fake' display and firefoxRUN apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefoxRUN mkdir /.vnc# Setup a passwordRUN xllvnc -storepasswd 1234 ~/.vnc/passwd# Autostart firefox (might not be the best way, but it does the trick)RUN bash -c 'echo \"firefox\" &gt;&gt; /.bashrc'EXPOSE 5900CMD [\"xllvnc\", \"-forever\", \"-usepw\", \"-create\"] 此Dockerfile基于ubuntu父镜像，安装filefox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox。 指令指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。 Dockerfile指令说明 指令 说明 FROM 指定所创建镜像的基础镜像 MAINTAINER 指定维护者信息 RUN 运行命令 CMD 指定启动容器时默认执行的命令 LABEL 指定生成镜像的元数据标签信息 EXPOSE 声明镜像内服务所监听的端口 ENV 指定容器环境变量 ADD 复制指定的 \\&lt;src> 路径下的内容到容器中的 \\&lt;dest> 路径下，\\&lt;src> 可以为URL；如果为tar文件，会自动解压到 \\&lt;dest> 路径下 COPY 复制本地主机的 \\&lt;src> 路径下的内容到镜像中的 \\&lt;dest> 路径下；一般情况下推荐使用COPY而不是ADD ENTRYPOINT 指定镜像的默认入口 VOLUME 创建数据卷挂载点 USER 指定运行容器时的用户名或UID WORKDIR 配置工作目录 ARG 指定镜像内使用的参数 （例如版本号信息等） ONBUILD 配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令 STOPSIGNAL 容器退出的信号值 HEALTHCHECK 如何进行健康检查 SHELL 指定使用shell时的默认shell类型 FROM1格式为 FROM &lt;image&gt; 或FROM&lt;image&gt;:&lt;tag&gt; 第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。 MAINTAINER1格式为 MAINTAINER &lt;name&gt;, 指定维护者信息 RUN1格式为 RUN &lt;command&gt; 或 RUN [\"executable\", \"param1\", \"param2\"] RUN 将在shell终端中运行命令，即 /bin/sh -c RUN [“executable”, “param1”, “param2”]则使用exec执行。 指定使用其他终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”, “echo hello”]。 每条RUN指令将在当前镜像基础上执行指令命令，并提交为新的镜像。当命令较长时可以用 \\ 来换行。 CMD支持三种格式 使用exec执行，推荐方式 1CMD [\"executable\", \"param1\", \"param2\"] 在/bin/sh中执行，提供给需要交互的应用 1CMD command param1 param2 提供给ENTRYPOINT的默认参数 1CMD [\"param1\", \"param2\"] 指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。 如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。 EXPOSE1格式为 EXPOSE &lt;port&gt; [&lt;port&gt;...] 例如：EXPOSE 22 80 8443 就是告诉Docker服务器容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P或者-p来指定端口映射。 ENV1格式为 ENV &lt;key&gt; &lt;value&gt; 指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。例如： 1234ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH ADD1格式为 ADD &lt;src&gt; &lt;dest&gt; 该命令将复制指定的到容器中的。其中可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。 COPY1格式为 COPY &lt;src&gt; &lt;dest&gt; 复制本地主机的（为Dockerfile所在目录的相对路径，文件或目录）为容器中的。目标路径不存在时，会自动创建。 当使用本地目录为源目录时，推荐使用COPY ENTRYPOINT 使用exec执行，推荐方式 1ENTRYPOINT [\"executable\", \"param1\", \"param2\"] 在shell中执行 1ENTRYPOINT command param1 param2 配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖 每个Dockerfile中只能有一个ENTRYPOINT，当制定多个ENTRYPOINT时，只有最后一个生效。 VOLUME1格式为 VOLUME [\"/data\"] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 USER1格式为 USER daemon 指定运行容器时的用户名或UID，后续的RUN也会使用指定的用户。 当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： 1RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 要临时获取管理员权限可以使用gosu，不推荐sudo WORKDIR1格式为 WORKDIR /path/to/workdir 为后续RUN、CMD、ENTRYPOINT指令配置工作目录。 可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如: 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 上面指令最终结果为：/a/b/c ONBUILD1格式为 ONBUILD [INSTRUCTION] 配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如： 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] Dockerfile使用上面的内容创建了镜像image-A，如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在Dockerfile后面添加了两条指令，如： 1234FROM image-A# Automatically run the followingADD . /app/srcRUN /usr/local/bin/python-build --dir /app/src 使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。 高级知识资源隔离Linux内核从2.4.19开始引入namespace的概念，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace中的进程看起来拥有它们自己的隔离的全局系统资源实例。 namespace 系统调用参数 隔离内容 在容器语境下的隔离效果 UTS CLONE_NEWUTS 主机名和域名 每个容器可以有自己的hostname和domainname IPC CLONE_NEWIPC 信号量、消息队列和共享内存 每个容器有其自己的System V IPC和POSIX消息队列文件系统，因此，只有在同一个IPC的进程之间才能互相通信 PID CLONE_NEWPID 进程编号 每个PID中的namespace中的进程可以有其独立的PID；每个容器可以有其PID为1的root进程；也使得容器可以在不同的host之间迁移，因为namespace中的进程ID和host无关了。这也使得容器中的每个进程有两个PID：容器中的PID和host上的PID Network CLONE_NEWNET 网络设备、网络栈、端口等 每个容器都有其独立的网络设备，IP地址，IP路由表，/proc/net目录，端口号等。这也使得多个容器内的同一个应用都绑定在各自容器的80端口上 Mount CLONE_NEWNS 挂载点（文件系统） 每个容器能看到不同的文件系统层次结构 User CLONE_NEWUSER 用户和组ID空间 在User中的进程的用户和组ID可以和在host上不通。每个container可以有不同的user和group id；一个host上的非特权用户可以成为User中的特权用户 Docker的资源隔离也是通过这六种方式实现的，在容器启动时，Docker会创建这六种namespace实例，然后把容器中的所有进程放到这些namespace中，使得Docker容器中只能看到隔离的系统资源。 网络模式docker目前支持四种网络工作的方式，分别为host，container，none，bridge。下面简单介绍下这几种网络模式。 host模式 Docker使用了Linux的Namespaces技术来进行资源隔离，如网卡、路由、进程等。如果启动容器的时候使用host模式，那么容器不会自己去创建一个独立的Network Namespace，而是与主机共用一个Network Namespace。容器也不会虚拟出自己的网卡、IP等，而是使用宿主机的IP和端口。 container模式 container模式指定创建的新的容器和已经存在的一个容器共享一个Network Namespace。container模式通过-net=container:NAME_OR_ID指定共享的容器。 none模式 在这种模式下，容器拥有自己的Network Namespace，但是不做任何网络配置，需要我们自己给容器添加网卡、IP等。 bridge模式 bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到虚拟网桥上，实现容器和容器的主机的互连。​","raw":"---\nlayout: post\ntitle: Docker学习笔记\ndate: 2017-6-16 19:24:41\ntags: Docker,Dockerfile\ncategories: Docker\ntoc: true\ndescription:\n---\n\n[TOC]\n\n# Docker基本操作\n\n## Docker简介\n\nDocker 是一个开源的应用容器引擎，基于 [Go 语言](http://www.runoob.com/go/go-tutorial.html) 并遵从Apache2.0协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\nDocker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。\n<!--more-->\n## Docker的应用场景\n\n- Web 应用的自动化打包和发布。\n- 自动化测试和持续集成、发布\n- 在服务型环境中部署和调整数据库或其他的后台应用\n- 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境\n\n## Docker的优点\n\n- 简化程序\n\nDocker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。过去需要数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。\n\n- 避免选择恐惧症\n\nDocker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个镜像部署。\n\n- 节省开支\n\n云计算时代的到来，使开发者不必为了追求效果而配置高额的硬件，Docker改变了高性能必然高价格的思维定势。Docker与云的结合，让云空间得到更充分的利用，不仅解决了硬件管理的问题，也改变了虚拟化的方式。\n\n## Centos的Docker安装与启动\n\n- 检查Linux版本\n\n```\n[docker@localhost ~]$ uname -r\n```\n\nDocker要求Centos系统的内核版本高于3.10\n\n- 安装Docker\n\n切换到root用户，更新系统\n\n```\n[root@localhost ~]# yum update\n```\n\n安装Docker\n\n```\n[root@localhost ~]# yum -y install docker\n```\n\nDocker软件包和依赖包已经包含在默认的Centos-Extras软件源里了。\n\n如果这种方式不能安装，也可使用下面的命令进行安装\n\n```\n[root@localhost ~]# curl -fsSL https://get.docker.com/ | sh\n```\n\n执行这个脚本后会添加docker.repo源并安装Docker\n\n注：若安装失败，重新使用上面命令安装时有时会报错，只需要去家目录下的.docker目录中将docker的相关文件删除，然后重新执行命令下载即可。\n\n- 启动Docker服务\n\n```\n[root@localhost ~]# service docker start\n```\n\n- 测试\n\n```\n[docker@localhost ~]$ docker run hello-world\n```\n\n由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器中运行\n\n> Docker的基本使用\n\n- 查看Docker常用命令\n\n```\n[docker@localhost ~]$ docker\n```\n\n或者\n\n```\n[docker@localhost ~]$ docker --help\n```\n\n如我们需要查看其中某个命令的使用方法，可使用以下命令\n\n```\n[docker@localhost ~]$ docker run --help\n```\n\n- 运行一个web应用\n\n我们在Docker容器中运行一个Python Flask应用来运行一个web应用\n\n```\n[docker@localhost ~]$ docker run -d -P training/webapp python app.py\n```\n\n我们先来看看之前执行docker run --help命令后的结果吧\n\n```\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n\nOPTIONS: 代表run命令的一些参数\n\nIMAGE: 镜像名\n\nCOMMAND: 运行镜像之后要执行的命令\n\nARG...: 命令需要的一些参数\n\n好了，我们现在来看看刚刚我们运行一个web应用的命令\n\n-d, --detach=false          Run container in background and print container ID\n\n让容器在后台运行，默认是关闭的\n\n-P, --publish-all=false     Publish all exposed ports to random ports\n\n让容器内部使用的网络端口映射到我们使用的主机上，默认是关闭的\n\n注意: 我们这里用的是大写的-P\n\n小写的-p手动将容器端口映射到宿主机上的端口，如\n\n```\n[docker@localhost ~]$ docker run -d -p 5000:5000 training/webapp python app.py\n```\n\n### 查看WEB应用容器\n\n#### 查看正在运行的容器\n\n```\n[docker@localhost ~]$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES\nf5d5071807a8        training/webapp     \"python app.py\"     13 seconds ago      Up 12 seconds       0.0.0.0:32768->5000/tcp   prickly_davinci\n```\n\n#### 查看所有已构建的容器\n\n~~~shell\ndocker ps -a\n~~~\n\n包括正在运行，已停止的等多个容器。\n\n结果中有容器ID，镜像名，端口，容器名等信息，其中端口显示了prickly_davinci容器端口的映射情况，此时映射的端口是容器自动做的映射，如果我们运行时没使用-P，而是使用-p手动映射，此处则显示手动指定的端口。其次容器名称此处为容器自动指定的，我们可以通过--name来手动指定，如\n\n```\n[docker@localhost ~]$ docker run -d -p 5000:5000 --name webapp training/webapp python app.py\n```\n\n上面默认都是绑定tcp端口，如果要绑定UDP端口，可以在端口后面加上/udp\n\n```\n[docker@localhost ~]$ docker run -d -p 5000:5000/udp --name webapp training/webapp python app.py\n```\n\n#### 查看容器端口映射\n\n- 使用容器ID查看容器端口映射情况\n\n```\n[docker@localhost ~]$ docker port f5d5071807a8\n5000/tcp -> 0.0.0.0:32768\n```\n\n- 使用容器名称查看端口映射情况\n\n```\n[docker@localhost ~]$ docker port prickly_davinci\n5000/tcp -> 0.0.0.0:32768\n```\n\n- 查看具体某个端口的映射情况\n\n```\n[docker@localhost docker]$ docker port tomcat 8080\n0.0.0.0:8080\n```\n\n**接下来凡是使用容器标识操作的都使用容器名称，并且容器ID也支持相同的命令操**\n\n#### 查看WEB应用程序日志\n\n```\n[docker@localhost ~]$ docker logs -f modest_banach\n```\n\n-f: 让docker logs像使用tail -f一样来输出容器内部的标准输出\n\n#### 查看WEB应用程序容器的进程\n\n```\n[docker@localhost ~]$ docker top modest_banach\n```\n#### 检查WEB应用程序\n\n```\n[docker@localhost ~]$ docker inspect modest_banach\n```\n#### 停止WEB应用程序\n\n```\n[docker@localhost ~]$ docker stop modest_banach\n```\n#### 启动WEB应用容器\n\n```\n[docker@localhost ~]$ docker start modest_banach\n```\n#### 重启WEB应用容器\n\n```\n[docker@localhost ~]$ docker restart modest_banach\n```\n\n**注**：正在运行的容器我们可以使用restart来重启\n\n#### 移除WEB应用容器\n\n```\n[docker@localhost ~]$ docker rm modest_banach\n```\n\n**注：**移除容器时，容器必须是停止状态。\n\n## Docker镜像的使用\n\n### 查看本地镜像列表\n\n```\n[docker@localhost ~]$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE\n```\n\n各个选项说明：\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG: 镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像创建时间\n- SIZE: 镜像大小\n\n同一个仓库源可以有多个TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10,14.04等多个不同的版本，我们可以使用REPOSITORY:TAG来定义不同的镜像，如\n\n```\n[docker@localhost ~]$ docker run -t -i ubuntu:15.10 /bin/bash\n```\n\n如果不指定镜像的版本标签，docker将默认使用latest镜像\n\n### 获取一个新的镜像\n\n```\n[docker@localhost ~]$ docker pull ubuntu:15.10\n```\n### 查找镜像\n\n```\n[docker@localhost ~]$ docker search httpd\nNAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\n```\n\nNAME: 镜像仓库源的名称\n\nDESCRIPTION: 镜像的描述\n\nOFFICIAL: 是否是docker官方发布\n\n### 拖取镜像\n\n```\n[docker@localhost ~]$ docker pull httpd\n```\n### 运行镜像\n\n```\n[docker@localhost ~]$ docker run httpd\n```\n### 自定义镜像\n\n#### 创建镜像\n\n当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：\n\n1、从已经创建的容器中更新镜像，并且提交这个镜像\n\n2、使用Dockerfile指令来创建一个新的镜像\n\n#### 更新镜像\n\n在更新镜像之前，我们先用以下命令启动容器，在容器中使用apt-get update命令更新，完成操作后使用exit退出容器。\n\n```\n[docker@localhost ~]$ docker run -t -i ubuntu:15.10 /bin/bash\nroot@2d60a31b8bdf:/# apt-get update\n```\n#### 提交容器副本\n\n```\n[docker@localhost ~]$ docker commit -m=\"has update\" -a=\"ubuntu/update\" 2d60a31b8bdf ubuntu:v2\nea547a1aa6de52e24092ff3ca13ae7ae58cd35123e2e58e6f3d784208af7ef5e\n```\n\n-m: 提交的描述信息\n\n-a: 指定镜像作者\n\n2d60a31b8bdf: 容器ID\n\nrunoob/ubuntu:v2: 指定要创建的目标镜像名\n\n#### 构建镜像\n\n创建Dockerfile，使用docker build命令来创建一个新的镜像\n\n```\n[docker@localhost docker]$ cat Dockerfile\nFROM    centos:6.7\nMAINTAINER      Fisher \"artislong@haha.com\"\n\nRUN     /bin/echo 'root:123456' |chpasswd\nRUN     useradd docker\nRUN     /bin/echo 'docker:123456' |chpasswd\nRUN     /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" >/etc/default/local\nEXPOSE  22\nEXPOSE  80\nCMD     /usr/sbin/sshd -D\n```\n\nDockerfile是一个文本格式的配置文件，它由一行行命令语句（指令）组成，并且支持以#开头的注释行\n\n每个指令都会在镜像上创建一个新的层，每个指令的前缀都必须大写。\n\n第一条FROM，指定使用哪个镜像源\n\nRUN指令告诉docker在镜像内执行命令，安装了什么。。。\n\n然后我们通过Dockerfile文件来构建一个镜像\n\n```\n[docker@localhost docker]$ docker build -t runoob/centos:6.7 .\n```\n\n千万不要忽略最后面的 “.”，它表示使用当前目录下的Dockerfile文件\n\n-t: 指定要创建的目标镜像名\n\n​\n\n我们可以使用新的镜像来创建容器\n\n```\n[docker@localhost docker]$ docker run -t -i runoob/centos:6.7 /bin/bash\n[root@ebd742bf9af0 /]# id docker\nuid=500(docker) gid=500(docker) groups=500(docker)\n```\n\n从上面看到新镜像已经包含了我们创建的用户docker\n\n#### 设置镜像标签\n\n```\n[docker@localhost docker]$ docker tag f38a8f197ee4 runoob/centos:dev\n```\n\ndocker tag 镜像ID，镜像源名和新的标签名\n\n## Docker安装Nginx\n\n### 创建Nginx目录，用于存放后面相关文件\n\n```\n[docker@localhost ~]$ mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf\n```\n\nwww目录将映射为nginx容器配置的虚拟目录\n\nlogs目录将映射为nginx容器的日志目录\n\nconf目录里的配置文件将映射为nginx容器的配置文件\n\n### 查找Docker Hub上的nginx镜像\n\n```\n[docker@localhost nginx]$ docker search nginx\n```\n\n### 拉取官方nginx镜像\n\n```\n[docker@localhost nginx]$ docker pull nginx\n```\n\n### 查看nginx本地镜像\n\n```\n[docker@localhost nginx]$ docker images nginx\n```\n\n### 使用nginx镜像\n\n#### 运行容器\n\n```\n[docker@localhost nginx]$ docker run -i -t -d -p 80:8081 --name nginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx\n```\n\n-p 80:8081: 将容器的80端口映射到宿主机的8081端口\n\n-name nginx: 将容器命名为nginx\n\n-v $PWD/www:/www: 将主机中当前目录下的www目录挂载到容器的/www\n\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf: 将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n\n-v $PWD/logs:/wwwlogs: 将主机中当前目录下的logs挂载到容器的/wwwlogs\n\n#### 查看容器启动情况\n\n```\n[docker@localhost nginx]$ docker ps\n```\n\n#### 通过浏览器访问\n\n访问路径为: http://主机ip:8081/ ，就可访问nginx\n\n## Docker安装Tomcat\n\n### 创建tomcat的相关目录\n\n```\n[docker@localhost ~]$ mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf\n```\n\n### 查找Docker Hub上的tomcat镜像\n\n```\n[docker@localhost ~]$ docker search tomcat\n```\n\n### 拉取官方tomcat镜像\n\n```\n[docker@localhost ~]$ docker pull tomcat\n```\n\n### 创建测试文件\n\n- 在~/tomcat/webapps目录下创建test目录\n\n  ~~~\n  [docker@localhost webapps]$ mkdir test\n  ~~~\n\n- 进入test目录，编写测试页面\n\n  ~~~\n  [docker@localhost test]$ vi index.html\n  ~~~\n\n  index.html文件内容：\n\n  ~~~html\n  <html>\n          <head>\n                  <meta charset=\"utf-8\">\n                  <title>docker中的tomcat测试</title>\n          </head>\n          <body>\n                  Hello, World! <br>\n                  哈哈哈哈，运行成功啦啦啦啦啦\n          </body>\n  </html>\n  ~~~\n\n- 运行tomcat容器\n\n  ~~~\n  [docker@localhost tomcat]$ docker run --name tomcat -p 8080:8080 -v $PWD/webapps/test:/usr/local/tomcat/webapps/test -d tomcat\n  ~~~\n\n  命令说明：\n\n  -v $PWD/webapps/test:/usr/local/tomcat/webapps/test: 将主机中当前目录下的test挂载到容器的/test\n\n  启动成功后，在浏览器访问：http://主机ip:8080/test/index.html即可访问刚才编写的测试页面\n\n\n---------------------------------------------------------------------------分割线-----------------------------------------------------------------------\n\n# Dockerfile镜像制作\n\nDockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。\n\n## 基本结构\n\nDockerfile由一行行命令语句组成，并且支持以#开头的注释行。\n\n一般Dockerfile文件分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。\n\n```dockerfile\n# This dockerfile uses the ubuntu image\n# VERSION 2 - EDITION 1\n# Author:docker_user\n# Command format: Instruction [arguments / command] ..\n# 第一行必须制定基于的基础镜像\nFROM ubuntu\n# 维护者信息\nMAINTAINER docker_user docker_user@email.com\n# 镜像的操作指令\nRUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list\nRUN apt-get update && apt-get install -y nginx\nRUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf\n# 容器启动时执行指令\nCMD /usr/sbin/nginx\n```\n\nDockerfile文件编写时，一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息\n\n后面则是镜像操作指令，例如RUN指令，镜像增加新的一层，并提交。最后是CMD指令，来指定运行容器时的操作命令。\n\n以下有两个摘自书上的Dockerfile例子：\n\n```dockerfile\n# Ngnix\n# \n# VERSION 0.0.1\nFROM ubuntu\nMAINTAINER Victor Vieux <victor@docker.com>\nRUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server\n```\n\n此Dockerfile文件是在ubuntu父镜像基础上安装inotify-tools、nginx、apache2、openssh-server软件，从而创建一个新的Nginx镜像\n\n**注** ：inotify-tools是为linux下inotify文件监控工具提供的一套c的开发接口库函数，同时还提供了一系列的命令行工具，这些工具可以用来监控文件系统的事件。\n\n~~~dockerfile\n# Firefox over VNC\n# \n# VERSION 0.3\nFROM ubuntu\n# Install vnc, xvfb in order to reate a 'fake' display and firefox\nRUN apt-get update && apt-get install -y xllvnc xvfb firefox\nRUN mkdir /.vnc\n# Setup a password\nRUN xllvnc -storepasswd 1234 ~/.vnc/passwd\n# Autostart firefox (might not be the best way, but it does the trick)\nRUN bash -c 'echo \"firefox\" >> /.bashrc'\nEXPOSE 5900\nCMD [\"xllvnc\", \"-forever\", \"-usepw\", \"-create\"]\n~~~\n\n此Dockerfile基于ubuntu父镜像，安装filefox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox。\n\n## 指令\n\n指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。\n\nDockerfile指令说明\n\n|    指令     |                             说明                             |\n| :---------: | :----------------------------------------------------------: |\n|    FROM     |                   指定所创建镜像的基础镜像                   |\n| MAINTAINER  |                        指定维护者信息                        |\n|     RUN     |                           运行命令                           |\n|     CMD     |                 指定启动容器时默认执行的命令                 |\n|    LABEL    |                 指定生成镜像的元数据标签信息                 |\n|   EXPOSE    |                  声明镜像内服务所监听的端口                  |\n|     ENV     |                       指定容器环境变量                       |\n|     ADD     | 复制指定的 \\<src\\> 路径下的内容到容器中的 \\<dest\\> 路径下，\\<src\\> 可以为URL；如果为tar文件，会自动解压到 \\<dest\\> 路径下 |\n|    COPY     | 复制本地主机的 \\<src\\> 路径下的内容到镜像中的 \\<dest\\> 路径下；一般情况下推荐使用COPY而不是ADD |\n| ENTRYPOINT  |                      指定镜像的默认入口                      |\n|   VOLUME    |                       创建数据卷挂载点                       |\n|    USER     |                 指定运行容器时的用户名或UID                  |\n|   WORKDIR   |                         配置工作目录                         |\n|     ARG     |          指定镜像内使用的参数 （例如版本号信息等）           |\n|   ONBUILD   | 配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令 |\n| STOPSIGNAL  |                       容器退出的信号值                       |\n| HEALTHCHECK |                       如何进行健康检查                       |\n|    SHELL    |                指定使用shell时的默认shell类型                |\n\n### FROM\n\n~~~dockerfile\n格式为 FROM <image> 或FROM<image>:<tag>\n~~~\n\n第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。\n\n### MAINTAINER\n\n~~~dockerfile\n格式为 MAINTAINER <name>, 指定维护者信息\n~~~\n### RUN\n\n~~~dockerfile\n格式为 RUN <command> 或 RUN [\"executable\", \"param1\", \"param2\"]\n~~~\n\nRUN <command> 将在shell终端中运行命令，即 /bin/sh -c\n\nRUN [\"executable\", \"param1\", \"param2\"]则使用exec执行。\n\n指定使用其他终端可以通过第二种方式实现，例如 RUN [\"/bin/bash\", \"-c\", \"echo hello\"]。\n\n每条RUN指令将在当前镜像基础上执行指令命令，并提交为新的镜像。当命令较长时可以用 \\ 来换行。\n\n### CMD\n\n支持三种格式\n\n- 使用exec执行，推荐方式\n\n  ~~~dockerfile\n  CMD [\"executable\", \"param1\", \"param2\"]\n  ~~~\n\n- 在/bin/sh中执行，提供给需要交互的应用\n\n  ~~~dockerfile\n  CMD command param1 param2\n  ~~~\n\n- 提供给ENTRYPOINT的默认参数\n\n  ~~~dockerfile\n  CMD [\"param1\", \"param2\"]\n  ~~~\n\n指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。\n\n如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。\n\n### EXPOSE\n\n~~~dockerfile\n格式为 EXPOSE <port> [<port>...]\n~~~\n\n例如：EXPOSE 22 80 8443\n\n就是告诉Docker服务器容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P或者-p来指定端口映射。\n\n### ENV\n\n~~~dockerfile\n格式为 ENV <key> <value>\n~~~\n\n指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。例如：\n\n~~~dockerfile\nENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && ...\nENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH\n~~~\n### ADD\n\n~~~dockerfile\n格式为 ADD <src> <dest>\n~~~\n\n该命令将复制指定的<src>到容器中的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。\n\n### COPY\n\n~~~dockerfile\n格式为 COPY <src> <dest>\n~~~\n\n复制本地主机的<src>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<dest>。目标路径不存在时，会自动创建。\n\n当使用本地目录为源目录时，推荐使用COPY\n\n### ENTRYPOINT\n\n- 使用exec执行，推荐方式\n\n  ~~~dockerfile\n  ENTRYPOINT [\"executable\", \"param1\", \"param2\"]\n  ~~~\n\n- 在shell中执行\n\n  ~~~dockerfile\n  ENTRYPOINT command param1 param2\n  ~~~\n\n配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖\n\n每个Dockerfile中只能有一个ENTRYPOINT，当制定多个ENTRYPOINT时，只有最后一个生效。\n\n### VOLUME\n\n~~~dockerfile\n格式为 VOLUME [\"/data\"]\n~~~\n\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n### USER\n\n~~~dockerfile\n格式为 USER daemon\n~~~\n\n指定运行容器时的用户名或UID，后续的RUN也会使用指定的用户。\n\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：\n\n~~~dockerfile\nRUN groupadd -r postgres && useradd -r -g postgres postgres\n~~~\n\n要临时获取管理员权限可以使用gosu，不推荐sudo\n\n### WORKDIR\n\n~~~dockerfile\n格式为 WORKDIR /path/to/workdir\n~~~\n\n为后续RUN、CMD、ENTRYPOINT指令配置工作目录。\n\n可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:\n\n~~~dockerfile\nWORKDIR /a\nWORKDIR b\nWORKDIR c\nRUN pwd\n~~~\n\n上面指令最终结果为：/a/b/c\n\n### ONBUILD\n\n~~~dockerfile\n格式为 ONBUILD [INSTRUCTION]\n~~~\n\n配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如：\n\n~~~dockerfile\n[...]\nONBUILD ADD . /app/src\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n[...]\n~~~\n\nDockerfile使用上面的内容创建了镜像image-A，如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在Dockerfile后面添加了两条指令，如：\n\n~~~dockerfile\nFROM image-A\n# Automatically run the following\nADD . /app/src\nRUN /usr/local/bin/python-build --dir /app/src\n~~~\n\n使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。\n\n# 高级知识\n\n## 资源隔离\n\nLinux内核从2.4.19开始引入namespace的概念，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace中的进程看起来拥有它们自己的隔离的全局系统资源实例。\n\n| namespace | 系统调用参数  | 隔离内容                   | 在容器语境下的隔离效果                                       |\n| --------- | ------------- | -------------------------- | ------------------------------------------------------------ |\n| UTS       | CLONE_NEWUTS  | 主机名和域名               | 每个容器可以有自己的hostname和domainname                     |\n| IPC       | CLONE_NEWIPC  | 信号量、消息队列和共享内存 | 每个容器有其自己的System V IPC和POSIX消息队列文件系统，因此，只有在同一个IPC的进程之间才能互相通信 |\n| PID       | CLONE_NEWPID  | 进程编号                   | 每个PID中的namespace中的进程可以有其独立的PID；每个容器可以有其PID为1的root进程；也使得容器可以在不同的host之间迁移，因为namespace中的进程ID和host无关了。这也使得容器中的每个进程有两个PID：容器中的PID和host上的PID |\n| Network   | CLONE_NEWNET  | 网络设备、网络栈、端口等   | 每个容器都有其独立的网络设备，IP地址，IP路由表，/proc/net目录，端口号等。这也使得多个容器内的同一个应用都绑定在各自容器的80端口上 |\n| Mount     | CLONE_NEWNS   | 挂载点（文件系统）         | 每个容器能看到不同的文件系统层次结构                         |\n| User      | CLONE_NEWUSER | 用户和组ID空间             | 在User中的进程的用户和组ID可以和在host上不通。每个container可以有不同的user和group id；一个host上的非特权用户可以成为User中的特权用户 |\n\nDocker的资源隔离也是通过这六种方式实现的，在容器启动时，Docker会创建这六种namespace实例，然后把容器中的所有进程放到这些namespace中，使得Docker容器中只能看到隔离的系统资源。\n\n## 网络模式\n\ndocker目前支持四种网络工作的方式，分别为host，container，none，bridge。下面简单介绍下这几种网络模式。\n\n- host模式\n\n  Docker使用了Linux的Namespaces技术来进行资源隔离，如网卡、路由、进程等。如果启动容器的时候使用host模式，那么容器不会自己去创建一个独立的Network Namespace，而是与主机共用一个Network Namespace。容器也不会虚拟出自己的网卡、IP等，而是使用宿主机的IP和端口。\n\n- container模式\n\n  container模式指定创建的新的容器和已经存在的一个容器共享一个Network Namespace。container模式通过-net=container:NAME_OR_ID指定共享的容器。\n\n- none模式\n\n  在这种模式下，容器拥有自己的Network Namespace，但是不做任何网络配置，需要我们自己给容器添加网卡、IP等。\n\n- bridge模式\n\n  bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到虚拟网桥上，实现容器和容器的主机的互连。​","content":"<p>[TOC]</p>\n<h1 id=\"Docker基本操作\"><a href=\"#Docker基本操作\" class=\"headerlink\" title=\"Docker基本操作\"></a>Docker基本操作</h1><h2 id=\"Docker简介\"><a href=\"#Docker简介\" class=\"headerlink\" title=\"Docker简介\"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href=\"http://www.runoob.com/go/go-tutorial.html\" target=\"_blank\" rel=\"noopener\">Go 语言</a> 并遵从Apache2.0协议开源。</p>\n<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>\n<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>\n<p>Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。<br><a id=\"more\"></a></p>\n<h2 id=\"Docker的应用场景\"><a href=\"#Docker的应用场景\" class=\"headerlink\" title=\"Docker的应用场景\"></a>Docker的应用场景</h2><ul>\n<li>Web 应用的自动化打包和发布。</li>\n<li>自动化测试和持续集成、发布</li>\n<li>在服务型环境中部署和调整数据库或其他的后台应用</li>\n<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境</li>\n</ul>\n<h2 id=\"Docker的优点\"><a href=\"#Docker的优点\" class=\"headerlink\" title=\"Docker的优点\"></a>Docker的优点</h2><ul>\n<li>简化程序</li>\n</ul>\n<p>Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。过去需要数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。</p>\n<ul>\n<li>避免选择恐惧症</li>\n</ul>\n<p>Docker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应用实例工作。比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个镜像部署。</p>\n<ul>\n<li>节省开支</li>\n</ul>\n<p>云计算时代的到来，使开发者不必为了追求效果而配置高额的硬件，Docker改变了高性能必然高价格的思维定势。Docker与云的结合，让云空间得到更充分的利用，不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>\n<h2 id=\"Centos的Docker安装与启动\"><a href=\"#Centos的Docker安装与启动\" class=\"headerlink\" title=\"Centos的Docker安装与启动\"></a>Centos的Docker安装与启动</h2><ul>\n<li>检查Linux版本</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>uname -r</span><br></pre></td></tr></table></figure>\n<p>Docker要求Centos系统的内核版本高于3.10</p>\n<ul>\n<li>安装Docker</li>\n</ul>\n<p>切换到root用户，更新系统</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@localhost</span> ~]<span class=\"meta\"># yum update</span></span><br></pre></td></tr></table></figure>\n<p>安装Docker</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@localhost</span> ~]<span class=\"meta\"># yum -y install docker</span></span><br></pre></td></tr></table></figure>\n<p>Docker软件包和依赖包已经包含在默认的Centos-Extras软件源里了。</p>\n<p>如果这种方式不能安装，也可使用下面的命令进行安装</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# curl -fsSL http<span class=\"variable\">s:</span>//<span class=\"built_in\">get</span>.docker.<span class=\"keyword\">com</span>/ | <span class=\"keyword\">sh</span></span><br></pre></td></tr></table></figure>\n<p>执行这个脚本后会添加docker.repo源并安装Docker</p>\n<p>注：若安装失败，重新使用上面命令安装时有时会报错，只需要去家目录下的.docker目录中将docker的相关文件删除，然后重新执行命令下载即可。</p>\n<ul>\n<li>启动Docker服务</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]#<span class=\"built_in\"> service </span>docker start</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试</li>\n</ul>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"symbol\">@localhost</span> ~]$ docker <span class=\"built_in\">run</span> hello-world</span><br></pre></td></tr></table></figure>\n<p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器中运行</p>\n<blockquote>\n<p>Docker的基本使用</p>\n</blockquote>\n<ul>\n<li>查看Docker常用命令</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker --help</span><br></pre></td></tr></table></figure>\n<p>如我们需要查看其中某个命令的使用方法，可使用以下命令</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker <span class=\"keyword\">run</span><span class=\"bash\"> --<span class=\"built_in\">help</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行一个web应用</li>\n</ul>\n<p>我们在Docker容器中运行一个Python Flask应用来运行一个web应用</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"symbol\">@localhost</span> ~]$ docker <span class=\"built_in\">run</span> -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<p>我们先来看看之前执行docker run –help命令后的结果吧</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run <span class=\"string\">[OPTIONS]</span> IMAGE <span class=\"string\">[COMMAND]</span> <span class=\"string\">[ARG...]</span></span><br></pre></td></tr></table></figure>\n<p>OPTIONS: 代表run命令的一些参数</p>\n<p>IMAGE: 镜像名</p>\n<p>COMMAND: 运行镜像之后要执行的命令</p>\n<p>ARG…: 命令需要的一些参数</p>\n<p>好了，我们现在来看看刚刚我们运行一个web应用的命令</p>\n<p>-d, –detach=false          Run container in background and print container ID</p>\n<p>让容器在后台运行，默认是关闭的</p>\n<p>-P, –publish-all=false     Publish all exposed ports to random ports</p>\n<p>让容器内部使用的网络端口映射到我们使用的主机上，默认是关闭的</p>\n<p>注意: 我们这里用的是大写的-P</p>\n<p>小写的-p手动将容器端口映射到宿主机上的端口，如</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"symbol\">@localhost</span> ~]$ docker <span class=\"built_in\">run</span> -d -p <span class=\"number\">5000</span>:<span class=\"number\">5000</span> training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看WEB应用容器\"><a href=\"#查看WEB应用容器\" class=\"headerlink\" title=\"查看WEB应用容器\"></a>查看WEB应用容器</h3><h4 id=\"查看正在运行的容器\"><a href=\"#查看正在运行的容器\" class=\"headerlink\" title=\"查看正在运行的容器\"></a>查看正在运行的容器</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker ps</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class=\"line\">f5d5071807a8        training/webapp     <span class=\"string\">\"python app.py\"</span>     <span class=\"number\">13</span> seconds ago      Up <span class=\"number\">12</span> seconds       <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span><span class=\"symbol\">:</span><span class=\"number\">32768</span>-&gt;<span class=\"number\">5000</span>/tcp   prickly_davinci</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看所有已构建的容器\"><a href=\"#查看所有已构建的容器\" class=\"headerlink\" title=\"查看所有已构建的容器\"></a>查看所有已构建的容器</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n<p>包括正在运行，已停止的等多个容器。</p>\n<p>结果中有容器ID，镜像名，端口，容器名等信息，其中端口显示了prickly_davinci容器端口的映射情况，此时映射的端口是容器自动做的映射，如果我们运行时没使用-P，而是使用-p手动映射，此处则显示手动指定的端口。其次容器名称此处为容器自动指定的，我们可以通过–name来手动指定，如</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker <span class=\"built_in\">run</span> -d -p <span class=\"number\">5000</span>:<span class=\"number\">5000</span> <span class=\"comment\">--name webapp training/webapp python app.py</span></span><br></pre></td></tr></table></figure>\n<p>上面默认都是绑定tcp端口，如果要绑定UDP端口，可以在端口后面加上/udp</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker <span class=\"built_in\">run</span> -d -p <span class=\"number\">5000</span>:<span class=\"number\">5000</span>/udp <span class=\"comment\">--name webapp training/webapp python app.py</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"查看容器端口映射\"><a href=\"#查看容器端口映射\" class=\"headerlink\" title=\"查看容器端口映射\"></a>查看容器端口映射</h4><ul>\n<li>使用容器ID查看容器端口映射情况</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker<span class=\"built_in\"> port </span>f5d5071807a8</span><br><span class=\"line\">5000/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用容器名称查看端口映射情况</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker<span class=\"built_in\"> port </span>prickly_davinci</span><br><span class=\"line\">5000/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看具体某个端口的映射情况</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost docker]$ docker<span class=\"built_in\"> port </span>tomcat 8080</span><br><span class=\"line\">0.0.0.0:8080</span><br></pre></td></tr></table></figure>\n<p><strong>接下来凡是使用容器标识操作的都使用容器名称，并且容器ID也支持相同的命令操</strong></p>\n<h4 id=\"查看WEB应用程序日志\"><a href=\"#查看WEB应用程序日志\" class=\"headerlink\" title=\"查看WEB应用程序日志\"></a>查看WEB应用程序日志</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker logs -f modest_banach</span><br></pre></td></tr></table></figure>\n<p>-f: 让docker logs像使用tail -f一样来输出容器内部的标准输出</p>\n<h4 id=\"查看WEB应用程序容器的进程\"><a href=\"#查看WEB应用程序容器的进程\" class=\"headerlink\" title=\"查看WEB应用程序容器的进程\"></a>查看WEB应用程序容器的进程</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker top modest_banach</span><br></pre></td></tr></table></figure>\n<h4 id=\"检查WEB应用程序\"><a href=\"#检查WEB应用程序\" class=\"headerlink\" title=\"检查WEB应用程序\"></a>检查WEB应用程序</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker inspect modest_banach</span><br></pre></td></tr></table></figure>\n<h4 id=\"停止WEB应用程序\"><a href=\"#停止WEB应用程序\" class=\"headerlink\" title=\"停止WEB应用程序\"></a>停止WEB应用程序</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker stop modest_banach</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动WEB应用容器\"><a href=\"#启动WEB应用容器\" class=\"headerlink\" title=\"启动WEB应用容器\"></a>启动WEB应用容器</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker start modest_banach</span><br></pre></td></tr></table></figure>\n<h4 id=\"重启WEB应用容器\"><a href=\"#重启WEB应用容器\" class=\"headerlink\" title=\"重启WEB应用容器\"></a>重启WEB应用容器</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker restart modest_banach</span><br></pre></td></tr></table></figure>\n<p><strong>注</strong>：正在运行的容器我们可以使用restart来重启</p>\n<h4 id=\"移除WEB应用容器\"><a href=\"#移除WEB应用容器\" class=\"headerlink\" title=\"移除WEB应用容器\"></a>移除WEB应用容器</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker rm modest_banach</span><br></pre></td></tr></table></figure>\n<p><strong>注：</strong>移除容器时，容器必须是停止状态。</p>\n<h2 id=\"Docker镜像的使用\"><a href=\"#Docker镜像的使用\" class=\"headerlink\" title=\"Docker镜像的使用\"></a>Docker镜像的使用</h2><h3 id=\"查看本地镜像列表\"><a href=\"#查看本地镜像列表\" class=\"headerlink\" title=\"查看本地镜像列表\"></a>查看本地镜像列表</h3><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost ~]$ docker images</span><br><span class=\"line\">REPOSITORY          <span class=\"keyword\">TAG</span>                 <span class=\"title\">IMAGE</span> ID            CREATED             VIRTUAL SIZE</span><br></pre></td></tr></table></figure>\n<p>各个选项说明：</p>\n<ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG: 镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像创建时间</li>\n<li>SIZE: 镜像大小</li>\n</ul>\n<p>同一个仓库源可以有多个TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10,14.04等多个不同的版本，我们可以使用REPOSITORY:TAG来定义不同的镜像，如</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"meta\">@localhost</span> ~]$ docker run -t -i <span class=\"string\">ubuntu:</span><span class=\"number\">15.10</span> <span class=\"regexp\">/bin/</span>bash</span><br></pre></td></tr></table></figure>\n<p>如果不指定镜像的版本标签，docker将默认使用latest镜像</p>\n<h3 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker pull <span class=\"symbol\">ubuntu:</span><span class=\"number\">15.10</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker search httpd</span><br><span class=\"line\">NAME                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br></pre></td></tr></table></figure>\n<p>NAME: 镜像仓库源的名称</p>\n<p>DESCRIPTION: 镜像的描述</p>\n<p>OFFICIAL: 是否是docker官方发布</p>\n<h3 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker pull httpd</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行镜像\"><a href=\"#运行镜像\" class=\"headerlink\" title=\"运行镜像\"></a>运行镜像</h3><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"symbol\">@localhost</span> ~]$ docker <span class=\"built_in\">run</span> httpd</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义镜像\"><a href=\"#自定义镜像\" class=\"headerlink\" title=\"自定义镜像\"></a>自定义镜像</h3><h4 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h4><p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：</p>\n<p>1、从已经创建的容器中更新镜像，并且提交这个镜像</p>\n<p>2、使用Dockerfile指令来创建一个新的镜像</p>\n<h4 id=\"更新镜像\"><a href=\"#更新镜像\" class=\"headerlink\" title=\"更新镜像\"></a>更新镜像</h4><p>在更新镜像之前，我们先用以下命令启动容器，在容器中使用apt-get update命令更新，完成操作后使用exit退出容器。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker run -t -i <span class=\"symbol\">ubuntu:</span><span class=\"number\">15.10</span> /bin/bash</span><br><span class=\"line\">root<span class=\"variable\">@2d60a31b8bdf</span><span class=\"symbol\">:/</span><span class=\"comment\"># apt-get update</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"提交容器副本\"><a href=\"#提交容器副本\" class=\"headerlink\" title=\"提交容器副本\"></a>提交容器副本</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker commit -m=<span class=\"string\">\"has update\"</span> -a=<span class=\"string\">\"ubuntu/update\"</span> <span class=\"number\">2</span>d60a31b8bdf <span class=\"symbol\">ubuntu:</span>v2</span><br><span class=\"line\">ea547a1aa6de52e24092ff3ca13ae7ae58cd35123e2e58e6f3d784208af7ef5e</span><br></pre></td></tr></table></figure>\n<p>-m: 提交的描述信息</p>\n<p>-a: 指定镜像作者</p>\n<p>2d60a31b8bdf: 容器ID</p>\n<p>runoob/ubuntu:v2: 指定要创建的目标镜像名</p>\n<h4 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h4><p>创建Dockerfile，使用docker build命令来创建一个新的镜像</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost docker]$ cat Dockerfile</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>    centos:<span class=\"number\">6.7</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span>      Fisher <span class=\"string\">\"artislong@haha.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\">     /bin/<span class=\"built_in\">echo</span> <span class=\"string\">'root:123456'</span> |chpasswd</span></span><br><span class=\"line\"><span class=\"bash\">RUN     useradd docker</span></span><br><span class=\"line\"><span class=\"bash\">RUN     /bin/<span class=\"built_in\">echo</span> <span class=\"string\">'docker:123456'</span> |chpasswd</span></span><br><span class=\"line\"><span class=\"bash\">RUN     /bin/<span class=\"built_in\">echo</span> -e <span class=\"string\">\"LANG=\\\"en_US.UTF-8\\\"\"</span> &gt;/etc/default/<span class=\"built_in\">local</span></span></span><br><span class=\"line\"><span class=\"bash\">EXPOSE  22</span></span><br><span class=\"line\"><span class=\"bash\">EXPOSE  80</span></span><br><span class=\"line\"><span class=\"bash\">CMD     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>\n<p>Dockerfile是一个文本格式的配置文件，它由一行行命令语句（指令）组成，并且支持以#开头的注释行</p>\n<p>每个指令都会在镜像上创建一个新的层，每个指令的前缀都必须大写。</p>\n<p>第一条FROM，指定使用哪个镜像源</p>\n<p>RUN指令告诉docker在镜像内执行命令，安装了什么。。。</p>\n<p>然后我们通过Dockerfile文件来构建一个镜像</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> docker]<span class=\"variable\">$ </span>docker build -t runoob/<span class=\"symbol\">centos:</span><span class=\"number\">6.7</span> .</span><br></pre></td></tr></table></figure>\n<p>千万不要忽略最后面的 “.”，它表示使用当前目录下的Dockerfile文件</p>\n<p>-t: 指定要创建的目标镜像名</p>\n<p>​</p>\n<p>我们可以使用新的镜像来创建容器</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost docker]$ docker <span class=\"builtin-name\">run</span> -t -i runoob/centos:6.7 /bin/bash</span><br><span class=\"line\">[root@ebd742bf9af0 /]# id docker</span><br><span class=\"line\"><span class=\"attribute\">uid</span>=500(docker) <span class=\"attribute\">gid</span>=500(docker) <span class=\"attribute\">groups</span>=500(docker)</span><br></pre></td></tr></table></figure>\n<p>从上面看到新镜像已经包含了我们创建的用户docker</p>\n<h4 id=\"设置镜像标签\"><a href=\"#设置镜像标签\" class=\"headerlink\" title=\"设置镜像标签\"></a>设置镜像标签</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost docker]$ docker <span class=\"keyword\">tag</span> <span class=\"title\">f38a8f197ee4</span> runoob/centos:dev</span><br></pre></td></tr></table></figure>\n<p>docker tag 镜像ID，镜像源名和新的标签名</p>\n<h2 id=\"Docker安装Nginx\"><a href=\"#Docker安装Nginx\" class=\"headerlink\" title=\"Docker安装Nginx\"></a>Docker安装Nginx</h2><h3 id=\"创建Nginx目录，用于存放后面相关文件\"><a href=\"#创建Nginx目录，用于存放后面相关文件\" class=\"headerlink\" title=\"创建Nginx目录，用于存放后面相关文件\"></a>创建Nginx目录，用于存放后面相关文件</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>mkdir -p ~<span class=\"regexp\">/nginx/www</span> ~<span class=\"regexp\">/nginx/logs</span> ~<span class=\"regexp\">/nginx/conf</span></span><br></pre></td></tr></table></figure>\n<p>www目录将映射为nginx容器配置的虚拟目录</p>\n<p>logs目录将映射为nginx容器的日志目录</p>\n<p>conf目录里的配置文件将映射为nginx容器的配置文件</p>\n<h3 id=\"查找Docker-Hub上的nginx镜像\"><a href=\"#查找Docker-Hub上的nginx镜像\" class=\"headerlink\" title=\"查找Docker Hub上的nginx镜像\"></a>查找Docker Hub上的nginx镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> nginx]<span class=\"variable\">$ </span>docker search nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"拉取官方nginx镜像\"><a href=\"#拉取官方nginx镜像\" class=\"headerlink\" title=\"拉取官方nginx镜像\"></a>拉取官方nginx镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> nginx]<span class=\"variable\">$ </span>docker pull nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看nginx本地镜像\"><a href=\"#查看nginx本地镜像\" class=\"headerlink\" title=\"查看nginx本地镜像\"></a>查看nginx本地镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> nginx]<span class=\"variable\">$ </span>docker images nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用nginx镜像\"><a href=\"#使用nginx镜像\" class=\"headerlink\" title=\"使用nginx镜像\"></a>使用nginx镜像</h3><h4 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost nginx]$ docker run -<span class=\"selector-tag\">i</span> -t -d -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span>:<span class=\"number\">8081</span> --name nginx -v <span class=\"variable\">$PWD</span>/www:/www -v <span class=\"variable\">$PWD</span>/conf/nginx<span class=\"selector-class\">.conf</span>:/etc/nginx/nginx<span class=\"selector-class\">.conf</span> -v <span class=\"variable\">$PWD</span>/logs:/wwwlogs  -d nginx</span><br></pre></td></tr></table></figure>\n<p>-p 80:8081: 将容器的80端口映射到宿主机的8081端口</p>\n<p>-name nginx: 将容器命名为nginx</p>\n<p>-v $PWD/www:/www: 将主机中当前目录下的www目录挂载到容器的/www</p>\n<p>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf: 将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</p>\n<p>-v $PWD/logs:/wwwlogs: 将主机中当前目录下的logs挂载到容器的/wwwlogs</p>\n<h4 id=\"查看容器启动情况\"><a href=\"#查看容器启动情况\" class=\"headerlink\" title=\"查看容器启动情况\"></a>查看容器启动情况</h4><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> nginx]<span class=\"variable\">$ </span>docker ps</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过浏览器访问\"><a href=\"#通过浏览器访问\" class=\"headerlink\" title=\"通过浏览器访问\"></a>通过浏览器访问</h4><p>访问路径为: http://主机ip:8081/ ，就可访问nginx</p>\n<h2 id=\"Docker安装Tomcat\"><a href=\"#Docker安装Tomcat\" class=\"headerlink\" title=\"Docker安装Tomcat\"></a>Docker安装Tomcat</h2><h3 id=\"创建tomcat的相关目录\"><a href=\"#创建tomcat的相关目录\" class=\"headerlink\" title=\"创建tomcat的相关目录\"></a>创建tomcat的相关目录</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>mkdir -p ~<span class=\"regexp\">/tomcat/webapps</span> ~<span class=\"regexp\">/tomcat/logs</span> ~<span class=\"regexp\">/tomcat/conf</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查找Docker-Hub上的tomcat镜像\"><a href=\"#查找Docker-Hub上的tomcat镜像\" class=\"headerlink\" title=\"查找Docker Hub上的tomcat镜像\"></a>查找Docker Hub上的tomcat镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker search tomcat</span><br></pre></td></tr></table></figure>\n<h3 id=\"拉取官方tomcat镜像\"><a href=\"#拉取官方tomcat镜像\" class=\"headerlink\" title=\"拉取官方tomcat镜像\"></a>拉取官方tomcat镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> ~]<span class=\"variable\">$ </span>docker pull tomcat</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建测试文件\"><a href=\"#创建测试文件\" class=\"headerlink\" title=\"创建测试文件\"></a>创建测试文件</h3><ul>\n<li><p>在~/tomcat/webapps目录下创建test目录</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> webapps]<span class=\"variable\">$ </span>mkdir test</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入test目录，编写测试页面</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker<span class=\"variable\">@localhost</span> test]<span class=\"variable\">$ </span>vi index.html</span><br></pre></td></tr></table></figure>\n<p>index.html文件内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>docker中的tomcat测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">                Hello, World! <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">                哈哈哈哈，运行成功啦啦啦啦啦</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行tomcat容器</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[docker@localhost tomcat]$ docker <span class=\"keyword\">run</span><span class=\"bash\"> --name tomcat -p 8080:8080 -v <span class=\"variable\">$PWD</span>/webapps/<span class=\"built_in\">test</span>:/usr/<span class=\"built_in\">local</span>/tomcat/webapps/<span class=\"built_in\">test</span> -d tomcat</span></span><br></pre></td></tr></table></figure>\n<p>命令说明：</p>\n<p>-v $PWD/webapps/test:/usr/local/tomcat/webapps/test: 将主机中当前目录下的test挂载到容器的/test</p>\n<p>启动成功后，在浏览器访问：http://主机ip:8080/test/index.html即可访问刚才编写的测试页面</p>\n</li>\n</ul>\n<p>—————————————————————————分割线———————————————————————–</p>\n<h1 id=\"Dockerfile镜像制作\"><a href=\"#Dockerfile镜像制作\" class=\"headerlink\" title=\"Dockerfile镜像制作\"></a>Dockerfile镜像制作</h1><p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。</p>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><p>Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。</p>\n<p>一般Dockerfile文件分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This dockerfile uses the ubuntu image</span></span><br><span class=\"line\"><span class=\"comment\"># VERSION 2 - EDITION 1</span></span><br><span class=\"line\"><span class=\"comment\"># Author:docker_user</span></span><br><span class=\"line\"><span class=\"comment\"># Command format: Instruction [arguments / command] ..</span></span><br><span class=\"line\"><span class=\"comment\"># 第一行必须制定基于的基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"><span class=\"comment\"># 维护者信息</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> docker_user docker_user@email.com</span><br><span class=\"line\"><span class=\"comment\"># 镜像的操作指令</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">\"deb http://archive.ubuntu.com/ubuntu/ raring main universe\"</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class=\"line\"><span class=\"bash\">RUN apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class=\"line\"><span class=\"bash\">RUN <span class=\"built_in\">echo</span> <span class=\"string\">\"\\ndaemon off;\"</span> &gt;&gt; /etc/nginx/nginx.conf</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># 容器启动时执行指令</span></span></span><br><span class=\"line\"><span class=\"bash\">CMD /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure>\n<p>Dockerfile文件编写时，一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息</p>\n<p>后面则是镜像操作指令，例如RUN指令，镜像增加新的一层，并提交。最后是CMD指令，来指定运行容器时的操作命令。</p>\n<p>以下有两个摘自书上的Dockerfile例子：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ngnix</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># VERSION 0.0.1</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> Victor Vieux &lt;victor@docker.com&gt;</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></span><br></pre></td></tr></table></figure>\n<p>此Dockerfile文件是在ubuntu父镜像基础上安装inotify-tools、nginx、apache2、openssh-server软件，从而创建一个新的Nginx镜像</p>\n<p><strong>注</strong> ：inotify-tools是为linux下inotify文件监控工具提供的一套c的开发接口库函数，同时还提供了一系列的命令行工具，这些工具可以用来监控文件系统的事件。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Firefox over VNC</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># VERSION 0.3</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"><span class=\"comment\"># Install vnc, xvfb in order to reate a 'fake' display and firefox</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefox</span></span><br><span class=\"line\"><span class=\"bash\">RUN mkdir /.vnc</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># Setup a password</span></span></span><br><span class=\"line\"><span class=\"bash\">RUN xllvnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># Autostart firefox (might not be the best way, but it does the trick)</span></span></span><br><span class=\"line\"><span class=\"bash\">RUN bash -c <span class=\"string\">'echo \"firefox\" &gt;&gt; /.bashrc'</span></span></span><br><span class=\"line\"><span class=\"bash\">EXPOSE 5900</span></span><br><span class=\"line\"><span class=\"bash\">CMD [<span class=\"string\">\"xllvnc\"</span>, <span class=\"string\">\"-forever\"</span>, <span class=\"string\">\"-usepw\"</span>, <span class=\"string\">\"-create\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>此Dockerfile基于ubuntu父镜像，安装filefox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox。</p>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p>指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。</p>\n<p>Dockerfile指令说明</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">FROM</td>\n<td style=\"text-align:center\">指定所创建镜像的基础镜像</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MAINTAINER</td>\n<td style=\"text-align:center\">指定维护者信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RUN</td>\n<td style=\"text-align:center\">运行命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CMD</td>\n<td style=\"text-align:center\">指定启动容器时默认执行的命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LABEL</td>\n<td style=\"text-align:center\">指定生成镜像的元数据标签信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">EXPOSE</td>\n<td style=\"text-align:center\">声明镜像内服务所监听的端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ENV</td>\n<td style=\"text-align:center\">指定容器环境变量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ADD</td>\n<td style=\"text-align:center\">复制指定的 \\&lt;src> 路径下的内容到容器中的 \\&lt;dest> 路径下，\\&lt;src> 可以为URL；如果为tar文件，会自动解压到 \\&lt;dest> 路径下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">COPY</td>\n<td style=\"text-align:center\">复制本地主机的 \\&lt;src> 路径下的内容到镜像中的 \\&lt;dest> 路径下；一般情况下推荐使用COPY而不是ADD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ENTRYPOINT</td>\n<td style=\"text-align:center\">指定镜像的默认入口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VOLUME</td>\n<td style=\"text-align:center\">创建数据卷挂载点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">USER</td>\n<td style=\"text-align:center\">指定运行容器时的用户名或UID</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WORKDIR</td>\n<td style=\"text-align:center\">配置工作目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ARG</td>\n<td style=\"text-align:center\">指定镜像内使用的参数 （例如版本号信息等）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ONBUILD</td>\n<td style=\"text-align:center\">配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">STOPSIGNAL</td>\n<td style=\"text-align:center\">容器退出的信号值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HEALTHCHECK</td>\n<td style=\"text-align:center\">如何进行健康检查</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SHELL</td>\n<td style=\"text-align:center\">指定使用shell时的默认shell类型</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">FROM</span> &lt;image&gt; 或<span class=\"keyword\">FROM</span>&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>\n<p>第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。</p>\n<h3 id=\"MAINTAINER\"><a href=\"#MAINTAINER\" class=\"headerlink\" title=\"MAINTAINER\"></a>MAINTAINER</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">MAINTAINER</span> &lt;name&gt;, 指定维护者信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">RUN</span><span class=\"bash\"> &lt;<span class=\"built_in\">command</span>&gt; 或 RUN [<span class=\"string\">\"executable\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>RUN <command> 将在shell终端中运行命令，即 /bin/sh -c</p>\n<p>RUN [“executable”, “param1”, “param2”]则使用exec执行。</p>\n<p>指定使用其他终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”, “echo hello”]。</p>\n<p>每条RUN指令将在当前镜像基础上执行指令命令，并提交为新的镜像。当命令较长时可以用 \\ 来换行。</p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>支持三种格式</p>\n<ul>\n<li><p>使用exec执行，推荐方式</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"executable\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在/bin/sh中执行，提供给需要交互的应用</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> <span class=\"built_in\">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提供给ENTRYPOINT的默认参数</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。</p>\n<p>如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p>\n<h3 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure>\n<p>例如：EXPOSE 22 80 8443</p>\n<p>就是告诉Docker服务器容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P或者-p来指定端口映射。</p>\n<h3 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>\n<p>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> PG_MAJOR <span class=\"number\">9.3</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PG_VERSION <span class=\"number\">9.3</span>.<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> curl -SL http://example.com/postgres-<span class=\"variable\">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...</span></span><br><span class=\"line\"><span class=\"bash\">ENV PATH /usr/<span class=\"built_in\">local</span>/postgres-<span class=\"variable\">$PG_MAJOR</span>/bin:<span class=\"variable\">$PATH</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">ADD</span><span class=\"bash\"> &lt;src&gt; &lt;dest&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该命令将复制指定的<src>到容器中的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</src></dest></src></p>\n<h3 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">COPY</span><span class=\"bash\"> &lt;src&gt; &lt;dest&gt;</span></span><br></pre></td></tr></table></figure>\n<p>复制本地主机的<src>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<dest>。目标路径不存在时，会自动创建。</dest></src></p>\n<p>当使用本地目录为源目录时，推荐使用COPY</p>\n<h3 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h3><ul>\n<li><p>使用exec执行，推荐方式</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"executable\"</span>, <span class=\"string\">\"param1\"</span>, <span class=\"string\">\"param2\"</span>]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在shell中执行</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> <span class=\"built_in\">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖</p>\n<p>每个Dockerfile中只能有一个ENTRYPOINT，当制定多个ENTRYPOINT时，只有最后一个生效。</p>\n<h3 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">VOLUME</span><span class=\"bash\"> [<span class=\"string\">\"/data\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>\n<h3 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">USER</span> daemon</span><br></pre></td></tr></table></figure>\n<p>指定运行容器时的用户名或UID，后续的RUN也会使用指定的用户。</p>\n<p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span></span><br></pre></td></tr></table></figure>\n<p>要临时获取管理员权限可以使用gosu，不推荐sudo</p>\n<h3 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>\n<p>为后续RUN、CMD、ENTRYPOINT指令配置工作目录。</p>\n<p>可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /a</span></span><br><span class=\"line\"><span class=\"bash\">WORKDIR b</span></span><br><span class=\"line\"><span class=\"bash\">WORKDIR c</span></span><br><span class=\"line\"><span class=\"bash\">RUN <span class=\"built_in\">pwd</span></span></span><br></pre></td></tr></table></figure>\n<p>上面指令最终结果为：/a/b/c</p>\n<h3 id=\"ONBUILD\"><a href=\"#ONBUILD\" class=\"headerlink\" title=\"ONBUILD\"></a>ONBUILD</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式为 <span class=\"keyword\">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure>\n<p>配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\"><span class=\"keyword\">ONBUILD</span> <span class=\"keyword\">ADD</span><span class=\"bash\"> . /app/src</span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD RUN /usr/<span class=\"built_in\">local</span>/bin/python-build --dir /app/src</span></span><br><span class=\"line\"><span class=\"bash\">[...]</span></span><br></pre></td></tr></table></figure>\n<p>Dockerfile使用上面的内容创建了镜像image-A，如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在Dockerfile后面添加了两条指令，如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> image-A</span><br><span class=\"line\"><span class=\"comment\"># Automatically run the following</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app/src</span></span><br><span class=\"line\"><span class=\"bash\">RUN /usr/<span class=\"built_in\">local</span>/bin/python-build --dir /app/src</span></span><br></pre></td></tr></table></figure>\n<p>使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。</p>\n<h1 id=\"高级知识\"><a href=\"#高级知识\" class=\"headerlink\" title=\"高级知识\"></a>高级知识</h1><h2 id=\"资源隔离\"><a href=\"#资源隔离\" class=\"headerlink\" title=\"资源隔离\"></a>资源隔离</h2><p>Linux内核从2.4.19开始引入namespace的概念，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace中的进程看起来拥有它们自己的隔离的全局系统资源实例。</p>\n<table>\n<thead>\n<tr>\n<th>namespace</th>\n<th>系统调用参数</th>\n<th>隔离内容</th>\n<th>在容器语境下的隔离效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTS</td>\n<td>CLONE_NEWUTS</td>\n<td>主机名和域名</td>\n<td>每个容器可以有自己的hostname和domainname</td>\n</tr>\n<tr>\n<td>IPC</td>\n<td>CLONE_NEWIPC</td>\n<td>信号量、消息队列和共享内存</td>\n<td>每个容器有其自己的System V IPC和POSIX消息队列文件系统，因此，只有在同一个IPC的进程之间才能互相通信</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>CLONE_NEWPID</td>\n<td>进程编号</td>\n<td>每个PID中的namespace中的进程可以有其独立的PID；每个容器可以有其PID为1的root进程；也使得容器可以在不同的host之间迁移，因为namespace中的进程ID和host无关了。这也使得容器中的每个进程有两个PID：容器中的PID和host上的PID</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>CLONE_NEWNET</td>\n<td>网络设备、网络栈、端口等</td>\n<td>每个容器都有其独立的网络设备，IP地址，IP路由表，/proc/net目录，端口号等。这也使得多个容器内的同一个应用都绑定在各自容器的80端口上</td>\n</tr>\n<tr>\n<td>Mount</td>\n<td>CLONE_NEWNS</td>\n<td>挂载点（文件系统）</td>\n<td>每个容器能看到不同的文件系统层次结构</td>\n</tr>\n<tr>\n<td>User</td>\n<td>CLONE_NEWUSER</td>\n<td>用户和组ID空间</td>\n<td>在User中的进程的用户和组ID可以和在host上不通。每个container可以有不同的user和group id；一个host上的非特权用户可以成为User中的特权用户</td>\n</tr>\n</tbody>\n</table>\n<p>Docker的资源隔离也是通过这六种方式实现的，在容器启动时，Docker会创建这六种namespace实例，然后把容器中的所有进程放到这些namespace中，使得Docker容器中只能看到隔离的系统资源。</p>\n<h2 id=\"网络模式\"><a href=\"#网络模式\" class=\"headerlink\" title=\"网络模式\"></a>网络模式</h2><p>docker目前支持四种网络工作的方式，分别为host，container，none，bridge。下面简单介绍下这几种网络模式。</p>\n<ul>\n<li><p>host模式</p>\n<p>Docker使用了Linux的Namespaces技术来进行资源隔离，如网卡、路由、进程等。如果启动容器的时候使用host模式，那么容器不会自己去创建一个独立的Network Namespace，而是与主机共用一个Network Namespace。容器也不会虚拟出自己的网卡、IP等，而是使用宿主机的IP和端口。</p>\n</li>\n<li><p>container模式</p>\n<p>container模式指定创建的新的容器和已经存在的一个容器共享一个Network Namespace。container模式通过-net=container:NAME_OR_ID指定共享的容器。</p>\n</li>\n<li><p>none模式</p>\n<p>在这种模式下，容器拥有自己的Network Namespace，但是不做任何网络配置，需要我们自己给容器添加网卡、IP等。</p>\n</li>\n<li><p>bridge模式</p>\n<p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到虚拟网桥上，实现容器和容器的主机的互连。​</p>\n</li>\n</ul>\n","slug":"Docker学习笔记","updated":"2018-05-16T11:24:19.000Z","comments":true,"link":"","permalink":"/2017/06/16/Docker学习笔记/","excerpt":"[TOC] Docker基本操作Docker简介Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的主要目标是“Build,Ship and Run Any App, Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”（有点类似于java）。这里的应用组件，即可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或者编译器。","categories":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}],"tags":[{"name":"Docker,Dockerfile","slug":"Docker-Dockerfile","permalink":"/tags/Docker-Dockerfile/"}]},{"title":"Nginx+Tomcat+Redis实现Session共享","date":"2017-06-07T06:43:12.000Z","path":"2017/06/07/session共享/","text":"Nginx+Tomcat+Redis实现Session共享之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。 经过百度，查资料，找到了几种解决session共享的方案。 不适用session，换作cookie 1能把session改成cookie，就能避开session的一些弊端，也有资料表明在集群系统中不能使用session。但是博主思考再三，公司项目的session中存储一些比较重要的信息，在以后的业务中也会使用session中的数据，所以直接使用cookie这种方案果断舍弃。 应用服务器自行实现共享 1让服务器自行实现session共享，就需要提供一个后端服务器都能访问的公共容器来存储session，比如redis或者memcache，当系统需要获取session时，直接从redis或memcache中获取即可。 以上两种方式都与Nginx没多大关系了。下面说说使用nginx如何处理 ip_hash 1234之前的博客中对upstream的几种方式做了介绍，相信大家还记得ip_hash的介绍吧，每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。这样一来这个ip下的某个客户端和某个后端服务器就能建立稳固的session。这样每个客户端都只对应一个服务器，那就不存在需要共享session的需要了，不过只用ip这个因子来分配后端，所以还是存在一些缺陷，不能在以下情况下使用：1、nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx就得不到正确的ip，也就不能根据ip来分配后端了。比如squid(一个高性能的代理缓存服务器)作为最前端，那么nginx只能获取到squid所在服务器的ip地址，这种分流方式肯定会混乱的。2、nginx的后端还有其他方式的负载均衡。如果nginx后端又有其他的负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台服务器上。 upstream_hash 12为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块大多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享；这种方式不是很理解，就不做累述了，以后再慢慢研究。读者可自行查找资料学习。 来自于网络上的方案介绍完了，接下来说说博主项目中的实际操作。 博主最初的打算是使用redis来缓存系统数据，刚好也可以实现session共享。可惜，客户公司方面服务器资源不够，不让使用redis，上面第二种方案瞬间被阉割掉了，有点不爽。这里必须吐槽吐槽客户公司。 由于不让使用redis，所以只能使用第三种方式了，这里就不做太多的累述了，比较简单，配置nginx负载均衡的时候将upstream的方式配置为ip_hash即可，具体配置方式在上篇“Nginx负载均衡配置”中已有例子，可做参考。 简单的解释一下公司项目架构，公司项目采用前后台分离的架构，前端页面使用angularJS实现一种单页面应用，后台服务则使用SpringBoot为前端提供数据服务，后台开发者只需要关注后端逻辑，然后将前端需要的数据转为json传给前端，而不需要去考虑页面的跳转等，而前端人员也不需要关注后台逻辑，可以全身心的提供前端的用户体验度，最主要的是前后台分离后，系统开发职责划分的更加清晰。 关于前后台分离方案，这个博客讲的比较好，读者可做参考。 这样就完了？没有，这就完了这篇博客也太水了，虽然客户公司不让使用redis，但是博主还是自己抽时间使用nginx+tomcat+redis来自己实现session共享。 ——————————————————————这是一个分隔线——————————————————————- 1、软件准备因为是自己玩，所以直接在windows上开工了。 nginx-1.11.5，apache-tomcat-7.0.55，redis-2.6.12(windows版) 读者可从这里下载。其中有三个jar包最为重要： commons-pool-1.6.jar，jedis-2.1.0.jar，tomcat-redis-session-manager-tomcat7.jar，在软件包中的tomcat的lib目录下可找到。 2、配置tomcat在tomcat中的context.xml文件中加入以下内容 123456&lt;Valve className=\"com.radiadesign.catalina.session.RedisSessionHandlerValve\" /&gt;&lt;Manager className=\"com.radiadesign.catalina.session.RedisSessionManager\" host=\"localhost\" port=\"6379\" database=\"0\" maxInactiveInterval=\"60\" /&gt; 将配置好的tomcat三份，分别命名为apache-tomcat-7.0.55-1，apache-tomcat-7.0.55-2，apache-tomcat-7.0.55-3，然后去将每个tomcat的端口改掉，分别改为8081，8082，8083 3、配置Nginx将三个tomcat服务器用nginx代理， 12345upstream localhost &#123; server localhost:8081 weight=1; server localhost:8082 weight=1; server localhost:8083 weight=1; &#125; 4、测试页面在tomcat的webapp目录下新建test目录，在test中新建index.jsp，然后给三个tomcat都拷贝一份 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(request.getSession().getId());%&gt;&lt;/body&gt;&lt;/html&gt; 这可能是可与Hello，World媲美的页面了。 5、启动测试先启动redis，在启动三个tomcat，最后再启动nginx，然后访问页面。 有两种访问方式： 直接访问三个tomcat，【http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。 多次访问nginx，【http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致 好了，这种session共享完成。不过还没完，刚开始介绍时说的那三个jar包还没说说呢，接下来通过tomcat-redis-session-manager-tomcat7.jar的源码来解释一下这种方式实现session共享的原理。 6、Session共享原理分析在解释Session共享原理之前，我们先简单的看看Tomcat架构方面的一些知识作为铺垫。 ##### 6.1 Tomcat架构原理分析 正在深入剖析tomcat源码中，解读清楚了此部分补上","raw":"---\n\nlayout: post\n\ntitle: Nginx+Tomcat+Redis实现Session共享\n\ntoc: true\n\ndate: 2017-06-07 14:43:12\n\ntags: Session\n\ncategories: 服务器\n\ndescription:\n\n---\n\n\n\n## Nginx+Tomcat+Redis实现Session共享\n\n之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。\n\n经过百度，查资料，找到了几种解决session共享的方案。\n\n- 不适用session，换作cookie<!--more-->\n\n  ```\n  能把session改成cookie，就能避开session的一些弊端，也有资料表明在集群系统中不能使用session。但是博主思考再三，公司项目的session中存储一些比较重要的信息，在以后的业务中也会使用session中的数据，所以直接使用cookie这种方案果断舍弃。\n  ```\n\n- 应用服务器自行实现共享\n\n  ```\n  让服务器自行实现session共享，就需要提供一个后端服务器都能访问的公共容器来存储session，比如redis或者memcache，当系统需要获取session时，直接从redis或memcache中获取即可。\n  ```\n\n  以上两种方式都与Nginx没多大关系了。下面说说使用nginx如何处理\n\n- ip_hash\n\n  ```\n  之前的博客中对upstream的几种方式做了介绍，相信大家还记得ip_hash的介绍吧，每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。\n  这样一来这个ip下的某个客户端和某个后端服务器就能建立稳固的session。这样每个客户端都只对应一个服务器，那就不存在需要共享session的需要了，不过只用ip这个因子来分配后端，所以还是存在一些缺陷，不能在以下情况下使用：\n  1、nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx就得不到正确的ip，也就不能根据ip来分配后端了。比如squid(一个高性能的代理缓存服务器)作为最前端，那么nginx只能获取到squid所在服务器的ip地址，这种分流方式肯定会混乱的。\n  2、nginx的后端还有其他方式的负载均衡。如果nginx后端又有其他的负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台服务器上。\n  ```\n\n- upstream_hash\n\n  ```\n  为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块大多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享；\n  这种方式不是很理解，就不做累述了，以后再慢慢研究。读者可自行查找资料学习。\n  ```\n\n来自于网络上的方案介绍完了，接下来说说博主项目中的实际操作。\n\n博主最初的打算是使用redis来缓存系统数据，刚好也可以实现session共享。可惜，客户公司方面服务器资源不够，不让使用redis，上面第二种方案瞬间被阉割掉了，有点不爽。这里必须吐槽吐槽客户公司。\n\n由于不让使用redis，所以只能使用第三种方式了，这里就不做太多的累述了，比较简单，配置nginx负载均衡的时候将upstream的方式配置为ip_hash即可，具体配置方式在上篇“Nginx负载均衡配置”中已有例子，可做参考。\n\n简单的解释一下公司项目架构，公司项目采用前后台分离的架构，前端页面使用angularJS实现一种单页面应用，后台服务则使用SpringBoot为前端提供数据服务，后台开发者只需要关注后端逻辑，然后将前端需要的数据转为json传给前端，而不需要去考虑页面的跳转等，而前端人员也不需要关注后台逻辑，可以全身心的提供前端的用户体验度，最主要的是前后台分离后，系统开发职责划分的更加清晰。\n\n关于前后台分离方案，这个[博客](http://web.jobbole.com/82637/)讲的比较好，读者可做参考。 \n\n这样就完了？没有，这就完了这篇博客也太水了，虽然客户公司不让使用redis，但是博主还是自己抽时间使用nginx+tomcat+redis来自己实现session共享。\n\n\n\n------------------------------------------------------------------这是一个分隔线-------------------------------------------------------------------\n\n\n\n#### 1、软件准备\n\n因为是自己玩，所以直接在windows上开工了。\n\nnginx-1.11.5，apache-tomcat-7.0.55，redis-2.6.12(windows版)\n\n读者可从[这里](https://github.com/ArtIsLong/documentation/blob/master/resources/nginx_redis_tomcat.zip)下载。其中有三个jar包最为重要：\n\ncommons-pool-1.6.jar，jedis-2.1.0.jar，tomcat-redis-session-manager-tomcat7.jar，在软件包中的tomcat的lib目录下可找到。\n\n#### 2、配置tomcat\n\n在tomcat中的context.xml文件中加入以下内容\n\n```xml\n<Valve  className=\"com.radiadesign.catalina.session.RedisSessionHandlerValve\" />\n<Manager className=\"com.radiadesign.catalina.session.RedisSessionManager\"\n\thost=\"localhost\" \n\tport=\"6379\"\n\tdatabase=\"0\" \n\tmaxInactiveInterval=\"60\" />\n```\n\n将配置好的tomcat三份，分别命名为apache-tomcat-7.0.55-1，apache-tomcat-7.0.55-2，apache-tomcat-7.0.55-3，然后去将每个tomcat的端口改掉，分别改为8081，8082，8083\n\n#### 3、配置Nginx\n\n将三个tomcat服务器用nginx代理，\n\n```nginx\nupstream  localhost   {\n\tserver   localhost:8081 weight=1;  \n\tserver   localhost:8082 weight=1;  \n\tserver   localhost:8083 weight=1; \n}\n```\n\n#### 4、测试页面\n\n在tomcat的webapp目录下新建test目录，在test中新建index.jsp，然后给三个tomcat都拷贝一份\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n<%\n\tout.println(request.getSession().getId());\n%>\n</body>\n</html>\n```\n\n这可能是可与Hello，World媲美的页面了。\n\n#### 5、启动测试\n\n先启动redis，在启动三个tomcat，最后再启动nginx，然后访问页面。\n\n有两种访问方式：\n\n- 直接访问三个tomcat，【http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。\n- 多次访问nginx，【http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致\n\n好了，这种session共享完成。不过还没完，刚开始介绍时说的那三个jar包还没说说呢，接下来通过tomcat-redis-session-manager-tomcat7.jar的源码来解释一下这种方式实现session共享的原理。\n\n#### 6、Session共享原理分析\n\n在解释Session共享原理之前，我们先简单的看看Tomcat架构方面的一些知识作为铺垫。\n\n\t##### 6.1 Tomcat架构原理分析\n\n正在深入剖析tomcat源码中，解读清楚了此部分补上\n\n","content":"<h2 id=\"Nginx-Tomcat-Redis实现Session共享\"><a href=\"#Nginx-Tomcat-Redis实现Session共享\" class=\"headerlink\" title=\"Nginx+Tomcat+Redis实现Session共享\"></a>Nginx+Tomcat+Redis实现Session共享</h2><p>之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。</p>\n<p>经过百度，查资料，找到了几种解决session共享的方案。</p>\n<ul>\n<li><p>不适用session，换作cookie<a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">能把session改成cookie，就能避开session的一些弊端，也有资料表明在集群系统中不能使用session。但是博主思考再三，公司项目的session中存储一些比较重要的信息，在以后的业务中也会使用session中的数据，所以直接使用cookie这种方案果断舍弃。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>应用服务器自行实现共享</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">让服务器自行实现session共享，就需要提供一个后端服务器都能访问的公共容器来存储session，比如redis或者memcache，当系统需要获取session时，直接从redis或memcache中获取即可。</span><br></pre></td></tr></table></figure>\n<p>以上两种方式都与Nginx没多大关系了。下面说说使用nginx如何处理</p>\n</li>\n<li><p>ip_hash</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">之前的博客中对upstream的几种方式做了介绍，相信大家还记得ip_hash的介绍吧，每个请求按访问<span class=\"built_in\">ip</span>的hash结果分配，这样每个访问固定访问一个后端服务器。</span><br><span class=\"line\">这样一来这个<span class=\"built_in\">ip</span>下的某个客户端和某个后端服务器就能建立稳固的session。这样每个客户端都只对应一个服务器，那就不存在需要共享session的需要了，不过只用<span class=\"built_in\">ip</span>这个因子来分配后端，所以还是存在一些缺陷，不能在以下情况下使用：</span><br><span class=\"line\"><span class=\"number\">1</span>、nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx就得不到正确的<span class=\"built_in\">ip</span>，也就不能根据<span class=\"built_in\">ip</span>来分配后端了。比如squid(一个高性能的代理缓存服务器)作为最前端，那么nginx只能获取到squid所在服务器的<span class=\"built_in\">ip</span>地址，这种分流方式肯定会混乱的。</span><br><span class=\"line\"><span class=\"number\">2</span>、nginx的后端还有其他方式的负载均衡。如果nginx后端又有其他的负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台服务器上。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>upstream_hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块大多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享；</span><br><span class=\"line\">这种方式不是很理解，就不做累述了，以后再慢慢研究。读者可自行查找资料学习。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>来自于网络上的方案介绍完了，接下来说说博主项目中的实际操作。</p>\n<p>博主最初的打算是使用redis来缓存系统数据，刚好也可以实现session共享。可惜，客户公司方面服务器资源不够，不让使用redis，上面第二种方案瞬间被阉割掉了，有点不爽。这里必须吐槽吐槽客户公司。</p>\n<p>由于不让使用redis，所以只能使用第三种方式了，这里就不做太多的累述了，比较简单，配置nginx负载均衡的时候将upstream的方式配置为ip_hash即可，具体配置方式在上篇“Nginx负载均衡配置”中已有例子，可做参考。</p>\n<p>简单的解释一下公司项目架构，公司项目采用前后台分离的架构，前端页面使用angularJS实现一种单页面应用，后台服务则使用SpringBoot为前端提供数据服务，后台开发者只需要关注后端逻辑，然后将前端需要的数据转为json传给前端，而不需要去考虑页面的跳转等，而前端人员也不需要关注后台逻辑，可以全身心的提供前端的用户体验度，最主要的是前后台分离后，系统开发职责划分的更加清晰。</p>\n<p>关于前后台分离方案，这个<a href=\"http://web.jobbole.com/82637/\" target=\"_blank\" rel=\"noopener\">博客</a>讲的比较好，读者可做参考。 </p>\n<p>这样就完了？没有，这就完了这篇博客也太水了，虽然客户公司不让使用redis，但是博主还是自己抽时间使用nginx+tomcat+redis来自己实现session共享。</p>\n<p>——————————————————————这是一个分隔线——————————————————————-</p>\n<h4 id=\"1、软件准备\"><a href=\"#1、软件准备\" class=\"headerlink\" title=\"1、软件准备\"></a>1、软件准备</h4><p>因为是自己玩，所以直接在windows上开工了。</p>\n<p>nginx-1.11.5，apache-tomcat-7.0.55，redis-2.6.12(windows版)</p>\n<p>读者可从<a href=\"https://github.com/ArtIsLong/documentation/blob/master/resources/nginx_redis_tomcat.zip\" target=\"_blank\" rel=\"noopener\">这里</a>下载。其中有三个jar包最为重要：</p>\n<p>commons-pool-1.6.jar，jedis-2.1.0.jar，tomcat-redis-session-manager-tomcat7.jar，在软件包中的tomcat的lib目录下可找到。</p>\n<h4 id=\"2、配置tomcat\"><a href=\"#2、配置tomcat\" class=\"headerlink\" title=\"2、配置tomcat\"></a>2、配置tomcat</h4><p>在tomcat中的context.xml文件中加入以下内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Valve</span>  <span class=\"attr\">className</span>=<span class=\"string\">\"com.radiadesign.catalina.session.RedisSessionHandlerValve\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Manager</span> <span class=\"attr\">className</span>=<span class=\"string\">\"com.radiadesign.catalina.session.RedisSessionManager\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">host</span>=<span class=\"string\">\"localhost\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">port</span>=<span class=\"string\">\"6379\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">database</span>=<span class=\"string\">\"0\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">maxInactiveInterval</span>=<span class=\"string\">\"60\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将配置好的tomcat三份，分别命名为apache-tomcat-7.0.55-1，apache-tomcat-7.0.55-2，apache-tomcat-7.0.55-3，然后去将每个tomcat的端口改掉，分别改为8081，8082，8083</p>\n<h4 id=\"3、配置Nginx\"><a href=\"#3、配置Nginx\" class=\"headerlink\" title=\"3、配置Nginx\"></a>3、配置Nginx</h4><p>将三个tomcat服务器用nginx代理，</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">upstream</span>  localhost   &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">server</span>   localhost:<span class=\"number\">8081</span> weight=<span class=\"number\">1</span>;  </span><br><span class=\"line\">\t<span class=\"attribute\">server</span>   localhost:<span class=\"number\">8082</span> weight=<span class=\"number\">1</span>;  </span><br><span class=\"line\">\t<span class=\"attribute\">server</span>   localhost:<span class=\"number\">8083</span> weight=<span class=\"number\">1</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、测试页面\"><a href=\"#4、测试页面\" class=\"headerlink\" title=\"4、测试页面\"></a>4、测试页面</h4><p>在tomcat的webapp目录下新建test目录，在test中新建index.jsp，然后给三个tomcat都拷贝一份</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"string\">\"java\"</span> %&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"zh-CN\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">\tout.println(request.getSession().getId());</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这可能是可与Hello，World媲美的页面了。</p>\n<h4 id=\"5、启动测试\"><a href=\"#5、启动测试\" class=\"headerlink\" title=\"5、启动测试\"></a>5、启动测试</h4><p>先启动redis，在启动三个tomcat，最后再启动nginx，然后访问页面。</p>\n<p>有两种访问方式：</p>\n<ul>\n<li>直接访问三个tomcat，【<a href=\"http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。\" target=\"_blank\" rel=\"noopener\">http://localhost:808x/test/index.jsp】，查看页面打印出的sessionId是否一致。</a></li>\n<li>多次访问nginx，【<a href=\"http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致\" target=\"_blank\" rel=\"noopener\">http://localhost:80/test/index.jsp】，同时配置Nginx时将upstream配置为轮询，使用上面路径访问时会将请求轮流转发到三台服务器上，确实此时页面上的sessionId是否一致</a></li>\n</ul>\n<p>好了，这种session共享完成。不过还没完，刚开始介绍时说的那三个jar包还没说说呢，接下来通过tomcat-redis-session-manager-tomcat7.jar的源码来解释一下这种方式实现session共享的原理。</p>\n<h4 id=\"6、Session共享原理分析\"><a href=\"#6、Session共享原理分析\" class=\"headerlink\" title=\"6、Session共享原理分析\"></a>6、Session共享原理分析</h4><p>在解释Session共享原理之前，我们先简单的看看Tomcat架构方面的一些知识作为铺垫。</p>\n<pre><code>##### 6.1 Tomcat架构原理分析\n</code></pre><p>正在深入剖析tomcat源码中，解读清楚了此部分补上</p>\n","slug":"session共享","updated":"2018-02-04T03:23:28.000Z","comments":true,"link":"","permalink":"/2017/06/07/session共享/","excerpt":"Nginx+Tomcat+Redis实现Session共享之前的博文中简单的介绍了一下Nginx的负载均衡配置，比较简单，但是如果实现多台服务器之间的session共享就是一个难题了。 经过百度，查资料，找到了几种解决session共享的方案。 不适用session，换作cookie","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"Session","slug":"Session","permalink":"/tags/Session/"}]},{"title":"Nginx负载均衡配置","date":"2017-06-06T14:50:56.000Z","path":"2017/06/06/Nginx负载均衡配置/","text":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx负载均衡配置这段来自百度百科，简单介绍一下，读者若需详细了解可自行查找资料，本文侧重于Nginx负载相关的具体操作配置介绍。 Nginx常用的功能有Http代理、反向代理，负载均衡器，web缓存等功能，最近项目需要做负载，简单的研究了一下nginx，对反向代理和负载均衡着重看了一下，所以接下来的文章主要对这两部分进行介绍。 1、Nginx服务器的安装windowns版Nginx下载地址：http://nginx.org/en/docs/windows.html windows上安装Nginx比较简单，Nginx官方已经提供了打包好的.exe的运行文件，不需要用户自己去编译运行。直接打开上面的地址，下载好windows版的nginx，解压后双击nginx.exe或者在命令窗口运行nginx.exe即可。 因为Nginx默认端口是80端口，所以启动成功之后在浏览器地址栏输入localhost就可以看到Nginx的欢迎页面。 linux版的Nginx下载地址：http://nginx.org/ 下载nginx之前，请确保自己的linux系统已经安装了g++，gcc。因为nginx是纯C语言编写，在linux下安装时需要去编译源码安装。 解压Nginx源码包 1&gt; tar -zxvf nginx-1.11.5.tar.gz 设置一下nginx配置信息 123&gt; chmod -R 777 nginx-1.11.5&gt; cd nginx-1.11.5&gt; ./configure --prefix=/usr/local/nginx #此处设置prefix，是设置nginx的安装路径 编译安装 1&gt; make | make install #将源码文件编译成可执行文件和各种库文件，并将其复制到上面设置的安装目录中 启动nginx 1&gt; /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf #这一步可以不指定nginx配置文件 还有最重要的一步，打开Nginx的防火墙端口 123&gt; vi /etc/sysconfig/iptables&gt; 添加端口，如： -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT&gt; /etc/init.d/iptables restart #重启防火墙，让修改生效 在自己本机的浏览器中输入localhost就可以看到Nginx的欢迎页面。 2、配置Nginx​ 在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了） &gt; Nginx的配置文件在安装目录下的conf目录中，一些默认配置都在这个目录下。 nginx.conf 的注释符号为 # 打开nginx.conf文件，可以大概浏览一下，配置文件基本可以分为几个模块 12345678910111213141516171819202122232425... #全局块events &#123; #events块 ...&#125;http #http块&#123; ... #http全局块 server #server块 &#123; ... #server全局块 location [PATTERN] #location块 &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; ... #http全局块&#125; 全局块：配置影像nginx的全局指令。一般有nginx的进程数，错误日志文件路径，nginx的主进程号等 events块：配置Nginx的工作模式，每个进程的最大连接数等 http块：可以嵌套多个server，配置代理，缓存，日志等功能以及第三方模块的配置。如文件引入，mime-type定义，连接超时时间，单连接请求数等等 server块：配置虚拟主机的相关参数，一个http中可以有多个server location块：配置请求的路由，以及各种页面的处理情况 给大家附上一个nginx的配置文件，博主在公司的测试环境上搭的一个负载均衡器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#user nobody;#nginx进程数，建议设置为CPU总核心数worker_processes 1;#错误日志文件路径error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#nginx主进程号pid logs/nginx.pid;#工作模式与连接数上限events &#123; # 单个进程的最大连接数（最大连接数=连接数*进程数） worker_connections 1024;&#125;http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #日志文件 access_log logs/access.log main; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 sendfile on; #防止网络阻塞 #tcp_nopush on; #长连接超时时间，单位是秒 keepalive_timeout 65; #服务器列表名称随便写 upstream global &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重，权值越高被分配到的几率越大。 server 192.168.100.100:8081; #weight=1 server 192.168.100.100:8084; ip_hash; #upstream的分配方式 &#125; #开启gzip压缩输出 #gzip on; server &#123; #监听端口 listen 8087; #域名可以有多个，用空格隔开 server_name 192.168.100.100; #默认编码 #charset koi8-r; #对“/”启用反向代理 location / &#123; #前端页面项目部署路径 root /home/fisCM/nginx/html; #默认主页面 index index.html index.htm; &#125; #5xx错误对应的页面 #error_page 500 502 503 504 /50x.html; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #我们项目的请求路径为http://192.168.100.100:8087/springboot/... location ^~ /springboot/ &#123; #请求转向global 定义的服务器列表 proxy_pass http://global; &#125; &#125;&#125; 注：192.168.100.100地址是博主瞎写的，读者可改为自己实际的IP地址 由于项目比较简单，所以也没有太多复杂的配置，接下来对Nginx负载均衡的一些基础知识做一下简单介绍。 3、nginx的upstream的几种方式&gt; 轮询（默认） 每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器冗机，能自动剔除。 ip_hash 每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。 weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 fair(第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 url_hash(第三方) 按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。 总结一下，负载均衡简单的理解其实可以看做是用户请求Nginx，Nginx将用户的请求URL按照配置的方式截取，然后按照配置的upstream的方式请求后端服务器。","raw":"\n---\nlayout: post\ntitle: Nginx负载均衡配置\ntoc: true\ndate: 2017-06-06 22:50:56\ntags: Nginx,负载均衡\ncategories: 服务器\ndescription:\n---\n\nNginx (\"engine x\") 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<!--more-->\nNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\n\n## Nginx负载均衡配置\n\n这段来自百度百科，简单介绍一下，读者若需详细了解可自行查找资料，本文侧重于Nginx负载相关的具体操作配置介绍。\n\nNginx常用的功能有Http代理、反向代理，负载均衡器，web缓存等功能，最近项目需要做负载，简单的研究了一下nginx，对反向代理和负载均衡着重看了一下，所以接下来的文章主要对这两部分进行介绍。\n\n\n#### 1、Nginx服务器的安装\n\nwindowns版Nginx下载地址：http://nginx.org/en/docs/windows.html\n\n> windows上安装Nginx比较简单，Nginx官方已经提供了打包好的.exe的运行文件，不需要用户自己去编译运行。直接打开上面的地址，下载好windows版的nginx，解压后双击nginx.exe或者在命令窗口运行nginx.exe即可。\n\n> 因为Nginx默认端口是80端口，所以启动成功之后在浏览器地址栏输入localhost就可以看到Nginx的欢迎页面。\n\n\nlinux版的Nginx下载地址：http://nginx.org/\n\n> 下载nginx之前，请确保自己的linux系统已经安装了g++，gcc。因为nginx是纯C语言编写，在linux下安装时需要去编译源码安装。\n\n- 解压Nginx源码包\n\n  ```\n  > tar -zxvf nginx-1.11.5.tar.gz\n  ```\n\n- 设置一下nginx配置信息\n\n  ```\n  > chmod -R 777 nginx-1.11.5\n  > cd nginx-1.11.5\n  > ./configure --prefix=/usr/local/nginx  #此处设置prefix，是设置nginx的安装路径\n  ```\n\n- 编译安装\n\n  ```\n  > make | make install #将源码文件编译成可执行文件和各种库文件，并将其复制到上面设置的安装目录中\n  ```\n\n- 启动nginx\n\n  ```\n  > /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf #这一步可以不指定nginx配置文件\n  ```\n\n- 还有最重要的一步，打开Nginx的防火墙端口\n\n  ```\n  > vi /etc/sysconfig/iptables\n  > 添加端口，如： -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT\n  > /etc/init.d/iptables restart #重启防火墙，让修改生效\n  ```\n\n- 在自己本机的浏览器中输入localhost就可以看到Nginx的欢迎页面。\n\n#### 2、配置Nginx\n\n​\t在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了）\n\n\t> Nginx的配置文件在安装目录下的conf目录中，一些默认配置都在这个目录下。\n\n> nginx.conf 的注释符号为 #\n\n打开nginx.conf文件，可以大概浏览一下，配置文件基本可以分为几个模块\n\n```\n...              #全局块\nevents {         #events块\n   ...\n}\nhttp      #http块\n{\n    ...   #http全局块\n    server        #server块\n    { \n        ...       #server全局块\n        location [PATTERN]   #location块\n        {\n            ...\n        }\n        location [PATTERN] \n        {\n            ...\n        }\n    }\n    server\n    {\n      ...\n    }\n    ...     #http全局块\n}\n```\n\n- 全局块：配置影像nginx的全局指令。一般有nginx的进程数，错误日志文件路径，nginx的主进程号等\n- events块：配置Nginx的工作模式，每个进程的最大连接数等\n- http块：可以嵌套多个server，配置代理，缓存，日志等功能以及第三方模块的配置。如文件引入，mime-type定义，连接超时时间，单连接请求数等等\n- server块：配置虚拟主机的相关参数，一个http中可以有多个server\n- location块：配置请求的路由，以及各种页面的处理情况\n\n给大家附上一个nginx的配置文件，博主在公司的测试环境上搭的一个负载均衡器。\n\n```\n#user  nobody;\n#nginx进程数，建议设置为CPU总核心数\nworker_processes  1;\n#错误日志文件路径\nerror_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n#nginx主进程号\npid        logs/nginx.pid;\n#工作模式与连接数上限\nevents {\n\t# 单个进程的最大连接数（最大连接数=连接数*进程数）\n\tworker_connections  1024;\n}\nhttp {\n\t#文件扩展名与文件类型映射表\n\tinclude       mime.types;\n\t#默认文件类型\n\tdefault_type  application/octet-stream;\n\t#日志文件\n\taccess_log  logs/access.log  main;\n\t#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 \n\tsendfile        on;\n\t#防止网络阻塞\n\t#tcp_nopush     on;\n\t#长连接超时时间，单位是秒\n\tkeepalive_timeout  65;\n\t#服务器列表名称随便写\n\tupstream global {\n\t\t#upstream的负载均衡，weight是权重，可以根据机器配置定义权重，权值越高被分配到的几率越大。\n\t\tserver 192.168.100.100:8081; #weight=1\n\t\tserver 192.168.100.100:8084;\n\t\tip_hash; #upstream的分配方式\n\t}\n\t#开启gzip压缩输出\n\t#gzip  on;\n\tserver {\n\t\t#监听端口\n\t\tlisten       8087;\n\t\t#域名可以有多个，用空格隔开\n\t\tserver_name  192.168.100.100;\n\t\t#默认编码\n\t\t#charset koi8-r;\n\t\t#对“/”启用反向代理\n\t\tlocation / {\n\t\t\t#前端页面项目部署路径\n\t\t\troot   /home/fisCM/nginx/html;\n\t\t\t#默认主页面\n\t\t\tindex  index.html index.htm;\n\t\t}\n\t\t#5xx错误对应的页面\n\t\t#error_page   500 502 503 504  /50x.html;\n\t\t#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。\n\t\t#我们项目的请求路径为http://192.168.100.100:8087/springboot/...\n\t\tlocation ^~ /springboot/ {\n\t\t\t#请求转向global 定义的服务器列表\n\t\t\tproxy_pass   http://global;\n\t\t}\n\t}\n}\n```\n\n注：192.168.100.100地址是博主瞎写的，读者可改为自己实际的IP地址\n\n由于项目比较简单，所以也没有太多复杂的配置，接下来对Nginx负载均衡的一些基础知识做一下简单介绍。\n\n#### 3、nginx的upstream的几种方式\n\n\t> 轮询（默认）\n\n每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器冗机，能自动剔除。\n\n> ip_hash\n\n每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。\n\n> weight\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n\n> fair(第三方)\n\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n> url_hash(第三方)\n\n按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。\n\n\n总结一下，负载均衡简单的理解其实可以看做是用户请求Nginx，Nginx将用户的请求URL按照配置的方式截取，然后按照配置的upstream的方式请求后端服务器。\n","content":"<p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<a id=\"more\"></a><br>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>\n<h2 id=\"Nginx负载均衡配置\"><a href=\"#Nginx负载均衡配置\" class=\"headerlink\" title=\"Nginx负载均衡配置\"></a>Nginx负载均衡配置</h2><p>这段来自百度百科，简单介绍一下，读者若需详细了解可自行查找资料，本文侧重于Nginx负载相关的具体操作配置介绍。</p>\n<p>Nginx常用的功能有Http代理、反向代理，负载均衡器，web缓存等功能，最近项目需要做负载，简单的研究了一下nginx，对反向代理和负载均衡着重看了一下，所以接下来的文章主要对这两部分进行介绍。</p>\n<h4 id=\"1、Nginx服务器的安装\"><a href=\"#1、Nginx服务器的安装\" class=\"headerlink\" title=\"1、Nginx服务器的安装\"></a>1、Nginx服务器的安装</h4><p>windowns版Nginx下载地址：<a href=\"http://nginx.org/en/docs/windows.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/docs/windows.html</a></p>\n<blockquote>\n<p>windows上安装Nginx比较简单，Nginx官方已经提供了打包好的.exe的运行文件，不需要用户自己去编译运行。直接打开上面的地址，下载好windows版的nginx，解压后双击nginx.exe或者在命令窗口运行nginx.exe即可。</p>\n</blockquote>\n<blockquote>\n<p>因为Nginx默认端口是80端口，所以启动成功之后在浏览器地址栏输入localhost就可以看到Nginx的欢迎页面。</p>\n</blockquote>\n<p>linux版的Nginx下载地址：<a href=\"http://nginx.org/\" target=\"_blank\" rel=\"noopener\">http://nginx.org/</a></p>\n<blockquote>\n<p>下载nginx之前，请确保自己的linux系统已经安装了g++，gcc。因为nginx是纯C语言编写，在linux下安装时需要去编译源码安装。</p>\n</blockquote>\n<ul>\n<li><p>解压Nginx源码包</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"selector-tag\">tar</span> <span class=\"selector-tag\">-zxvf</span> <span class=\"selector-tag\">nginx-1</span><span class=\"selector-class\">.11</span><span class=\"selector-class\">.5</span><span class=\"selector-class\">.tar</span><span class=\"selector-class\">.gz</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置一下nginx配置信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> chmod -R 777 nginx-1.11.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">cd</span> nginx-1.11.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> ./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx  <span class=\"comment\">#此处设置prefix，是设置nginx的安装路径</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">make</span> | <span class=\"built_in\">make</span> install <span class=\"meta\">#将源码文件编译成可执行文件和各种库文件，并将其复制到上面设置的安装目录中</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动nginx</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/nginx/</span>sbin<span class=\"regexp\">/nginx -c /u</span>sr<span class=\"regexp\">/local/</span>nginx<span class=\"regexp\">/conf/</span>nginx.conf <span class=\"comment\">#这一步可以不指定nginx配置文件</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>还有最重要的一步，打开Nginx的防火墙端口</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> vi /etc/sysconfig/iptables</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> 添加端口，如： -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> /etc/init.d/iptables restart <span class=\"comment\">#重启防火墙，让修改生效</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在自己本机的浏览器中输入localhost就可以看到Nginx的欢迎页面。</p>\n</li>\n</ul>\n<h4 id=\"2、配置Nginx\"><a href=\"#2、配置Nginx\" class=\"headerlink\" title=\"2、配置Nginx\"></a>2、配置Nginx</h4><p>​    在真正开始配置之前，先说一下Nginx的配置文件配置的基础知识。（Linux和Windows的配置一样，不分开说了）</p>\n<pre><code>&gt; Nginx的配置文件在安装目录下的conf目录中，一些默认配置都在这个目录下。\n</code></pre><blockquote>\n<p>nginx.conf 的注释符号为 #</p>\n</blockquote>\n<p>打开nginx.conf文件，可以大概浏览一下，配置文件基本可以分为几个模块</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">..</span>.              #全局块</span><br><span class=\"line\">events &#123;         #events块</span><br><span class=\"line\">   <span class=\"built_in\">..</span>.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http      #http块</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">..</span>.   #http全局块</span><br><span class=\"line\">   <span class=\"built_in\"> server </span>       #server块</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"built_in\">..</span>.       #server全局块</span><br><span class=\"line\">        location [PATTERN]   #location块</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">..</span>.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location [PATTERN] </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">..</span>.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">..</span>.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">..</span>.     #http全局块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>全局块：配置影像nginx的全局指令。一般有nginx的进程数，错误日志文件路径，nginx的主进程号等</li>\n<li>events块：配置Nginx的工作模式，每个进程的最大连接数等</li>\n<li>http块：可以嵌套多个server，配置代理，缓存，日志等功能以及第三方模块的配置。如文件引入，mime-type定义，连接超时时间，单连接请求数等等</li>\n<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server</li>\n<li>location块：配置请求的路由，以及各种页面的处理情况</li>\n</ul>\n<p>给大家附上一个nginx的配置文件，博主在公司的测试环境上搭的一个负载均衡器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">user  nobody;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nginx进程数，建议设置为CPU总核心数</span></span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">错误日志文件路径</span></span><br><span class=\"line\">error_log  logs/error.log;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  notice;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  info;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nginx主进程号</span></span><br><span class=\"line\">pid        logs/nginx.pid;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">工作模式与连接数上限</span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\"> 单个进程的最大连接数（最大连接数=连接数*进程数）</span></span><br><span class=\"line\">\tworker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">文件扩展名与文件类型映射表</span></span><br><span class=\"line\">\tinclude       mime.types;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">默认文件类型</span></span><br><span class=\"line\">\tdefault_type  application/octet-stream;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">日志文件</span></span><br><span class=\"line\">\taccess_log  logs/access.log  main;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 </span></span><br><span class=\"line\">\tsendfile        on;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">防止网络阻塞</span></span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">tcp_nopush     on;</span></span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">长连接超时时间，单位是秒</span></span><br><span class=\"line\">\tkeepalive_timeout  65;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">服务器列表名称随便写</span></span><br><span class=\"line\">\tupstream global &#123;</span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">upstream的负载均衡，weight是权重，可以根据机器配置定义权重，权值越高被分配到的几率越大。</span></span><br><span class=\"line\">\t\tserver 192.168.100.100:8081; #weight=1</span><br><span class=\"line\">\t\tserver 192.168.100.100:8084;</span><br><span class=\"line\">\t\tip_hash; #upstream的分配方式</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">开启gzip压缩输出</span></span><br><span class=\"line\"><span class=\"meta\">\t#</span><span class=\"bash\">gzip  on;</span></span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">监听端口</span></span><br><span class=\"line\">\t\tlisten       8087;</span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">域名可以有多个，用空格隔开</span></span><br><span class=\"line\">\t\tserver_name  192.168.100.100;</span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">默认编码</span></span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">charset koi8-r;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">对“/”启用反向代理</span></span><br><span class=\"line\">\t\tlocation / &#123;</span><br><span class=\"line\"><span class=\"meta\">\t\t\t#</span><span class=\"bash\">前端页面项目部署路径</span></span><br><span class=\"line\">\t\t\troot   /home/fisCM/nginx/html;</span><br><span class=\"line\"><span class=\"meta\">\t\t\t#</span><span class=\"bash\">默认主页面</span></span><br><span class=\"line\">\t\t\tindex  index.html index.htm;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">5xx错误对应的页面</span></span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">error_page   500 502 503 504  /50x.html;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class=\"line\"><span class=\"meta\">\t\t#</span><span class=\"bash\">我们项目的请求路径为http://192.168.100.100:8087/springboot/...</span></span><br><span class=\"line\">\t\tlocation ^~ /springboot/ &#123;</span><br><span class=\"line\"><span class=\"meta\">\t\t\t#</span><span class=\"bash\">请求转向global 定义的服务器列表</span></span><br><span class=\"line\">\t\t\tproxy_pass   http://global;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：192.168.100.100地址是博主瞎写的，读者可改为自己实际的IP地址</p>\n<p>由于项目比较简单，所以也没有太多复杂的配置，接下来对Nginx负载均衡的一些基础知识做一下简单介绍。</p>\n<h4 id=\"3、nginx的upstream的几种方式\"><a href=\"#3、nginx的upstream的几种方式\" class=\"headerlink\" title=\"3、nginx的upstream的几种方式\"></a>3、nginx的upstream的几种方式</h4><pre><code>&gt; 轮询（默认）\n</code></pre><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器冗机，能自动剔除。</p>\n<blockquote>\n<p>ip_hash</p>\n</blockquote>\n<p>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器。</p>\n<blockquote>\n<p>weight</p>\n</blockquote>\n<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>\n<blockquote>\n<p>fair(第三方)</p>\n</blockquote>\n<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<blockquote>\n<p>url_hash(第三方)</p>\n</blockquote>\n<p>按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。</p>\n<p>总结一下，负载均衡简单的理解其实可以看做是用户请求Nginx，Nginx将用户的请求URL按照配置的方式截取，然后按照配置的upstream的方式请求后端服务器。</p>\n","slug":"Nginx负载均衡配置","updated":"2017-07-11T13:34:57.000Z","comments":true,"link":"","permalink":"/2017/06/06/Nginx负载均衡配置/","excerpt":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"Nginx,负载均衡","slug":"Nginx-负载均衡","permalink":"/tags/Nginx-负载均衡/"}]},{"title":"SpringBoot动态数据源切换","date":"2017-06-01T13:30:56.000Z","path":"2017/06/01/SpringBoot动态数据源切换/","text":"最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。 1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码 1234567891011121314151617181920212223242526272829 /** * Retrieve the current target DataSource. Determines the * &#123;@link #determineCurrentLookupKey() current lookup key&#125;, performs * a lookup in the &#123;@link #setTargetDataSources targetDataSources&#125; map, * falls back to the specified * &#123;@link #setDefaultTargetDataSource default target DataSource&#125; if necessary. * @see #determineCurrentLookupKey() */protected DataSource determineTargetDataSource() &#123; Assert.notNull(this.resolvedDataSources, \"DataSource router not initialized\"); Object lookupKey = determineCurrentLookupKey(); DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123; dataSource = this.resolvedDefaultDataSource; &#125; if (dataSource == null) &#123; throw new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\"); &#125; return dataSource;&#125;/** * Determine the current lookup key. This will typically be * implemented to check a thread-bound transaction context. * &lt;p&gt;Allows for arbitrary keys. The returned key needs * to match the stored lookup key type, as resolved by the * &#123;@link #resolveSpecifiedLookupKey&#125; method. */protected abstract Object determineCurrentLookupKey(); 源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的） 所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。 2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。 123456789101112public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; /** * DynamicDataSourceContextHolder代码中使用setDataSource * 设置当前的数据源，在路由类中使用getDataSource进行获取， * 交给AbstractRoutingDataSource进行注入使用。 */ return DynamicDataSourceContextHolder.getDataSource(); &#125;&#125; 3、创建统一数据源管理类DynamicDataSourceContextHolder 12345678910111213141516171819202122public class DynamicDataSourceContextHolder &#123; // 线程本地环境 private static final ThreadLocal&lt;String&gt; dataSources = new ThreadLocal&lt;String&gt;(); // 管理所有的数据源Id public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;String&gt;(); public static void setDataSource(String dataSource) &#123; dataSources.set(dataSource); &#125; public static String getDataSource() &#123; return dataSources.get(); &#125; public static void clearDataSource() &#123; dataSources.remove(); &#125; // 判断指定的DataSource当前是否存在 public static boolean containsDataSource(String dataSourceId) &#123; return dataSourceIds.contains(dataSourceId); &#125;&#125; 4、重点来了，创建动态数据源注册器DynamicDataSourceRegister 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // 默认数据连接池 public static final Object DATASOURCE_TYPE_DEFAULT = \"org.apache.tomcat.jdbc.pool.DataSource\"; private Class&lt;? extends DataSource&gt; dataSourceType; // 默认数据源 private DataSource defaultDataSource; private Map&lt;String, DataSource&gt; dataSourceMaps = new HashMap&lt;String, DataSource&gt;(); /** * 加载多数据源配置 * @param environment */ @Override public void setEnvironment(Environment environment) &#123; initDefaultDataSource(environment); &#125; /** * 初始化默认数据源 * @param environment */ private void initDefaultDataSource(Environment environment) &#123; RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(environment, \"spring.datasource.\"); try &#123; if(propertyResolver.getProperty(\"type\") == null) &#123; dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString()); &#125; else &#123; dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(\"type\")); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 创建数据源 String jndiName = propertyResolver.getProperty(\"jndi-name\"); String[] jndiNames = jndiName.split(\",\"); defaultDataSource = new JndiDataSourceLookup().getDataSource(jndiNames[0]); dataSourceMaps.put(\"AAA\", defaultDataSource); DataSource dataSource1 = new JndiDataSourceLookup().getDataSource(jndiNames[1]); dataSourceMaps.put(\"BBB\", dataSource1); &#125; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; Map&lt;String, Object&gt; targetDataSources = new HashMap&lt;String, Object&gt;(); // 将主数据源添加到更多数据源中 targetDataSources.put(\"dataSource\", defaultDataSource); DynamicDataSourceContextHolder.dataSourceIds.add(\"dataSource\"); // 添加更多数据源 targetDataSources.putAll(dataSourceMaps); for(String key : dataSourceMaps.keySet()) &#123; DynamicDataSourceContextHolder.dataSourceIds.add(key); &#125; // 创建DynamicDataSource GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(DynamicDataSource.class); beanDefinition.setSynthetic(true); MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues(); mutablePropertyValues.addPropertyValue(\"defaultTargetDataSource\", defaultDataSource); mutablePropertyValues.addPropertyValue(\"targetDataSources\", targetDataSources); beanDefinitionRegistry.registerBeanDefinition(\"dataSource\", beanDefinition); &#125;&#125; 好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释 &gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中 &gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。 5、将动态数据源注册器导入到Spring容器中 1234567@SpringBootApplication@Import(&#123;DynamicDataSourceRegister.class&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件： 导入的类使用@Configuration进行标注 导入的类中至少有一个使用@Bean标准的方法 导入的类实现了ImportSelector接口 导入的类实现了ImportBeanDefinitionRegistrar接口 到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础 6、新建一个TargetDataSource注解 123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource &#123; String value();&#125; 此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。 7、新建数据源切换AOP切面 123456789101112131415161718192021222324@Aspect@Order(-1) //保证此AOP在@Transactional之前执行@Componentpublic class DynamicDataSourceAspect &#123; private transient static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); // 通过注解切换数据源（细粒度） @Around(\"@annotation(targetDataSource)\") public Object changeDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable &#123; Object object = null; String dataSourceId = targetDataSource.value(); if(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123; logger.info(\"系统将使用&#123;&#125;数据源\", dataSourceId); DynamicDataSourceContextHolder.setDataSource(dataSourceId); &#125; else &#123; logger.debug(\"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;\", dataSourceId, joinPoint.getSignature()); &#125; object=joinPoint.proceed(); DynamicDataSourceContextHolder.clearDataSource(); return object; &#125;&#125; 解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。 最后附一下JNDI数据源在application.properties文件中的配置 1spring.datasource.jndi-name=java:comp/env/jdbc/AAA,java:comp/env/jdbc/BBB 其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。 ————————————————华丽的分割线—————————————————- 在项目的进展中，此数据源切换已被改造，增加了Druid数据源加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取","raw":"---\nlayout: post\ntitle: SpringBoot动态数据源切换\ntoc: true\ndate: 2017-06-01 21:30:56\ntags: SpringBoot\ncategories: SpringBoot\ndescription:\n---\n\n最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。<!--more-->\n\n---\n\n- 1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码\n\n\n```java\n    /**\n\t * Retrieve the current target DataSource. Determines the\n\t * {@link #determineCurrentLookupKey() current lookup key}, performs\n\t * a lookup in the {@link #setTargetDataSources targetDataSources} map,\n\t * falls back to the specified\n\t * {@link #setDefaultTargetDataSource default target DataSource} if necessary.\n\t * @see #determineCurrentLookupKey()\n\t */\n\tprotected DataSource determineTargetDataSource() {\n\t\tAssert.notNull(this.resolvedDataSources, \"DataSource router not initialized\");\n\t\tObject lookupKey = determineCurrentLookupKey();\n\t\tDataSource dataSource = this.resolvedDataSources.get(lookupKey);\n\t\tif (dataSource == null && (this.lenientFallback || lookupKey == null)) {\n\t\t\tdataSource = this.resolvedDefaultDataSource;\n\t\t}\n\t\tif (dataSource == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\");\n\t\t}\n\t\treturn dataSource;\n\t}\n\n\t/**\n\t * Determine the current lookup key. This will typically be\n\t * implemented to check a thread-bound transaction context.\n\t * <p>Allows for arbitrary keys. The returned key needs\n\t * to match the stored lookup key type, as resolved by the\n\t * {@link #resolveSpecifiedLookupKey} method.\n\t */\n\tprotected abstract Object determineCurrentLookupKey();\n```\n源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的）\n\n所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。\n\n- 2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。\n\n\n```java\n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            /**\n             * DynamicDataSourceContextHolder代码中使用setDataSource\n             * 设置当前的数据源，在路由类中使用getDataSource进行获取，\n             * 交给AbstractRoutingDataSource进行注入使用。\n             */\n            return DynamicDataSourceContextHolder.getDataSource();\n        }\n    }\n```\n\n- 3、创建统一数据源管理类DynamicDataSourceContextHolder\n\n```java\n    public class DynamicDataSourceContextHolder {\n    \n        // 线程本地环境\n        private static final ThreadLocal<String> dataSources = new ThreadLocal<String>();\n        // 管理所有的数据源Id\n        public static List<String> dataSourceIds = new ArrayList<String>();\n        \n        public static void setDataSource(String dataSource) {\n            dataSources.set(dataSource);\n        }\n        public static String getDataSource() {\n            return dataSources.get();\n        }\n        public static void clearDataSource() {\n            dataSources.remove();\n        }\n        \n        // 判断指定的DataSource当前是否存在\n        public static boolean containsDataSource(String dataSourceId) {\n            return dataSourceIds.contains(dataSourceId);\n        }\n    }\n```\n\n- 4、重点来了，创建动态数据源注册器DynamicDataSourceRegister\n\n```java\n    public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    // 默认数据连接池\n    public static final Object DATASOURCE_TYPE_DEFAULT = \"org.apache.tomcat.jdbc.pool.DataSource\";\n\n    private Class<? extends DataSource> dataSourceType;\n\n    // 默认数据源\n    private DataSource defaultDataSource;\n\n    private Map<String, DataSource> dataSourceMaps = new HashMap<String, DataSource>();\n\n    /**\n     * 加载多数据源配置\n     * @param environment\n     */\n    @Override\n    public void setEnvironment(Environment environment) {\n        initDefaultDataSource(environment);\n    }\n\n    /**\n     * 初始化默认数据源\n     * @param environment\n     */\n    private void initDefaultDataSource(Environment environment) {\n        RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(environment, \"spring.datasource.\");\n        try {\n            if(propertyResolver.getProperty(\"type\") == null) {\n                dataSourceType = (Class<? extends DataSource>)Class.forName(DATASOURCE_TYPE_DEFAULT.toString());\n            } else {\n                dataSourceType = (Class<? extends DataSource>)Class.forName(propertyResolver.getProperty(\"type\"));\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        // 创建数据源\n        String jndiName = propertyResolver.getProperty(\"jndi-name\");\n        String[] jndiNames = jndiName.split(\",\");\n        defaultDataSource = new JndiDataSourceLookup().getDataSource(jndiNames[0]);\n\n        dataSourceMaps.put(\"AAA\", defaultDataSource);\n        DataSource dataSource1 = new JndiDataSourceLookup().getDataSource(jndiNames[1]);\n        dataSourceMaps.put(\"BBB\", dataSource1);\n    }\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) {\n        Map<String, Object> targetDataSources = new HashMap<String, Object>();\n        // 将主数据源添加到更多数据源中\n        targetDataSources.put(\"dataSource\", defaultDataSource);\n        DynamicDataSourceContextHolder.dataSourceIds.add(\"dataSource\");\n\n        // 添加更多数据源\n        targetDataSources.putAll(dataSourceMaps);\n        for(String key : dataSourceMaps.keySet()) {\n            DynamicDataSourceContextHolder.dataSourceIds.add(key);\n        }\n\n        // 创建DynamicDataSource\n        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n        beanDefinition.setBeanClass(DynamicDataSource.class);\n        beanDefinition.setSynthetic(true);\n\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        mutablePropertyValues.addPropertyValue(\"defaultTargetDataSource\", defaultDataSource);\n        mutablePropertyValues.addPropertyValue(\"targetDataSources\", targetDataSources);\n        beanDefinitionRegistry.registerBeanDefinition(\"dataSource\", beanDefinition);\n    }\n}\n\n\n```\n    好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释\n\n    > EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中\n    > ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。\n\n5、将动态数据源注册器导入到Spring容器中\n\n```java\n    @SpringBootApplication\n    @Import({DynamicDataSourceRegister.class})\n    public class Application {\n        public static void main(String[] args) {\n            SpringApplication.run(Application.class, args);\n        }\n    }\n```\n\n   > 需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件：\n\n1.    导入的类使用@Configuration进行标注\n2.    导入的类中至少有一个使用@Bean标准的方法\n3.    导入的类实现了ImportSelector接口\n4.    导入的类实现了ImportBeanDefinitionRegistrar接口\n\n到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础\n\n- 6、新建一个TargetDataSource注解\n\n```java\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface TargetDataSource {\n        String value();\n    }\n```\n此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(\"AAA\")注解即可，还没完，继续往下看。\n\n- 7、新建数据源切换AOP切面\n\n```java\n@Aspect\n@Order(-1)  //保证此AOP在@Transactional之前执行\n@Component\npublic class DynamicDataSourceAspect {\n\n    private transient static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);\n\n    // 通过注解切换数据源（细粒度）\n    @Around(\"@annotation(targetDataSource)\")\n    public Object changeDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable {\n        Object object = null;\n        String dataSourceId = targetDataSource.value();\n        if(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) {\n            logger.info(\"系统将使用{}数据源\", dataSourceId);\n            DynamicDataSourceContextHolder.setDataSource(dataSourceId);\n        } else {\n            logger.debug(\"数据源{}不存在，将使用默认数据源{}\", dataSourceId, joinPoint.getSignature());\n        }\n        object=joinPoint.proceed();\n        DynamicDataSourceContextHolder.clearDataSource();\n        return object;\n    }\n\n}\n```\n解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。\n\n最后附一下JNDI数据源在application.properties文件中的配置\n\n\n```properties\n    spring.datasource.jndi-name=java:comp/env/jdbc/AAA,java:comp/env/jdbc/BBB\n```\n\n其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。\n\n\n------------------------------------------------华丽的分割线----------------------------------------------------\n\n在项目的进展中，此数据源切换已被改造，增加了[Druid数据源](https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter)加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取\n","content":"<p>最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。<a id=\"more\"></a></p>\n<hr>\n<ul>\n<li>1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Retrieve the current target DataSource. Determines the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #determineCurrentLookupKey() current lookup key&#125;, performs</span></span><br><span class=\"line\"><span class=\"comment\"> * a lookup in the &#123;<span class=\"doctag\">@link</span> #setTargetDataSources targetDataSources&#125; map,</span></span><br><span class=\"line\"><span class=\"comment\"> * falls back to the specified</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #setDefaultTargetDataSource default target DataSource&#125; if necessary.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #determineCurrentLookupKey()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DataSource <span class=\"title\">determineTargetDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tAssert.notNull(<span class=\"keyword\">this</span>.resolvedDataSources, <span class=\"string\">\"DataSource router not initialized\"</span>);</span><br><span class=\"line\">\tObject lookupKey = determineCurrentLookupKey();</span><br><span class=\"line\">\tDataSource dataSource = <span class=\"keyword\">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dataSource == <span class=\"keyword\">null</span> &amp;&amp; (<span class=\"keyword\">this</span>.lenientFallback || lookupKey == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">\t\tdataSource = <span class=\"keyword\">this</span>.resolvedDefaultDataSource;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dataSource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Cannot determine target DataSource for lookup key [\"</span> + lookupKey + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Determine the current lookup key. This will typically be</span></span><br><span class=\"line\"><span class=\"comment\"> * implemented to check a thread-bound transaction context.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Allows for arbitrary keys. The returned key needs</span></span><br><span class=\"line\"><span class=\"comment\"> * to match the stored lookup key type, as resolved by the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #resolveSpecifiedLookupKey&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的）</p>\n<p>所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。</p>\n<ul>\n<li>2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSource</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * DynamicDataSourceContextHolder代码中使用setDataSource</span></span><br><span class=\"line\"><span class=\"comment\">         * 设置当前的数据源，在路由类中使用getDataSource进行获取，</span></span><br><span class=\"line\"><span class=\"comment\">         * 交给AbstractRoutingDataSource进行注入使用。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicDataSourceContextHolder.getDataSource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3、创建统一数据源管理类DynamicDataSourceContextHolder</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线程本地环境</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; dataSources = <span class=\"keyword\">new</span> ThreadLocal&lt;String&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 管理所有的数据源Id</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; dataSourceIds = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setDataSource</span><span class=\"params\">(String dataSource)</span> </span>&#123;</span><br><span class=\"line\">        dataSources.set(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSources.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        dataSources.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 判断指定的DataSource当前是否存在</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsDataSource</span><span class=\"params\">(String dataSourceId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSourceIds.contains(dataSourceId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、重点来了，创建动态数据源注册器DynamicDataSourceRegister</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceRegister</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span>, <span class=\"title\">EnvironmentAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 默认数据连接池</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object DATASOURCE_TYPE_DEFAULT = <span class=\"string\">\"org.apache.tomcat.jdbc.pool.DataSource\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;? extends DataSource&gt; dataSourceType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 默认数据源</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource defaultDataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, DataSource&gt; dataSourceMaps = <span class=\"keyword\">new</span> HashMap&lt;String, DataSource&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载多数据源配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> environment</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEnvironment</span><span class=\"params\">(Environment environment)</span> </span>&#123;</span><br><span class=\"line\">        initDefaultDataSource(environment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化默认数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> environment</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initDefaultDataSource</span><span class=\"params\">(Environment environment)</span> </span>&#123;</span><br><span class=\"line\">        RelaxedPropertyResolver propertyResolver = <span class=\"keyword\">new</span> RelaxedPropertyResolver(environment, <span class=\"string\">\"spring.datasource.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(propertyResolver.getProperty(<span class=\"string\">\"type\"</span>) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(<span class=\"string\">\"type\"</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建数据源</span></span><br><span class=\"line\">        String jndiName = propertyResolver.getProperty(<span class=\"string\">\"jndi-name\"</span>);</span><br><span class=\"line\">        String[] jndiNames = jndiName.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">        defaultDataSource = <span class=\"keyword\">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        dataSourceMaps.put(<span class=\"string\">\"AAA\"</span>, defaultDataSource);</span><br><span class=\"line\">        DataSource dataSource1 = <span class=\"keyword\">new</span> JndiDataSourceLookup().getDataSource(jndiNames[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        dataSourceMaps.put(<span class=\"string\">\"BBB\"</span>, dataSource1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; targetDataSources = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 将主数据源添加到更多数据源中</span></span><br><span class=\"line\">        targetDataSources.put(<span class=\"string\">\"dataSource\"</span>, defaultDataSource);</span><br><span class=\"line\">        DynamicDataSourceContextHolder.dataSourceIds.add(<span class=\"string\">\"dataSource\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加更多数据源</span></span><br><span class=\"line\">        targetDataSources.putAll(dataSourceMaps);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String key : dataSourceMaps.keySet()) &#123;</span><br><span class=\"line\">            DynamicDataSourceContextHolder.dataSourceIds.add(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建DynamicDataSource</span></span><br><span class=\"line\">        GenericBeanDefinition beanDefinition = <span class=\"keyword\">new</span> GenericBeanDefinition();</span><br><span class=\"line\">        beanDefinition.setBeanClass(DynamicDataSource.class);</span><br><span class=\"line\">        beanDefinition.setSynthetic(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();</span><br><span class=\"line\">        mutablePropertyValues.addPropertyValue(<span class=\"string\">\"defaultTargetDataSource\"</span>, defaultDataSource);</span><br><span class=\"line\">        mutablePropertyValues.addPropertyValue(<span class=\"string\">\"targetDataSources\"</span>, targetDataSources);</span><br><span class=\"line\">        beanDefinitionRegistry.registerBeanDefinition(<span class=\"string\">\"dataSource\"</span>, beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释\n\n&gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中\n&gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。\n</code></pre><p>5、将动态数据源注册器导入到Spring容器中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;DynamicDataSourceRegister.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Application.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件：</p>\n</blockquote>\n<ol>\n<li>导入的类使用@Configuration进行标注</li>\n<li>导入的类中至少有一个使用@Bean标准的方法</li>\n<li>导入的类实现了ImportSelector接口</li>\n<li>导入的类实现了ImportBeanDefinitionRegistrar接口</li>\n</ol>\n<p>到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础</p>\n<ul>\n<li>6、新建一个TargetDataSource注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> TargetDataSource &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。</p>\n<ul>\n<li>7、新建数据源切换AOP切面</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Order</span>(-<span class=\"number\">1</span>)  <span class=\"comment\">//保证此AOP在@Transactional之前执行</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过注解切换数据源（细粒度）</span></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"@annotation(targetDataSource)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">changeDataSource</span><span class=\"params\">(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String dataSourceId = targetDataSource.value();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"系统将使用&#123;&#125;数据源\"</span>, dataSourceId);</span><br><span class=\"line\">            DynamicDataSourceContextHolder.setDataSource(dataSourceId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;\"</span>, dataSourceId, joinPoint.getSignature());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        object=joinPoint.proceed();</span><br><span class=\"line\">        DynamicDataSourceContextHolder.clearDataSource();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。</p>\n<p>最后附一下JNDI数据源在application.properties文件中的配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.jndi-name=java:comp/env/jdbc/AAA,java:comp/env/jdbc/BBB</span><br></pre></td></tr></table></figure>\n<p>其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。</p>\n<p>————————————————华丽的分割线—————————————————-</p>\n<p>在项目的进展中，此数据源切换已被改造，增加了<a href=\"https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\" target=\"_blank\" rel=\"noopener\">Druid数据源</a>加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取</p>\n","slug":"SpringBoot动态数据源切换","updated":"2018-05-12T16:03:07.000Z","comments":true,"link":"","permalink":"/2017/06/01/SpringBoot动态数据源切换/","excerpt":"最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/tags/SpringBoot/"}]},{"title":"java基本数据类型缓存解析","date":"2016-12-21T16:46:28.000Z","path":"2016/12/22/java基本数据类型缓存解析/","text":"基本类型缓存解析一、Integer缓存解析：123456789101112131415161718192021222324252627282930private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low)); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。 所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false注意：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=参数即可。 二、Long及Byte、Character缓存解析12345678910111213141516private static class LongCache &#123; private LongCache()&#123;&#125; static final Long cache[] = new Long[-(-128) + 127 + 1]; static &#123; for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); &#125;&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。","raw":"---\nlayout: post\ntitle: java基本数据类型缓存解析\ndate: 2016-12-22 00:46:28\ntoc: true\ntags: java缓存\ncategories: java基础\ndescription:\n---\n## 基本类型缓存解析<!--more-->\n### 一、Integer缓存解析：\n\n```\n\tprivate static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low));\n            }\n            high = h;\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n        }\n        private IntegerCache() {}\n    }\n\n\tpublic static Integer valueOf(int i) {\n    \tassert IntegerCache.high >= 127;\n\t    if (i >= IntegerCache.low && i <= IntegerCache.high)\n\t        return IntegerCache.cache[i + (-IntegerCache.low)];\n\t    return new Integer(i);\n\t}\n\n```\n1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。<p>\n2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。<p>\n3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。<p>\n\n所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false<p>\n****注意****：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=<size>参数即可。\n### 二、Long及Byte、Character缓存解析\n\n```\n\tprivate static class LongCache {\n    \tprivate LongCache(){}\n\t    static final Long cache[] = new Long[-(-128) + 127 + 1];\n\t    static {\n\t        for(int i = 0; i < cache.length; i++)\n\t            cache[i] = new Long(i - 128);\n\t    }\n\t}\n\n\tpublic static Long valueOf(long l) {\n\t    final int offset = 128;\n\t    if (l >= -128 && l <= 127) { // will cache\n\t        return LongCache.cache[(int)l + offset];\n\t    }\n\t    return new Long(l);\n\t}\n```\nLong的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。","content":"<h2 id=\"基本类型缓存解析\"><a href=\"#基本类型缓存解析\" class=\"headerlink\" title=\"基本类型缓存解析\"></a>基本类型缓存解析<a id=\"more\"></a></h2><h3 id=\"一、Integer缓存解析：\"><a href=\"#一、Integer缓存解析：\" class=\"headerlink\" title=\"一、Integer缓存解析：\"></a>一、Integer缓存解析：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\">       <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">           <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">           String integerCacheHighPropValue =</span><br><span class=\"line\">               sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">               i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">               <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">               h = Math.min(i, Integer.MAX_VALUE - (-low));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           high = h;</span><br><span class=\"line\">           cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">           <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">               cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。</p><p><br>2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。</p><p><br>3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。</p><p></p>\n<p>所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false</p><p><br><strong><strong>注意</strong></strong>：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=<size>参数即可。</size></p>\n<h3 id=\"二、Long及Byte、Character缓存解析\"><a href=\"#二、Long及Byte、Character缓存解析\" class=\"headerlink\" title=\"二、Long及Byte、Character缓存解析\"></a>二、Long及Byte、Character缓存解析</h3><figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongCache</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> LongCache()&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">Long</span> cache[] = <span class=\"keyword\">new</span> <span class=\"keyword\">Long</span>[-(<span class=\"number\">-128</span>) + <span class=\"number\">127</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cache.length; i++)</span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">Long</span>(i - <span class=\"number\">128</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">Long</span> valueOf(<span class=\"keyword\">long</span> l) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset = <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= <span class=\"number\">-128</span> &amp;&amp; l &lt;= <span class=\"number\">127</span>) &#123; <span class=\"comment\">// will cache</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> LongCache.cache[(<span class=\"keyword\">int</span>)l + offset];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">Long</span>(l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。</p>\n","slug":"java基本数据类型缓存解析","updated":"2016-12-22T14:25:10.000Z","comments":true,"link":"","permalink":"/2016/12/22/java基本数据类型缓存解析/","excerpt":"基本类型缓存解析","categories":[{"name":"java基础","slug":"java基础","permalink":"/categories/java基础/"}],"tags":[{"name":"java缓存","slug":"java缓存","permalink":"/tags/java缓存/"}]},{"title":"Spring Boot核心","date":"2016-12-18T12:26:36.000Z","path":"2016/12/18/Spring-Boot核心/","text":"一、Spring Boot基本配置 1、入口类和@SpringBootApplicationSpring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),启动Spring Boot应用项目。 2、关闭特定的自动配置通过@SpringBootApplication源码可以看出，关闭特定的自动配置应该使用@SpringBootApplication注解的exclude参数，例如:@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 3、定制Banner在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。1）我们在src/main/resources下新建一个banner.txt2）通过http://patorjk.com/software/taag网站生成字符，将生成的字符复制到banner.txt文件中3）自动程序，这时控制台图案将变成刚才生成的图案 4、关闭banner在main方法中修改为(Spring Boot:1.4.0)： 123SpringApplication application = new SpringApplication(Chapter1Application.class); application.setBannerMode(Mode.OFF); application.run(args); 或者 123new SpringApplicationBuilder(Chapter1Application.class) // .bannerMode(Mode.OFF) // .run(args); 5、Spring Boot配置文件Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。例如：修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在application.properties中添加： 12server.port=9090 server.context-path=/helloBoot 6、官方starter pomspring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 准生产特性，用来监控和管理应用spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供基于ssh协议的监控和管理spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-rabbit来支持AMQPspring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Batch的支持spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Cache抽象的支持spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-elasticsearch对Elasticsearch的支持spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-gemfire对分布式存储GenFile的支持spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JPA的支持，包含spring-data-jpa，spring-orm和Hibernatespring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-mongodb，对MongoDB进行支持spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-solr对Apache Solr数据检索平台的支持spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对FreeMarker模板引擎的支持spring-boot-starter-groovy-templates &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持spring-boot-starter-hateoas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas 通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持spring-boot-starter-hornetq &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持spring-boot-starter-integration &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持spring-boot-starter-jdbc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持spring-boot-starter-jersey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持spring-boot-starter-jta-atomikos &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持spring-boot-starter-jta-bitronix &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持spring-boot-starter-mail &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持spring-boot-starter-mobile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持spring-boot-starter-mustache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持spring-boot-starter-redis &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reidsspring-boot-starter-security &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持spring-boot-starter-social-faceboot &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持spring-boot-starter-social-twitter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持spring-boot-starter-test &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板spring-boot-starter-thymeleaf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置spring-boot-starter-velocity &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持spring-boot-starter-web &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvcspring-boot-starter-Tomcat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcatspring-boot-starter-Jetty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcatspring-boot-starter-undertow &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcatspring-boot-starter-logging &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logbackspring-boot-starter-log4j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持spring-boot-starter-ws &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持 还有第三方为Spring Boot所写的starter pom,这里不做介绍 7、使用xml配置Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的@ImportResource来加载xml配置，例如： 1@ImportResource(&#123;\"classpath:context.xml”&#125;) 8、命令行参数配置Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号 9、常规属性配置在常规Spring环境下，注入properties文件里的值得方式，通过@PropertySource指明properties文件的位置，然后通过@Value注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用@Value注入即可。例如：在application.properties文件中添加属性： 12book.author=cmbook.name=spring boot 在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性 12345678910111213141516171819@Componentpublic class PropertiesTests &#123; @Value(\"book.author\") private String author; @Value(\"book.name\") private String name; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 10、类型安全的配置（基于properties）Spring Boot提供了基于类型安全的配置方式，通过@ConfigurationProperties将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为： 123456789101112131415161718@Component@ConfigurationProperties(prefix = \"book\")public class PropertiesTests &#123; private String author; private String name; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 11、日志配置Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。默认情况下，Spring Boot使用Logback作为日志框架。日志级别:logging.file=/home/cm/mylog.log配置日志文件，格式为logging.level.包名=级别：logging.level.org.springframework.web=DEBUG 12、Profile配置Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),通过在application.properties中设置spring.profiles.active=prod来指定活动的Profile例如：我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。两种配置文件分别为： 12application-prod.properties: server.port=80application-dev.properties: server.port=8888 然后在application.properties增加： 1spring.profiles.active=dev(prod) 通过Profile可以灵活切换Spring Boot项目的配置了。 二、Spring Boot运行原理Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：1）运行jar时增加—debug参数：java -jar xx.jar —debug2)在application.properties中设置属性：debug=true（这个方便点）3）在开发工具启动参数中配置 1、Spring Boot运行原理解析： 对@SpringBootApplication注解说明： @SpringBootApplication是一个组合注解，它的核心功能是由@EnableAutoConfiguration注解提供的。查看@EnableAutoConfiguration源码这里@Import注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。 任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下： @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下 @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下 @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件 @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件 @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下 @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下 @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值 @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值 @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下这些注解都是使用了@Conditional元注解，不过是使用了不同的条件而已。 2、分析http的编码配置配置参数 HttpEncodingProperties的源码如下：这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。根据条件配置CharacterEncodingFilter的Bean，源码如下: 3、自定义自动配置（包装成starter pom）1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置: 12345678910111213141516&lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2) 新建属性配置类HellpServiceProperties 1234567891011@ConfigurationProperties(prefix = \"hello\")public class HelloServiceProperties &#123; private static final String MSG = \"world\"; private String msg = MSG; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world 3）新建依据类HelloService（此类可以是第三方类库的类） 123456789101112public class HelloService &#123; private String msg; public String sayHello() &#123; return \"Hello \" + msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 4）新建自动配置类 123456789101112131415@Configuration@EnableConfigurationProperties(HelloServiceProperties.class)@ConditionalOnClass(HelloService.class)@ConditionalOnProperty(prefix = \"hello\", value = \"enabled\", matchIfMissing = true)public class HelloServiceAutoConfiguration &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean @ConditionalOnMissingBean(HelloService.class) public HelloService helloService() &#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 根据HelloServiceProperties提供的参数，并通过@ConditionalOnClass来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。5）注册自动配置在src/main/resources中新建META-INF/spring.factories文件，内容为 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.gnd.springboot.config.HelloServiceAutoConfiguration&lt;br&gt; 其中“\\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔6）测试自定义自动配置新建一个maven web工程，添加如下依赖: 12345678910111213141516&lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;spring-boot-starter-hello&lt;/groupId&gt; &lt;artifactId&gt;com.gnd.springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-hello为之前新建的自定义自动配置starter pom新建测试启动类 12345678910111213@RestController@SpringBootApplicationpublic class Chapter11Application &#123; @Autowired private HelloService helloService; @RequestMapping(\"/test\") public String index() &#123; return helloService.sayHello(); &#125; public static void main(String[] args)&#123; SpringApplication.run(Chapter11Application.class, args); &#125;&#125; 运行测试工程之后，浏览器输入”http://localhost:8080/test“测试，测试结果如下:新建application.properties配置文件，内容为 1hello.msg=haha 重启工程，浏览器输入”http://localhost:8080/test“测试，测试结果如下:","raw":"---\nlayout: post\ntitle: Spring Boot核心\ndate: 2016-12-18 20:26:36\ntags: SpringBoot\ncategories: SpringBoot\ntoc: true\ndescription:\n---\n\n## 一、Spring Boot基本配置\n<p>\n####   1、入口类和@SpringBootApplication\nSpring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),<!--more-->启动Spring Boot应用项目。\n####   2、关闭特定的自动配置\n通过**@SpringBootApplication**源码可以看出，关闭特定的自动配置应该使用**@SpringBootApplication**注解的exclude参数，例如:\n@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})\n####   3、定制Banner\n在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。\n1）我们在src/main/resources下新建一个banner.txt\n2）通过[http://patorjk.com/software/taag](http://patorjk.com/software/taag)网站生成字符，将生成的字符复制到banner.txt文件中\n3）自动程序，这时控制台图案将变成刚才生成的图案\n####   4、关闭banner\n在main方法中修改为(Spring Boot:1.4.0)：\n\n```\n\tSpringApplication application = new SpringApplication(Chapter1Application.class);\n    application.setBannerMode(Mode.OFF);\n    application.run(args);\n```\n  或者\n\n```\n\tnew SpringApplicationBuilder(Chapter1Application.class) //\n                .bannerMode(Mode.OFF) //\n\t\t\t\t.run(args);\n```\n####   5、Spring Boot配置文件\nSpring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。<p>\nSpring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。<p>\nSpring Boot的全局配置文件的作用是对一些默认配置值进行修改。<br>\n例如：<br>\n修改tomcat端口为8080->8888，默认的访问路径为\"/\"->”/helloboot”。可以在\napplication.properties中添加：\n\n```\n\tserver.port=9090\n    server.context-path=/helloBoot\n```\n#### 6、官方starter pom\n<div style=\"color:gray\">\nspring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持<br>\nspring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  准生产特性，用来监控和管理应用<br>\nspring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  提供基于ssh协议的监控和管理<br>\nspring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用spring-rabbit来支持AMQP<br>\nspring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成<br>\nspring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Batch的支持<br>\nspring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Cache抽象的支持<br>\nspring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法<br>\nspring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-elasticsearch对Elasticsearch的支持<br>\nspring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-gemfire对分布式存储GenFile的支持<br>\nspring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对JPA的支持，包含spring-data-jpa，spring-orm和Hibernate<br>\nspring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-mongodb，对MongoDB进行支持<br>\nspring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务<br>\nspring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-solr对Apache Solr数据检索平台的支持<br>\nspring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对FreeMarker模板引擎的支持<br>\nspring-boot-starter-groovy-templates  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持<br>\nspring-boot-starter-hateoas  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas  通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持<br>\nspring-boot-starter-hornetq  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持<br>\nspring-boot-starter-integration  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持<br>\nspring-boot-starter-jdbc  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持<br>\nspring-boot-starter-jersey  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持<br>\nspring-boot-starter-jta-atomikos  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持<br>\nspring-boot-starter-jta-bitronix  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持<br>\nspring-boot-starter-mail  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持<br>\nspring-boot-starter-mobile  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持<br>\nspring-boot-starter-mustache  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持<br>\nspring-boot-starter-redis  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reids<br>\nspring-boot-starter-security  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持<br>\nspring-boot-starter-social-faceboot  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持<br>\nspring-boot-starter-social-twitter   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持<br>\nspring-boot-starter-test  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板<br>\nspring-boot-starter-thymeleaf  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置<br>\nspring-boot-starter-velocity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持<br>\nspring-boot-starter-web  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvc<br>\nspring-boot-starter-Tomcat  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcat<br>\nspring-boot-starter-Jetty  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcat<br>\nspring-boot-starter-undertow  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcat<br>\nspring-boot-starter-logging  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logback<br>\nspring-boot-starter-log4j  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架<br>\nspring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持<br>\nspring-boot-starter-ws  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持<br>\n</div>\n<p>\n还有第三方为Spring Boot所写的starter pom,这里不做介绍\n####    7、使用xml配置\nSpring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的**@ImportResource**来加载xml配置，例如：\n\n```\n\t@ImportResource({\"classpath:context.xml”})\n```\n#### 8、命令行参数配置\nSpring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行\n可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号\n####    9、常规属性配置\n在常规Spring环境下，注入properties文件里的值得方式，通过**@PropertySource**指明properties文件的位置，然后通过**@Value**注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用**@Value**注入即可。<br>\n例如：<br>\n在application.properties文件中添加属性：\n\n```\n     book.author=cm\n     book.name=spring boot\n```\n在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性\n\n```\n\t@Component\n\tpublic class PropertiesTests {\n\t\t@Value(\"book.author\")\n\t\tprivate String author;\n\t\t@Value(\"book.name\")\n\t\tprivate String name;\n\t\tpublic String getAuthor() {\n\t\t\treturn author;\n    \t}\n\t\tpublic void setAuthor(String author) {\n\t\t\tthis.author = author;\n\t    }\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t    }\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t    }\n\t}\n```\n####   10、类型安全的配置（基于properties）\nSpring Boot提供了基于类型安全的配置方式，通过**@ConfigurationProperties**将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为：\n\n```\n\t@Component\n\t@ConfigurationProperties(prefix = \"book\")\n\tpublic class PropertiesTests {\n\t\tprivate String author;\n\t\tprivate String name;\n\t\tpublic String getAuthor() {\n\t\t\treturn author;\n\t    }\n\t\tpublic void setAuthor(String author) {\n\t\t\tthis.author = author;\n\t    }\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t    }\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t    }\n\t}\n```\n####   11、日志配置\nSpring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。<p>\n默认情况下，Spring Boot使用Logback作为日志框架。日志级别:****logging.file=/home/cm/mylog.log****\n配置日志文件，格式为logging.level.包名=级别：****logging.level.org.springframework.web=DEBUG****\n####   12、Profile配置\nProfile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),\n通过在application.properties中设置****spring.profiles.active=prod****来指定活动的Profile\n例如：<br>\n我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。<br>\n两种配置文件分别为：<br>\n\n```\n\tapplication-prod.properties:  server.port=80\n\tapplication-dev.properties:  server.port=8888\n```\n然后在application.properties增加：\n\n```\n\tspring.profiles.active=dev(prod)\n```\n通过Profile可以灵活切换Spring Boot项目的配置了。\n## 二、Spring Boot运行原理\nSpring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：<p>\n<a href=\"http://i1.piimg.com/4851/bb6e18a430a22a09.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/bb6e18a430a22a09t.jpg\"></a>\n<a href=\"http://i1.piimg.com/4851/73ed190dbda257cb.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/73ed190dbda257cbt.jpg\"></a><p>\n若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：<p>\n1）运行jar时增加—debug参数：java -jar xx.jar —debug<p>\n2)在application.properties中设置属性：debug=true（这个方便点）<p>\n3）在开发工具启动参数中配置<p>\n<a href=\"http://i1.piimg.com/4851/db0610f744b512ec.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/db0610f744b512ect.jpg\"></a><p>\n#### 1、Spring Boot运行原理解析：\n 对@SpringBootApplication注解说明：\n  **@SpringBootApplication**是一个组合注解，它的核心功能是由**@EnableAutoConfiguration**注解提供的。\n查看**@EnableAutoConfiguration**源码<p>\n<a href=\"http://i1.piimg.com/4851/df2b568388d67082.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/df2b568388d67082t.jpg\"></a><p>\n这里**@Import**注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。\n<a href=\"http://i1.piimg.com/4851/8290194ff6bbbda5.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/8290194ff6bbbda5t.jpg\"></a><br>\n<a href=\"http://i1.piimg.com/4851/dba6c685c8097175.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/dba6c685c8097175t.jpg\"></a><p>\n       任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下：<p>\n<div style=\"color:gray\">\n\t@ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下<br>\n    @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下<br>\n     @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件<br>\n     @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件<br>\n     @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置<br>\n     @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下<br>\n     @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下<br>\n     @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下<br>\n     @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值<br>\n     @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值<br>\n     @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean<br>\n     @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下<br>\n</div><p>\n这些注解都是使用了**@Conditional**元注解，不过是使用了不同的条件而已。\n\n#### 2、分析http的编码配置\n\n配置参数\n  \n  HttpEncodingProperties的源码如下：<p>\n<a href=\"http://i1.piimg.com/4851/01b5f66dfd191b68.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/01b5f66dfd191b68t.jpg\"></a><p>\n这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。\n根据条件配置CharacterEncodingFilter的Bean，源码如下:\n<a href=\"http://i1.piimg.com/4851/6307e6e411a78c22.png\" title=\"点击显示原始图片\"><img src=\"http://i1.piimg.com/4851/6307e6e411a78c22t.jpg\"></a>\n#### 3、自定义自动配置（包装成starter pom）\n1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置:\n\n```\n\t<properties>\n    \t<spring-framework.version>1.4.0.RELEASE</spring-framework.version>\n\t    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t</properties>\n\t<dependencies>\n    \t<dependency>\n        \t<groupId>junit</groupId>\n        \t<artifactId>junit</artifactId>\n        \t<version>4.11</version>\n    \t</dependency>\n    \t<dependency>\n       \t\t<groupId>org.springframework.boot</groupId>\n\t        <artifactId>spring-boot-autoconfigure</artifactId>\n    \t    <version>${spring-framework.version}</version>\n\t    </dependency>\n\t</dependencies>\n```\n2) 新建属性配置类HellpServiceProperties\n\n```\n\t@ConfigurationProperties(prefix = \"hello\")\n\tpublic class HelloServiceProperties {\n\t    private static final String MSG = \"world\";\n\t    private String msg = MSG;\n\t    public String getMsg() {\n\t        return msg;\n    \t}\n\t    public void setMsg(String msg) {\n    \t    this.msg = msg;\n\t    }\n\t}\n```\n此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world<p>\n\n3）新建依据类HelloService（此类可以是第三方类库的类）\n\n```\n\tpublic class HelloService {\n    \tprivate String msg;\n\t    public String sayHello() {\n\t        return \"Hello \" + msg;\n\t    }\n\t    public String getMsg() {\n\t        return msg;\n\t    }\n\t    public void setMsg(String msg) {\n\t        this.msg = msg;\n\t    }\n\t}\n```\n4）新建自动配置类\n\n```\n\t@Configuration\n\t@EnableConfigurationProperties(HelloServiceProperties.class)\n\t@ConditionalOnClass(HelloService.class)\n\t@ConditionalOnProperty(prefix = \"hello\", value = \"enabled\", matchIfMissing = true)\n\tpublic class HelloServiceAutoConfiguration {\n    \t@Autowired\n\t    private HelloServiceProperties helloServiceProperties;\n\t    @Bean\n\t    @ConditionalOnMissingBean(HelloService.class)\n\t    public HelloService helloService() {\n\t        HelloService helloService = new HelloService();\n\t        helloService.setMsg(helloServiceProperties.getMsg());\n\t        return helloService;\n\t    }\n\t}\n```\n根据HelloServiceProperties提供的参数，并通过**@ConditionalOnClass**来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。<p>\n5）注册自动配置<p>\n在src/main/resources中新建META-INF/spring.factories文件，内容为\n\n```\n\torg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\t  com.gnd.springboot.config.HelloServiceAutoConfiguration<br>\n```\n\n其中“\\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔<p>\n6）测试自定义自动配置<p>\n新建一个maven web工程，添加如下依赖:\n\n```\n\t<properties>\n    \t<spring-framework.version>1.4.0.RELEASE</spring-framework.version>\n\t    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t</properties>\n\t<dependencies>\n\t    <dependency>\n\t        <groupId>org.springframework.boot</groupId>\n\t        <artifactId>spring-boot-starter-web</artifactId>\n\t        <version>${spring-framework.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>spring-boot-starter-hello</groupId>\n\t        <artifactId>com.gnd.springboot</artifactId>\n\t        <version>1.0-SNAPSHOT</version>\n\t    </dependency>\n\t</dependencies>\n```\nspring-boot-starter-hello为之前新建的自定义自动配置starter pom<p>\n新建测试启动类\n\t\n```\n\t@RestController\n\t@SpringBootApplication\n\tpublic class Chapter11Application {\n\t    @Autowired\n\t    private HelloService helloService;\n\t    @RequestMapping(\"/test\")\n\t    public String index() {\n\t        return helloService.sayHello();\n\t    }\n\t    public static void main(String[] args){\n\t        SpringApplication.run(Chapter11Application.class, args);\n\t    }\n\t}\n```\n运行测试工程之后，浏览器输入\"[http://localhost:8080/test](http://localhost:8080/test)\"测试，测试结果如下:<br>\n<a href=\"http://p1.bpimg.com/4851/6ff00c546916cb99.png\" title=\"点击显示原始图片\"><img src=\"http://p1.bpimg.com/4851/6ff00c546916cb99t.jpg\"></a><p>\n新建application.properties配置文件，内容为\n\n```\n\thello.msg=haha\n```\n重启工程，浏览器输入\"[http://localhost:8080/test](http://localhost:8080/test)\"测试，测试结果如下:\n<a href=\"http://p1.bpimg.com/4851/fbf8797b19bd1733.png\" title=\"点击显示原始图片\"><img src=\"http://p1.bpimg.com/4851/fbf8797b19bd1733t.jpg\"></a><p>\n\n\n","content":"<h2 id=\"一、Spring-Boot基本配置\"><a href=\"#一、Spring-Boot基本配置\" class=\"headerlink\" title=\"一、Spring Boot基本配置\"></a>一、Spring Boot基本配置</h2><p></p><p></p>\n<h4 id=\"1、入口类和-SpringBootApplication\"><a href=\"#1、入口类和-SpringBootApplication\" class=\"headerlink\" title=\"1、入口类和@SpringBootApplication\"></a>1、入口类和@SpringBootApplication</h4><p>Spring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),<a id=\"more\"></a>启动Spring Boot应用项目。</p>\n<h4 id=\"2、关闭特定的自动配置\"><a href=\"#2、关闭特定的自动配置\" class=\"headerlink\" title=\"2、关闭特定的自动配置\"></a>2、关闭特定的自动配置</h4><p>通过<strong>@SpringBootApplication</strong>源码可以看出，关闭特定的自动配置应该使用<strong>@SpringBootApplication</strong>注解的exclude参数，例如:<br>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p>\n<h4 id=\"3、定制Banner\"><a href=\"#3、定制Banner\" class=\"headerlink\" title=\"3、定制Banner\"></a>3、定制Banner</h4><p>在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。<br>1）我们在src/main/resources下新建一个banner.txt<br>2）通过<a href=\"http://patorjk.com/software/taag\" target=\"_blank\" rel=\"noopener\">http://patorjk.com/software/taag</a>网站生成字符，将生成的字符复制到banner.txt文件中<br>3）自动程序，这时控制台图案将变成刚才生成的图案</p>\n<h4 id=\"4、关闭banner\"><a href=\"#4、关闭banner\" class=\"headerlink\" title=\"4、关闭banner\"></a>4、关闭banner</h4><p>在main方法中修改为(Spring Boot:1.4.0)：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpringApplication <span class=\"built_in\">application</span> = new SpringApplication(Chapter1Application.<span class=\"built_in\">class</span>);</span><br><span class=\"line\">   <span class=\"built_in\">application</span>.setBannerMode(Mode.OFF);</span><br><span class=\"line\">   <span class=\"built_in\">application</span>.<span class=\"built_in\">run</span>(args);</span><br></pre></td></tr></table></figure>\n<p>  或者</p>\n<figure class=\"highlight pony\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">new</span> <span class=\"title\">SpringApplicationBuilder</span>(<span class=\"type\">Chapter1Application</span>.class) <span class=\"comment\">//</span></span></span><br><span class=\"line\"><span class=\"function\">               .<span class=\"title\">bannerMode</span>(<span class=\"type\">Mode</span>.<span class=\"type\">OFF</span>) <span class=\"comment\">//</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t.<span class=\"title\">run</span>(args);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5、Spring-Boot配置文件\"><a href=\"#5、Spring-Boot配置文件\" class=\"headerlink\" title=\"5、Spring Boot配置文件\"></a>5、Spring Boot配置文件</h4><p>Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。</p><p><br>Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p><br>Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。<br><br>例如：<br><br>修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在<br>application.properties中添加：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.<span class=\"attribute\">port</span>=9090</span><br><span class=\"line\">   server.<span class=\"attribute\">context-path</span>=/helloBoot</span><br></pre></td></tr></table></figure>\n<h4 id=\"6、官方starter-pom\"><a href=\"#6、官方starter-pom\" class=\"headerlink\" title=\"6、官方starter pom\"></a>6、官方starter pom</h4><p><div style=\"color:gray\"><br>spring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持<br><br>spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  准生产特性，用来监控和管理应用<br><br>spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  提供基于ssh协议的监控和管理<br><br>spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用spring-rabbit来支持AMQP<br><br>spring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成<br><br>spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Batch的支持<br><br>spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对Spring Cache抽象的支持<br><br>spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法<br><br>spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-elasticsearch对Elasticsearch的支持<br><br>spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-gemfire对分布式存储GenFile的支持<br><br>spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对JPA的支持，包含spring-data-jpa，spring-orm和Hibernate<br><br>spring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-mongodb，对MongoDB进行支持<br><br>spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务<br><br>spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  通过spring-data-solr对Apache Solr数据检索平台的支持<br><br>spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对FreeMarker模板引擎的支持<br><br>spring-boot-starter-groovy-templates  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持<br><br>spring-boot-starter-hateoas  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas  通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持<br><br>spring-boot-starter-hornetq  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持<br><br>spring-boot-starter-integration  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持<br><br>spring-boot-starter-jdbc  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持<br><br>spring-boot-starter-jersey  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持<br><br>spring-boot-starter-jta-atomikos  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持<br><br>spring-boot-starter-jta-bitronix  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持<br><br>spring-boot-starter-mail  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持<br><br>spring-boot-starter-mobile  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持<br><br>spring-boot-starter-mustache  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持<br><br>spring-boot-starter-redis  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reids<br><br>spring-boot-starter-security  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持<br><br>spring-boot-starter-social-faceboot  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持<br><br>spring-boot-starter-social-twitter   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持<br><br>spring-boot-starter-test  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板<br><br>spring-boot-starter-thymeleaf  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置<br><br>spring-boot-starter-velocity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持<br><br>spring-boot-starter-web  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvc<br><br>spring-boot-starter-Tomcat  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcat<br><br>spring-boot-starter-Jetty  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcat<br><br>spring-boot-starter-undertow  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcat<br><br>spring-boot-starter-logging  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logback<br><br>spring-boot-starter-log4j  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架<br><br>spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持<br><br>spring-boot-starter-ws  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持<br><br></div></p>\n<p></p><p><br>还有第三方为Spring Boot所写的starter pom,这里不做介绍</p>\n<h4 id=\"7、使用xml配置\"><a href=\"#7、使用xml配置\" class=\"headerlink\" title=\"7、使用xml配置\"></a>7、使用xml配置</h4><p>Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的<strong>@ImportResource</strong>来加载xml配置，例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">ImportResource</span>(&#123;\"<span class=\"selector-tag\">classpath</span><span class=\"selector-pseudo\">:context.xml</span>”&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"8、命令行参数配置\"><a href=\"#8、命令行参数配置\" class=\"headerlink\" title=\"8、命令行参数配置\"></a>8、命令行参数配置</h4><p>Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行<br>可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号</p>\n<h4 id=\"9、常规属性配置\"><a href=\"#9、常规属性配置\" class=\"headerlink\" title=\"9、常规属性配置\"></a>9、常规属性配置</h4><p>在常规Spring环境下，注入properties文件里的值得方式，通过<strong>@PropertySource</strong>指明properties文件的位置，然后通过<strong>@Value</strong>注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用<strong>@Value</strong>注入即可。<br><br>例如：<br><br>在application.properties文件中添加属性：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">book.<span class=\"attribute\">author</span>=cm</span><br><span class=\"line\">book.<span class=\"attribute\">name</span>=spring boot</span><br></pre></td></tr></table></figure>\n<p>在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> PropertiesTests &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Value</span>(<span class=\"string\">\"book.author\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> author;</span><br><span class=\"line\">\t<span class=\"meta\">@Value</span>(<span class=\"string\">\"book.name\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">String</span> getAuthor() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> author;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">void</span> setAuthor(<span class=\"built_in\">String</span> author) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.author = author;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">String</span> getName() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">void</span> setName(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"10、类型安全的配置（基于properties）\"><a href=\"#10、类型安全的配置（基于properties）\" class=\"headerlink\" title=\"10、类型安全的配置（基于properties）\"></a>10、类型安全的配置（基于properties）</h4><p>Spring Boot提供了基于类型安全的配置方式，通过<strong>@ConfigurationProperties</strong>将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"book\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> PropertiesTests &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> author;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">String</span> getAuthor() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> author;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">void</span> setAuthor(<span class=\"built_in\">String</span> author) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.author = author;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">String</span> getName() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">void</span> setName(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"11、日志配置\"><a href=\"#11、日志配置\" class=\"headerlink\" title=\"11、日志配置\"></a>11、日志配置</h4><p>Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。</p><p><br>默认情况下，Spring Boot使用Logback作为日志框架。日志级别:<strong><strong>logging.file=/home/cm/mylog.log</strong></strong><br>配置日志文件，格式为logging.level.包名=级别：<strong><strong>logging.level.org.springframework.web=DEBUG</strong></strong></p>\n<h4 id=\"12、Profile配置\"><a href=\"#12、Profile配置\" class=\"headerlink\" title=\"12、Profile配置\"></a>12、Profile配置</h4><p>Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),<br>通过在application.properties中设置<strong><strong>spring.profiles.active=prod</strong></strong>来指定活动的Profile<br>例如：<br><br>我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。<br><br>两种配置文件分别为：<br></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application-prod.properties:  server.<span class=\"attribute\">port</span>=80</span><br><span class=\"line\">application-dev.properties:  server.<span class=\"attribute\">port</span>=8888</span><br></pre></td></tr></table></figure>\n<p>然后在application.properties增加：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring<span class=\"selector-class\">.profiles</span><span class=\"selector-class\">.active</span>=dev(prod)</span><br></pre></td></tr></table></figure>\n<p>通过Profile可以灵活切换Spring Boot项目的配置了。</p>\n<h2 id=\"二、Spring-Boot运行原理\"><a href=\"#二、Spring-Boot运行原理\" class=\"headerlink\" title=\"二、Spring Boot运行原理\"></a>二、Spring Boot运行原理</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：</p><p><br><a href=\"http://i1.piimg.com/4851/bb6e18a430a22a09.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/bb6e18a430a22a09t.jpg\"></a><br><a href=\"http://i1.piimg.com/4851/73ed190dbda257cb.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/73ed190dbda257cbt.jpg\"></a></p><p><br>若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：</p><p><br>1）运行jar时增加—debug参数：java -jar xx.jar —debug</p><p><br>2)在application.properties中设置属性：debug=true（这个方便点）</p><p><br>3）在开发工具启动参数中配置</p><p><br><a href=\"http://i1.piimg.com/4851/db0610f744b512ec.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/db0610f744b512ect.jpg\"></a></p><p></p>\n<h4 id=\"1、Spring-Boot运行原理解析：\"><a href=\"#1、Spring-Boot运行原理解析：\" class=\"headerlink\" title=\"1、Spring Boot运行原理解析：\"></a>1、Spring Boot运行原理解析：</h4><p> 对@SpringBootApplication注解说明：<br>  <strong>@SpringBootApplication</strong>是一个组合注解，它的核心功能是由<strong>@EnableAutoConfiguration</strong>注解提供的。<br>查看<strong>@EnableAutoConfiguration</strong>源码</p><p><br><a href=\"http://i1.piimg.com/4851/df2b568388d67082.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/df2b568388d67082t.jpg\"></a></p><p><br>这里<strong>@Import</strong>注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。<br><a href=\"http://i1.piimg.com/4851/8290194ff6bbbda5.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/8290194ff6bbbda5t.jpg\"></a><br><br><a href=\"http://i1.piimg.com/4851/dba6c685c8097175.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/dba6c685c8097175t.jpg\"></a></p><p><br>       任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下：</p><p></p>\n<p><div style=\"color:gray\"><br>    @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下<br><br>    @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下<br><br>     @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件<br><br>     @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件<br><br>     @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置<br><br>     @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下<br><br>     @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下<br><br>     @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下<br><br>     @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值<br><br>     @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值<br><br>     @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean<br><br>     @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下<br><br></div></p><p><br>这些注解都是使用了<strong>@Conditional</strong>元注解，不过是使用了不同的条件而已。</p>\n<h4 id=\"2、分析http的编码配置\"><a href=\"#2、分析http的编码配置\" class=\"headerlink\" title=\"2、分析http的编码配置\"></a>2、分析http的编码配置</h4><p>配置参数</p>\n<p>  HttpEncodingProperties的源码如下：</p><p><br><a href=\"http://i1.piimg.com/4851/01b5f66dfd191b68.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/01b5f66dfd191b68t.jpg\"></a></p><p><br>这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。<br>根据条件配置CharacterEncodingFilter的Bean，源码如下:<br><a href=\"http://i1.piimg.com/4851/6307e6e411a78c22.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://i1.piimg.com/4851/6307e6e411a78c22t.jpg\"></a></p>\n<h4 id=\"3、自定义自动配置（包装成starter-pom）\"><a href=\"#3、自定义自动配置（包装成starter-pom）\" class=\"headerlink\" title=\"3、自定义自动配置（包装成starter pom）\"></a>3、自定义自动配置（包装成starter pom）</h4><p>1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t<span class=\"tag\">&lt;<span class=\"name\">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring-framework.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">       \t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">       \t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">       \t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.11<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      \t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;spring-framework.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>2) 新建属性配置类HellpServiceProperties</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServiceProperties</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String MSG = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String msg = MSG;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMsg</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">   \t    <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world</p><p></p>\n<p>3）新建依据类HelloService（此类可以是第三方类库的类）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> &#123;</span></span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> String msg;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello \"</span> + msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMsg</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4）新建自动配置类</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span>(HelloServiceProperties.<span class=\"keyword\">class</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>(HelloService.<span class=\"keyword\">class</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty</span>(prefix = <span class=\"string\">\"hello\"</span>, value = <span class=\"string\">\"enabled\"</span>, matchIfMissing = <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServiceAutoConfiguration</span> &#123;</span></span><br><span class=\"line\">   \t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HelloServiceProperties helloServiceProperties;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span>(HelloService.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HelloService helloService() &#123;</span><br><span class=\"line\">        HelloService helloService = <span class=\"keyword\">new</span> HelloService();</span><br><span class=\"line\">        helloService.setMsg(helloServiceProperties.getMsg());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helloService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据HelloServiceProperties提供的参数，并通过<strong>@ConditionalOnClass</strong>来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。</p><p><br>5）注册自动配置</p><p><br>在src/main/resources中新建META-INF/spring.factories文件，内容为</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org<span class=\"selector-class\">.springframework</span><span class=\"selector-class\">.boot</span><span class=\"selector-class\">.autoconfigure</span><span class=\"selector-class\">.EnableAutoConfiguration</span>=\\\t  com<span class=\"selector-class\">.gnd</span><span class=\"selector-class\">.springboot</span><span class=\"selector-class\">.config</span><span class=\"selector-class\">.HelloServiceAutoConfiguration</span>&lt;br&gt;</span><br></pre></td></tr></table></figure>\n<p>其中“\\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔</p><p><br>6）测试自定义自动配置</p><p><br>新建一个maven web工程，添加如下依赖:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   \t<span class=\"tag\">&lt;<span class=\"name\">spring-framework.version</span>&gt;</span>1.4.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring-framework.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;spring-framework.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>spring-boot-starter-hello<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>com.gnd.springboot<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>spring-boot-starter-hello为之前新建的自定义自动配置starter pom</p><p><br>新建测试启动类</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@RestController</span></span><br><span class=\"line\"><span class=\"variable\">@SpringBootApplication</span></span><br><span class=\"line\">public class Chapter11Application &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Autowired</span></span><br><span class=\"line\">    private HelloService helloService;</span><br><span class=\"line\">    <span class=\"variable\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">    public String index() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">helloService</span><span class=\"selector-class\">.sayHello</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">public</span> <span class=\"selector-tag\">static</span> <span class=\"selector-tag\">void</span> <span class=\"selector-tag\">main</span>(String[] args)&#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">SpringApplication</span><span class=\"selector-class\">.run</span>(Chapter11Application.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行测试工程之后，浏览器输入”<a href=\"http://localhost:8080/test\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/test</a>“测试，测试结果如下:<br><br><a href=\"http://p1.bpimg.com/4851/6ff00c546916cb99.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://p1.bpimg.com/4851/6ff00c546916cb99t.jpg\"></a></p><p><br>新建application.properties配置文件，内容为</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello.<span class=\"attribute\">msg</span>=haha</span><br></pre></td></tr></table></figure>\n<p>重启工程，浏览器输入”<a href=\"http://localhost:8080/test\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/test</a>“测试，测试结果如下:<br><a href=\"http://p1.bpimg.com/4851/fbf8797b19bd1733.png\" title=\"点击显示原始图片\" target=\"_blank\" rel=\"noopener\"><img src=\"http://p1.bpimg.com/4851/fbf8797b19bd1733t.jpg\"></a></p><p></p>\n","slug":"Spring-Boot核心","updated":"2018-05-12T16:03:18.000Z","comments":true,"link":"","permalink":"/2016/12/18/Spring-Boot核心/","excerpt":"一、Spring Boot基本配置 1、入口类和@SpringBootApplicationSpring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/tags/SpringBoot/"}]},{"title":"jdk各版本区别","date":"2016-12-17T16:06:43.000Z","path":"2016/12/18/jdk各版本区别/","text":"jdk5新特性1、自动装箱和拆箱2、枚举3、静态导入4、可变参数5、內省 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。 一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 6、泛型7、For-Each循环jdk6新特性1、Desktop类和SystemTray类 AWT新增加了两个雷：Desktop，SystemTray。 Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档 SystemTray可以用来在系统托盘区创建一个托盘程序 2、使用JAXB2来实现对象与XML之间的映射 也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。 3、StAX StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4、使用Compiler API 使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。 5、轻量级Http Server API6、插入式注解处理API7、用Console开发控制台程序8、对脚本语言的支持如：ruby，groovy，javascript9、Common Annotationsjdk7新特性1、switch中可以使用字符串2、泛型的自动判断3、自定义自动关闭类（实现AutoCloseable接口）4、新增一些取环境信息的工具方法（System中的方法）5、Boolean类型反转，空指针安全，参数与位运算6、两个char间的equals7、安全的加减乘除1、对Java集合（Collections）的增强支持12345List&lt;String&gt; list=[\"item\"]; //向List集合中添加元素String item=list[0]; //从List集合中获取元素Set&lt;String&gt; set=&#123;\"item\"&#125;; //向Set集合对象中添加元Map&lt;String,Integer&gt; map=&#123;\"key\":1&#125;; //向Map集合中添加对象int value=map[\"key\"]; //从Map集合中获取对象 但是经过自己测试，按照上面的使用方法，并不能创建集合。 2、int支持二进制数据3、在try catch异常捕捉中，一个catch可以写多个异常类型1234567Connection conn = null;try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"\",\"\",\"\");&#125; catch(ClassNotFoundException|SQLException ex) &#123; ex.printStackTrace();&#125; 4、try catch中资源定义好之后try catch自动关闭12345678910try (BufferedReader in = new BufferedReader(new FileReader(\"in.txt\")); BufferedWriter out = new BufferedWriter(new FileWriter(\"out.txt\"))) &#123; int charRead; while ((charRead = in.read()) != -1) &#123; System.out.printf(\"%c \", (char)charRead); out.write(charRead); &#125;&#125; catch (IOException ex) &#123; ex.printStackTrace();&#125; jdk8新特性1、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下： 123456public interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678 Formula formula = new Formula() &#123;@Overridepublic double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常 2、Lambda表达式1234567List&lt;String&gt; names = Arrays.asList(\"tom\",\"jace\",\"mike\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125;&#125;); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。在Java 8中提供了更简洁的语法，lambda表达式： 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 还可以更简洁： 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 去掉大括号以及return关键字 1Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。 3、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@FunctionalInterface注解标注的接口只能有一个抽象方法。例如： 1234567@FunctionalInterfacepublic interface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); 以上代码不需要@FunctionalInterface注解也是正确的。 4、方法与构造函数引用上面的代码也可以通过静态方法引用来表示： 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 12345678910public class Person &#123; String firstName; String lastName; Person() &#123; &#125; public Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 指定一个用来创建Person对象的对象工厂接口： 123public interface PersonFactory&lt;P extends Person&gt; &#123; P create(String fisrtName, String lastName);&#125; 创建Person对象 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(\"Peter\",\"Parker”); 我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5、Lambda作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6、访问局部变量我们可以直接在lambda表达式中访问外层的局部变量 123final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。 7、访问对象字段与静态变量和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： 123456789101112static int outerStaticNum;int outerNum;public void testScopes() &#123; Converter stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;;&#125; 8、访问接口的默认方法9、Date API10、Annotation注解","raw":"---\nlayout: post\ntitle: jdk各版本区别\ndate: 2016-12-18 00:06:43\ntags: jdk版本\ncategories: Java基础\ntoc: true\ndescription: \n\t自从1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0）以来，到现在jdk的版本已经更新到1.8了，1.9也即将出现。本文将介绍jdk1.5到1.8各版本的特性。\n\n---\n# jdk5新特性\n### 1、自动装箱和拆箱\n### 2、枚举\n### 3、静态导入\n### 4、可变参数\n### 5、內省\n   内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。<!--more-->Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br>\n   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。\n### 6、泛型\n### 7、For-Each循环\n\n## jdk6新特性\n### 1、Desktop类和SystemTray类\n   AWT新增加了两个雷：Desktop，SystemTray。<p>\n   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档<p>\n   SystemTray可以用来在系统托盘区创建一个托盘程序\n### 2、使用JAXB2来实现对象与XML之间的映射\n   也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。\n### 3、StAX\n   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； <p>\n   SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。\n### 4、使用Compiler API\n   使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。\n### 5、轻量级Http Server API\n### 6、插入式注解处理API\n### 7、用Console开发控制台程序\n### 8、对脚本语言的支持如：ruby，groovy，javascript\n### 9、Common Annotations\n\n## jdk7新特性\n### 1、switch中可以使用字符串\n### 2、泛型的自动判断\n### 3、自定义自动关闭类（实现AutoCloseable接口）\n### 4、新增一些取环境信息的工具方法（System中的方法）\n### 5、Boolean类型反转，空指针安全，参数与位运算\n### 6、两个char间的equals\n### 7、安全的加减乘除\n\n### 1、对Java集合（Collections）的增强支持\n\n```\n\tList<String> list=[\"item\"]; //向List集合中添加元素\n\tString item=list[0]; //从List集合中获取元素\n\tSet<String> set={\"item\"}; //向Set集合对象中添加元\n\tMap<String,Integer> map={\"key\":1}; //向Map集合中添加对象\n\tint value=map[\"key\"]; //从Map集合中获取对象\n```\n   但是经过自己测试，按照上面的使用方法，并不能创建集合。\n### 2、int支持二进制数据\n### 3、在try catch异常捕捉中，一个catch可以写多个异常类型\n\n```\n\tConnection conn = null;\n\ttry {\n    \tClass.forName(\"com.mysql.jdbc.Driver\");\n    \tconn = DriverManager.getConnection(\"\",\"\",\"\");\n\t} catch(ClassNotFoundException|SQLException ex) {\n    \tex.printStackTrace();\n\t}\n```\n### 4、try catch中资源定义好之后try catch自动关闭\n\n```\n\ttry (BufferedReader in  = new BufferedReader(new \tFileReader(\"in.txt\"));\n     \tBufferedWriter out = new BufferedWriter(new \tFileWriter(\"out.txt\"))) {\n\t\tint charRead;\n\t\twhile ((charRead = in.read()) != -1) {\n        \tSystem.out.printf(\"%c \", (char)charRead);\n        \tout.write(charRead);\n    \t}\n\t} catch (IOException ex) {\n    \tex.printStackTrace();\n\t}\n```\n## jdk8新特性\n### 1、接口的默认方法\nJava 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：\n\n```\n\tpublic interface Formula {\n    \tdouble calculate(int a);\n    \tdefault double sqrt(int a) {\n\t\t\treturn Math.sqrt(a);\n    \t}\n\t}\n```\nFormula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。\n\n```\n    Formula formula = new Formula() {\n\t\t@Override\n\t\tpublic double calculate(int a) {\n\t\t\treturn sqrt(a * 100);\n        }\n    };\n    System.out.println(formula.calculate(100));  // 100.0\n    System.out.println(formula.sqrt(16));  // 4.0\n```\n文中的formula被实现为一个匿名类的实例，该代码非常\n### 2、Lambda表达式\n\n```\n\tList<String> names = Arrays.asList(\"tom\",\"jace\",\"mike\");\n\tCollections.sort(names, new Comparator<String>() {\n\t\t@Override\n\t\tpublic int compare(String o1, String o2) {\n\t\t\treturn o2.compareTo(o1);\n    \t}\n\t});\n```\n只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。\n在Java 8中提供了更简洁的语法，lambda表达式：\n\n```\n\tCollections.sort(names, (String a, String b) -> {\n\t\treturn b.compareTo(a);\n\t});\n```\n还可以更简洁：\n\n```\n\tCollections.sort(names, (String a, String b) -> b.compareTo(a));\n```\n去掉大括号以及return关键字\n\n```\n\tCollections.sort(names, (a,b) -> b.compareTo(a));\n```\nJava编译器可以自动推导出参数类型，所以可以不用再写一次类型。\n### 3、函数式接口\nLambda表达式是如何在java的类型系统中表示的呢？<p>\n每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。<p>\n我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加**@FunctionalInterface**注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说**@FunctionalInterface**注解标注的接口只能有一个抽象方法。<p>\n例如：\n\n```\n\t@FunctionalInterface\n\tpublic interface Converter<F, T> {\n\t\tT convert(F from);\n\t}\n\tConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\n\tInteger converted = converter.convert(\"123\");\n\tSystem.out.println(converted);\n```\n以上代码不需要@FunctionalInterface注解也是正确的。\n### 4、方法与构造函数引用\n上面的代码也可以通过静态方法引用来表示：\n\n```\n\tConverter<String, Integer> converter = Integer::valueOf;\n\tInteger converted = converter.convert(\"123\");\n\tSystem.out.println(converted);\n```\nJava8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：\n\n```\n\tpublic class Person {\n    \tString firstName;\n\t    String lastName;\n    \tPerson() {\n    \t}\n\t\tpublic Person(String firstName, String lastName) {\n\t\t\tthis.firstName = firstName;\n\t\t\tthis.lastName = lastName;\n\t    }\n\t}\n```\n指定一个用来创建Person对象的对象工厂接口：\n\n```\n\tpublic interface PersonFactory<P extends Person> {\n\t\tP create(String fisrtName, String lastName);\n\t}\n```\n创建Person对象\n\n```\n\tPersonFactory<Person> personFactory = Person::new;\n\tPerson person = personFactory.create(\"Peter\",\"Parker”);\n```\n我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。\n### 5、Lambda作用域\n在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。\n### 6、访问局部变量\n我们可以直接在lambda表达式中访问外层的局部变量\n\n```\n\tfinal int num = 1;\n\tConverter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);\n\tstringConverter.convert(2);\n```\n但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。\n### 7、访问对象字段与静态变量\n和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：\n\n```\n\tstatic int outerStaticNum;\n\tint outerNum;\n\tpublic void testScopes() {\n    \tConverter stringConverter1 = (from) -> {\n        \touterNum = 23;\n        \treturn String.valueOf(from);\n    \t};\n\t    Converter stringConverter2 = (from) -> {\n    \t    outerStaticNum = 72;\n        \treturn String.valueOf(from);\n    \t};\n\t}\n```\n### 8、访问接口的默认方法\n### 9、Date API\n### 10、Annotation注解\n","content":"<h1 id=\"jdk5新特性\"><a href=\"#jdk5新特性\" class=\"headerlink\" title=\"jdk5新特性\"></a>jdk5新特性</h1><h3 id=\"1、自动装箱和拆箱\"><a href=\"#1、自动装箱和拆箱\" class=\"headerlink\" title=\"1、自动装箱和拆箱\"></a>1、自动装箱和拆箱</h3><h3 id=\"2、枚举\"><a href=\"#2、枚举\" class=\"headerlink\" title=\"2、枚举\"></a>2、枚举</h3><h3 id=\"3、静态导入\"><a href=\"#3、静态导入\" class=\"headerlink\" title=\"3、静态导入\"></a>3、静态导入</h3><h3 id=\"4、可变参数\"><a href=\"#4、可变参数\" class=\"headerlink\" title=\"4、可变参数\"></a>4、可变参数</h3><h3 id=\"5、內省\"><a href=\"#5、內省\" class=\"headerlink\" title=\"5、內省\"></a>5、內省</h3><p>   内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。<a id=\"more\"></a>Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br><br>   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。</p>\n<h3 id=\"6、泛型\"><a href=\"#6、泛型\" class=\"headerlink\" title=\"6、泛型\"></a>6、泛型</h3><h3 id=\"7、For-Each循环\"><a href=\"#7、For-Each循环\" class=\"headerlink\" title=\"7、For-Each循环\"></a>7、For-Each循环</h3><h2 id=\"jdk6新特性\"><a href=\"#jdk6新特性\" class=\"headerlink\" title=\"jdk6新特性\"></a>jdk6新特性</h2><h3 id=\"1、Desktop类和SystemTray类\"><a href=\"#1、Desktop类和SystemTray类\" class=\"headerlink\" title=\"1、Desktop类和SystemTray类\"></a>1、Desktop类和SystemTray类</h3><p>   AWT新增加了两个雷：Desktop，SystemTray。</p><p><br>   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档</p><p><br>   SystemTray可以用来在系统托盘区创建一个托盘程序</p>\n<h3 id=\"2、使用JAXB2来实现对象与XML之间的映射\"><a href=\"#2、使用JAXB2来实现对象与XML之间的映射\" class=\"headerlink\" title=\"2、使用JAXB2来实现对象与XML之间的映射\"></a>2、使用JAXB2来实现对象与XML之间的映射</h3><p>   也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。</p>\n<h3 id=\"3、StAX\"><a href=\"#3、StAX\" class=\"headerlink\" title=\"3、StAX\"></a>3、StAX</h3><p>   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p><p><br>   SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>\n<h3 id=\"4、使用Compiler-API\"><a href=\"#4、使用Compiler-API\" class=\"headerlink\" title=\"4、使用Compiler API\"></a>4、使用Compiler API</h3><p>   使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。</p>\n<h3 id=\"5、轻量级Http-Server-API\"><a href=\"#5、轻量级Http-Server-API\" class=\"headerlink\" title=\"5、轻量级Http Server API\"></a>5、轻量级Http Server API</h3><h3 id=\"6、插入式注解处理API\"><a href=\"#6、插入式注解处理API\" class=\"headerlink\" title=\"6、插入式注解处理API\"></a>6、插入式注解处理API</h3><h3 id=\"7、用Console开发控制台程序\"><a href=\"#7、用Console开发控制台程序\" class=\"headerlink\" title=\"7、用Console开发控制台程序\"></a>7、用Console开发控制台程序</h3><h3 id=\"8、对脚本语言的支持如：ruby，groovy，javascript\"><a href=\"#8、对脚本语言的支持如：ruby，groovy，javascript\" class=\"headerlink\" title=\"8、对脚本语言的支持如：ruby，groovy，javascript\"></a>8、对脚本语言的支持如：ruby，groovy，javascript</h3><h3 id=\"9、Common-Annotations\"><a href=\"#9、Common-Annotations\" class=\"headerlink\" title=\"9、Common Annotations\"></a>9、Common Annotations</h3><h2 id=\"jdk7新特性\"><a href=\"#jdk7新特性\" class=\"headerlink\" title=\"jdk7新特性\"></a>jdk7新特性</h2><h3 id=\"1、switch中可以使用字符串\"><a href=\"#1、switch中可以使用字符串\" class=\"headerlink\" title=\"1、switch中可以使用字符串\"></a>1、switch中可以使用字符串</h3><h3 id=\"2、泛型的自动判断\"><a href=\"#2、泛型的自动判断\" class=\"headerlink\" title=\"2、泛型的自动判断\"></a>2、泛型的自动判断</h3><h3 id=\"3、自定义自动关闭类（实现AutoCloseable接口）\"><a href=\"#3、自定义自动关闭类（实现AutoCloseable接口）\" class=\"headerlink\" title=\"3、自定义自动关闭类（实现AutoCloseable接口）\"></a>3、自定义自动关闭类（实现AutoCloseable接口）</h3><h3 id=\"4、新增一些取环境信息的工具方法（System中的方法）\"><a href=\"#4、新增一些取环境信息的工具方法（System中的方法）\" class=\"headerlink\" title=\"4、新增一些取环境信息的工具方法（System中的方法）\"></a>4、新增一些取环境信息的工具方法（System中的方法）</h3><h3 id=\"5、Boolean类型反转，空指针安全，参数与位运算\"><a href=\"#5、Boolean类型反转，空指针安全，参数与位运算\" class=\"headerlink\" title=\"5、Boolean类型反转，空指针安全，参数与位运算\"></a>5、Boolean类型反转，空指针安全，参数与位运算</h3><h3 id=\"6、两个char间的equals\"><a href=\"#6、两个char间的equals\" class=\"headerlink\" title=\"6、两个char间的equals\"></a>6、两个char间的equals</h3><h3 id=\"7、安全的加减乘除\"><a href=\"#7、安全的加减乘除\" class=\"headerlink\" title=\"7、安全的加减乘除\"></a>7、安全的加减乘除</h3><h3 id=\"1、对Java集合（Collections）的增强支持\"><a href=\"#1、对Java集合（Collections）的增强支持\" class=\"headerlink\" title=\"1、对Java集合（Collections）的增强支持\"></a>1、对Java集合（Collections）的增强支持</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt; list=[<span class=\"string\">\"item\"</span>]; <span class=\"comment\">//向List集合中添加元素</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> item=list[<span class=\"number\">0</span>]; <span class=\"comment\">//从List集合中获取元素</span></span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; <span class=\"keyword\">set</span>=&#123;<span class=\"string\">\"item\"</span>&#125;; <span class=\"comment\">//向Set集合对象中添加元</span></span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>,Integer&gt; map=&#123;<span class=\"string\">\"key\"</span>:<span class=\"number\">1</span>&#125;; <span class=\"comment\">//向Map集合中添加对象</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> value=map[<span class=\"string\">\"key\"</span>]; <span class=\"comment\">//从Map集合中获取对象</span></span><br></pre></td></tr></table></figure>\n<p>   但是经过自己测试，按照上面的使用方法，并不能创建集合。</p>\n<h3 id=\"2、int支持二进制数据\"><a href=\"#2、int支持二进制数据\" class=\"headerlink\" title=\"2、int支持二进制数据\"></a>2、int支持二进制数据</h3><h3 id=\"3、在try-catch异常捕捉中，一个catch可以写多个异常类型\"><a href=\"#3、在try-catch异常捕捉中，一个catch可以写多个异常类型\" class=\"headerlink\" title=\"3、在try catch异常捕捉中，一个catch可以写多个异常类型\"></a>3、在try catch异常捕捉中，一个catch可以写多个异常类型</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">   \tconn = DriverManager.getConnection(<span class=\"string\">\"\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(ClassNotFoundException|SQLException ex) &#123;</span><br><span class=\"line\">   \tex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、try-catch中资源定义好之后try-catch自动关闭\"><a href=\"#4、try-catch中资源定义好之后try-catch自动关闭\" class=\"headerlink\" title=\"4、try catch中资源定义好之后try catch自动关闭\"></a>4、try catch中资源定义好之后try catch自动关闭</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (BufferedReader <span class=\"keyword\">in</span>  = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> \tFileReader(<span class=\"string\">\"in.txt\"</span>));</span><br><span class=\"line\">    \tBufferedWriter <span class=\"keyword\">out</span> = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> \tFileWriter(<span class=\"string\">\"out.txt\"</span>))) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> charRead;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((charRead = <span class=\"keyword\">in</span>.read()) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">       \tSystem.<span class=\"keyword\">out</span>.printf(<span class=\"string\">\"%c \"</span>, (<span class=\"keyword\">char</span>)charRead);</span><br><span class=\"line\">       \t<span class=\"keyword\">out</span>.write(charRead);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">   \tex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"jdk8新特性\"><a href=\"#jdk8新特性\" class=\"headerlink\" title=\"jdk8新特性\"></a>jdk8新特性</h2><h3 id=\"1、接口的默认方法\"><a href=\"#1、接口的默认方法\" class=\"headerlink\" title=\"1、接口的默认方法\"></a>1、接口的默认方法</h3><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public<span class=\"built_in\"> interface </span>Formula &#123;</span><br><span class=\"line\">   \tdouble calculate(int a);</span><br><span class=\"line\">   <span class=\"built_in\">\tdefault </span>double sqrt(int a) &#123;</span><br><span class=\"line\">\t\treturn Math.sqrt(a);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Formula formula = <span class=\"keyword\">new</span> Formula() &#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> calculate(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> <span class=\"built_in\">sqrt</span>(a * <span class=\"number\">100</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  System.out.<span class=\"built_in\">println</span>(formula.calculate(<span class=\"number\">100</span>));  <span class=\"comment\">// 100.0</span></span><br><span class=\"line\">  System.out.<span class=\"built_in\">println</span>(formula.<span class=\"built_in\">sqrt</span>(<span class=\"number\">16</span>));  <span class=\"comment\">// 4.0</span></span><br></pre></td></tr></table></figure>\n<p>文中的formula被实现为一个匿名类的实例，该代码非常</p>\n<h3 id=\"2、Lambda表达式\"><a href=\"#2、Lambda表达式\" class=\"headerlink\" title=\"2、Lambda表达式\"></a>2、Lambda表达式</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt; names = Arrays.asList(<span class=\"string\">\"tom\"</span>,<span class=\"string\">\"jace\"</span>,<span class=\"string\">\"mike\"</span>);</span><br><span class=\"line\">Collections.sort(names, <span class=\"keyword\">new</span> Comparator&lt;<span class=\"built_in\">String</span>&gt;() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\tpublic <span class=\"built_in\">int</span> compare(<span class=\"built_in\">String</span> o1, <span class=\"built_in\">String</span> o2) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o2.compareTo(o1);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。<br>在Java 8中提供了更简洁的语法，lambda表达式：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort<span class=\"function\"><span class=\"params\">(names, (String a, String b) -&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">return</span> b.compareTo(a);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;)</span>;</span></span><br></pre></td></tr></table></figure>\n<p>还可以更简洁：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort<span class=\"function\"><span class=\"params\">(names, (String a, String b) -&gt; b.compareTo(a))</span>;</span></span><br></pre></td></tr></table></figure>\n<p>去掉大括号以及return关键字</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort<span class=\"function\"><span class=\"params\">(names, (a,b) -&gt; b.compareTo(a))</span>;</span></span><br></pre></td></tr></table></figure>\n<p>Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。</p>\n<h3 id=\"3、函数式接口\"><a href=\"#3、函数式接口\" class=\"headerlink\" title=\"3、函数式接口\"></a>3、函数式接口</h3><p>Lambda表达式是如何在java的类型系统中表示的呢？</p><p><br>每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。</p><p><br>我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加<strong>@FunctionalInterface</strong>注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说<strong>@FunctionalInterface</strong>注解标注的接口只能有一个抽象方法。</p><p><br>例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> Converter&lt;F, T&gt; &#123;</span><br><span class=\"line\">\tT convert(F <span class=\"keyword\">from</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Converter&lt;<span class=\"built_in\">String</span>, Integer&gt; converter = (<span class=\"keyword\">from</span>) -&gt; Integer.valueOf(<span class=\"keyword\">from</span>);</span><br><span class=\"line\">Integer converted = converter.convert(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">System.out.println(converted);</span><br></pre></td></tr></table></figure>\n<p>以上代码不需要@FunctionalInterface注解也是正确的。</p>\n<h3 id=\"4、方法与构造函数引用\"><a href=\"#4、方法与构造函数引用\" class=\"headerlink\" title=\"4、方法与构造函数引用\"></a>4、方法与构造函数引用</h3><p>上面的代码也可以通过静态方法引用来表示：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Converter&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Integer</span>&gt; converter = <span class=\"built_in\">Integer</span><span class=\"type\">::valueOf</span>;</span><br><span class=\"line\"><span class=\"built_in\">Integer</span> converted = converter.convert(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">System.out.println(converted);</span><br></pre></td></tr></table></figure>\n<p>Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">String</span> firstName;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> lastName;</span><br><span class=\"line\">   \tPerson() &#123;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Person(<span class=\"keyword\">String</span> firstName, <span class=\"keyword\">String</span> lastName) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.firstName = firstName;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.lastName = lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指定一个用来创建Person对象的对象工厂接口：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public<span class=\"built_in\"> interface </span>PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class=\"line\">\tP create(String fisrtName, String lastName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建Person对象</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonFactory&lt;<span class=\"keyword\">Person</span>&gt; personFactory = <span class=\"keyword\">Person</span>::new;</span><br><span class=\"line\"><span class=\"keyword\">Person</span> <span class=\"keyword\">person</span> = personFactory.create(<span class=\"string\">\"Peter\"</span>,<span class=\"string\">\"Parker”);</span></span><br></pre></td></tr></table></figure>\n<p>我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>\n<h3 id=\"5、Lambda作用域\"><a href=\"#5、Lambda作用域\" class=\"headerlink\" title=\"5、Lambda作用域\"></a>5、Lambda作用域</h3><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>\n<h3 id=\"6、访问局部变量\"><a href=\"#6、访问局部变量\" class=\"headerlink\" title=\"6、访问局部变量\"></a>6、访问局部变量</h3><p>我们可以直接在lambda表达式中访问外层的局部变量</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"built_in\">int</span> <span class=\"built_in\">num</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">Converter&lt;Integer, <span class=\"built_in\">String</span>&gt; stringConverter = (from) -&gt; <span class=\"built_in\">String</span>.valueOf(from + <span class=\"built_in\">num</span>);</span><br><span class=\"line\">stringConverter.convert(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。</p>\n<h3 id=\"7、访问对象字段与静态变量\"><a href=\"#7、访问对象字段与静态变量\" class=\"headerlink\" title=\"7、访问对象字段与静态变量\"></a>7、访问对象字段与静态变量</h3><p>和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int outerStaticNum;</span><br><span class=\"line\">int outerNum;</span><br><span class=\"line\">public <span class=\"literal\">void</span> testScopes() &#123;</span><br><span class=\"line\">   \tConverter <span class=\"function\"><span class=\"title\">stringConverter1</span> = <span class=\"params\">(<span class=\"keyword\">from</span>)</span> -&gt;</span> &#123;</span><br><span class=\"line\">       \touterNum = <span class=\"number\">23</span>;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> String.valueOf(<span class=\"keyword\">from</span>);</span><br><span class=\"line\">   \t&#125;;</span><br><span class=\"line\">    Converter <span class=\"function\"><span class=\"title\">stringConverter2</span> = <span class=\"params\">(<span class=\"keyword\">from</span>)</span> -&gt;</span> &#123;</span><br><span class=\"line\">   \t    outerStaticNum = <span class=\"number\">72</span>;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> String.valueOf(<span class=\"keyword\">from</span>);</span><br><span class=\"line\">   \t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8、访问接口的默认方法\"><a href=\"#8、访问接口的默认方法\" class=\"headerlink\" title=\"8、访问接口的默认方法\"></a>8、访问接口的默认方法</h3><h3 id=\"9、Date-API\"><a href=\"#9、Date-API\" class=\"headerlink\" title=\"9、Date API\"></a>9、Date API</h3><h3 id=\"10、Annotation注解\"><a href=\"#10、Annotation注解\" class=\"headerlink\" title=\"10、Annotation注解\"></a>10、Annotation注解</h3>","slug":"jdk各版本区别","updated":"2016-12-22T14:24:34.000Z","comments":true,"link":"","permalink":"/2016/12/18/jdk各版本区别/","excerpt":"jdk5新特性1、自动装箱和拆箱2、枚举3、静态导入4、可变参数5、內省 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}],"tags":[{"name":"jdk版本","slug":"jdk版本","permalink":"/tags/jdk版本/"}]},{"title":"Spring Boot入门","date":"2016-12-13T15:18:29.000Z","path":"2016/12/13/Spring-Boot入门/","text":"一、Spring Boot简介 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。 Spring Boot有以下几个优点： 1、 没有代码生成，不需要XML配置文件 2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器 3、 可以独立运行Spring应用程序 4、 提供了Maven，Gradle两种方法搭建Spring Boot工程 5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合） 6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查 二、Spring Boot入门工程搭建：1、采用Spring官网提供的SPRING INITIALIZR进行搭建。可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。 2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）1、新建一个Maven的web工程2、在pom.xml文件中添加Spring Boot的相关依赖添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 然后在dependencies中添加Web支持的starter pom。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web会自动添加它所依赖的jar包 然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程 1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt;&lt;/plugin&gt; 3、简单测试新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法 123456@SpringBootApplicationpublic class Chapter01Application &#123; public static void main(String[] args)&#123; SpringApplication.run(Chapter01Application.class, args); &#125;&#125; 注：@SpringBootApplication是一个组合注解，查看其源码，@SpringBootApplication组合了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解，@SpringBootConfiguration表示当前类是一个启动应用程序的入口；@EnableAutoConfiguration注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了@Component注解的类。 然后新建目录controller，在其中新建一个HelloController测试类。 1234567@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index() &#123; return \"Hello, World!\"; &#125;&#125; @RestController也是一个组合注解，组合了@Controller，@ResponseBody两个注解 4、运行使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问http://localhost:8080/hello即可访问HelloController。","raw":"---\ntitle: Spring Boot入门\ndate: 2016-12-13 23:18:29\ntoc: true\ncategories: SpringBoot\ntags: SpringBoot\ndescrpition: \n---\n# 一、Spring Boot简介\n\n   ***Spring Boot***是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<!--more-->\n    <p>Spring Boot有以下几个优点：<br>\n    1、 没有代码生成，不需要XML配置文件<br>\n    2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br>\n    3、 可以独立运行Spring应用程序<br>\n    4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br>\n    5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br>\n    6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br>\n\n# 二、Spring Boot入门工程搭建：\n\n##  1、采用Spring官网提供的[SPRING INITIALIZR](https://start.spring.io/)进行搭建。\n可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。\n##    2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）\n###   1、新建一个Maven的web工程\n###   2、在pom.xml文件中添加Spring Boot的相关依赖\n添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。\n\n```xml\n\t<parent>\n    \t<groupId>org.springframework.boot</groupId>\n    \t<artifactId>spring-boot-starter-parent</artifactId>\n    \t<version>1.4.0.RELEASE</version>\n    \t<relativePath/>\n\t</parent>\n```\n添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。\n\n```xml\n\t<dependency>\n    \t<groupId>org.springframework.boot</groupId>\n    \t<artifactId>spring-boot-starter</artifactId>\n\t</dependency>\n```\n然后在dependencies中添加Web支持的starter pom。\n\n```xml\n\t<dependency>\n    \t<groupId>org.springframework.boot</groupId>\n    \t<artifactId>spring-boot-starter-web</artifactId>\n\t</dependency>\n```\nspring-boot-starter-web会自动添加它所依赖的jar包\n\n然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程\n\n```xml\n\t<plugin>\n    \t<groupId>org.springframework.boot</groupId>\n    \t<artifactId>spring-boot-maven-plugin</artifactId>\n    \t<configuration>\n        \t<fork>true</fork>\n\t    </configuration>\n\t</plugin>\n```\n### 3、简单测试\n新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法\n\n```java\n\t@SpringBootApplication\n\tpublic class Chapter01Application {\n    \tpublic static void main(String[] args){\n\t    \tSpringApplication.run(Chapter01Application.class, args);\n    \t}\n\t}\n```\n***注***：\n**@SpringBootApplication**是一个组合注解，查看其源码，**@SpringBootApplication**\n组合了**@SpringBootConfiguration**，**@EnableAutoConfiguration**，**@ComponentScan**三个注解，**@SpringBootConfiguration**表示当前类是一个启动应用程序的入口；**@EnableAutoConfiguration**注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了**@Component**注解的类。\n\n然后新建目录controller，在其中新建一个HelloController测试类。\n\n```java\n\t@RestController\n\tpublic class HelloController {\n    \t@RequestMapping(\"/hello\")\n    \tpublic String index() {\n        \treturn \"Hello, World!\";\n        }\n\t}\n```\n**@RestController**也是一个组合注解，组合了**@Controller**，**@ResponseBody**两个注解\n\n\n### 4、运行\n使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问[http://localhost:8080/hello](http://localhost:8080/hello)即可访问HelloController。","content":"<h1 id=\"一、Spring-Boot简介\"><a href=\"#一、Spring-Boot简介\" class=\"headerlink\" title=\"一、Spring Boot简介\"></a>一、Spring Boot简介</h1><p>   <strong><em>Spring Boot</em></strong>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。<a id=\"more\"></a><br>    </p><p>Spring Boot有以下几个优点：<br><br>    1、 没有代码生成，不需要XML配置文件<br><br>    2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器<br><br>    3、 可以独立运行Spring应用程序<br><br>    4、 提供了Maven，Gradle两种方法搭建Spring Boot工程<br><br>    5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合）<br><br>    6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查<br></p>\n<h1 id=\"二、Spring-Boot入门工程搭建：\"><a href=\"#二、Spring-Boot入门工程搭建：\" class=\"headerlink\" title=\"二、Spring Boot入门工程搭建：\"></a>二、Spring Boot入门工程搭建：</h1><h2 id=\"1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。\"><a href=\"#1、采用Spring官网提供的SPRING-INITIALIZR进行搭建。\" class=\"headerlink\" title=\"1、采用Spring官网提供的SPRING INITIALIZR进行搭建。\"></a>1、采用Spring官网提供的<a href=\"https://start.spring.io/\" target=\"_blank\" rel=\"noopener\">SPRING INITIALIZR</a>进行搭建。</h2><p>可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。</p>\n<h2 id=\"2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）\"><a href=\"#2、使用开发工具手动构建Spring-Boot工程（本文采用Intellij-Idea-2016-3）\" class=\"headerlink\" title=\"2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）\"></a>2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）</h2><h3 id=\"1、新建一个Maven的web工程\"><a href=\"#1、新建一个Maven的web工程\" class=\"headerlink\" title=\"1、新建一个Maven的web工程\"></a>1、新建一个Maven的web工程</h3><h3 id=\"2、在pom-xml文件中添加Spring-Boot的相关依赖\"><a href=\"#2、在pom-xml文件中添加Spring-Boot的相关依赖\" class=\"headerlink\" title=\"2、在pom.xml文件中添加Spring Boot的相关依赖\"></a>2、在pom.xml文件中添加Spring Boot的相关依赖</h3><p>添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在dependencies中添加Web支持的starter pom。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>spring-boot-starter-web会自动添加它所依赖的jar包</p>\n<p>然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">       \t<span class=\"tag\">&lt;<span class=\"name\">fork</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">fork</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3、简单测试\"><a href=\"#3、简单测试\" class=\"headerlink\" title=\"3、简单测试\"></a>3、简单测试</h3><p>新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chapter01Application</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    \tSpringApplication.run(Chapter01Application.class, args);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>注</em></strong>：<br><strong>@SpringBootApplication</strong>是一个组合注解，查看其源码，<strong>@SpringBootApplication</strong><br>组合了<strong>@SpringBootConfiguration</strong>，<strong>@EnableAutoConfiguration</strong>，<strong>@ComponentScan</strong>三个注解，<strong>@SpringBootConfiguration</strong>表示当前类是一个启动应用程序的入口；<strong>@EnableAutoConfiguration</strong>注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了<strong>@Component</strong>注解的类。</p>\n<p>然后新建目录controller，在其中新建一个HelloController测试类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"string\">\"Hello, World!\"</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@RestController</strong>也是一个组合注解，组合了<strong>@Controller</strong>，<strong>@ResponseBody</strong>两个注解</p>\n<h3 id=\"4、运行\"><a href=\"#4、运行\" class=\"headerlink\" title=\"4、运行\"></a>4、运行</h3><p>使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问<a href=\"http://localhost:8080/hello\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/hello</a>即可访问HelloController。</p>\n","slug":"Spring-Boot入门","updated":"2018-05-12T16:03:33.000Z","comments":true,"link":"","permalink":"/2016/12/13/Spring-Boot入门/","excerpt":"一、Spring Boot简介 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/tags/SpringBoot/"}]}]}