[{"title":"jdk各版本区别","date":"2016-12-17T16:06:43.000Z","path":"jdk各版本区别.html","text":"jdk5新特性1、自动装箱和拆箱2、枚举3、静态导入4、可变参数5、內省 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。 一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 6、泛型7、For-Each循环jdk6新特性1、Desktop类和SystemTray类 AWT新增加了两个雷：Desktop，SystemTray。 Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档 SystemTray可以用来在系统托盘区创建一个托盘程序 2、使用JAXB2来实现对象与XML之间的映射 也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。 3、StAX StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4、使用Compiler API 使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。 5、轻量级Http Server API6、插入式注解处理API7、用Console开发控制台程序8、对脚本语言的支持如：ruby，groovy，javascript9、Common Annotationsjdk7新特性1、switch中可以使用字符串2、泛型的自动判断3、自定义自动关闭类（实现AutoCloseable接口）4、新增一些取环境信息的工具方法（System中的方法）5、Boolean类型反转，空指针安全，参数与位运算6、两个char间的equals7、安全的加减乘除1、对Java集合（Collections）的增强支持List&lt;String&gt; list=[&quot;item&quot;]; //向List集合中添加元素 String item=list[0]; //从List集合中获取元素 Set&lt;String&gt; set={&quot;item&quot;}; //向Set集合对象中添加元 Map&lt;String,Integer&gt; map={&quot;key&quot;:1}; //向Map集合中添加对象 int value=map[&quot;key&quot;]; //从Map集合中获取对象 但是经过自己测试，按照上面的使用方法，并不能创建集合。 2、int支持二进制数据3、在try catch异常捕捉中，一个catch可以写多个异常类型Connection conn = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); } catch(ClassNotFoundException|SQLException ex) { ex.printStackTrace(); } 4、try catch中资源定义好之后try catch自动关闭try (BufferedReader in = new BufferedReader(new FileReader(&quot;in.txt&quot;)); BufferedWriter out = new BufferedWriter(new FileWriter(&quot;out.txt&quot;))) { int charRead; while ((charRead = in.read()) != -1) { System.out.printf(&quot;%c &quot;, (char)charRead); out.write(charRead); } } catch (IOException ex) { ex.printStackTrace(); } jdk8新特性1、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下： public interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常 2、Lambda表达式List&lt;String&gt; names = Arrays.asList(&quot;tom&quot;,&quot;jace&quot;,&quot;mike&quot;); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.compareTo(o1); } }); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。在Java 8中提供了更简洁的语法，lambda表达式： Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); }); 还可以更简洁： Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 去掉大括号以及return关键字 Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。 3、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@FunctionalInterface注解标注的接口只能有一个抽象方法。例如： @FunctionalInterface public interface Converter&lt;F, T&gt; { T convert(F from); } Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); 以上代码不需要@FunctionalInterface注解也是正确的。 4、方法与构造函数引用上面的代码也可以通过静态方法引用来表示： Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： public class Person { String firstName; String lastName; Person() { } public Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 指定一个用来创建Person对象的对象工厂接口： public interface PersonFactory&lt;P extends Person&gt; { P create(String fisrtName, String lastName); } 创建Person对象 PersonFactory&lt;Person&gt; personFactory = Person::new; Person person = personFactory.create(&quot;Peter&quot;,&quot;Parker”); 我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5、Lambda作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6、访问局部变量我们可以直接在lambda表达式中访问外层的局部变量 final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。 7、访问对象字段与静态变量和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： static int outerStaticNum; int outerNum; public void testScopes() { Converter stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); }; Converter stringConverter2 = (from) -&gt; { outerStaticNum = 72; return String.valueOf(from); }; } 8、访问接口的默认方法9、Date API10、Annotation注解","permalink":"/jdk各版本区别.html","tags":[{"name":"jdk版本","slug":"jdk版本","permalink":"/tags/jdk版本/"}]},{"title":"Spring Boot入门","date":"2016-12-13T15:18:29.000Z","path":"Spring-Boot入门.html","text":"Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。 Spring Boot有以下几个优点： 1、 没有代码生成，不需要XML配置文件 2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器 3、 可以独立运行Spring应用程序 4、 提供了Maven，Gradle两种方法搭建Spring Boot工程 5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合） 6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查 ##Spring Boot入门工程搭建： 一、采用Spring官网提供的SPRING INITIALIZR进行搭建。 可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。 二、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3） 1、新建一个Maven的web工程 2、在pom.xml文件中添加Spring Boot的相关依赖 添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 然后在dependencies中添加Web支持的starter pom。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; spring-boot-starter-web会自动添加它所依赖的jar包 然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 3、简单测试 新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法 @SpringBootApplication public class Chapter01Application { public static void main(String[] args){ SpringApplication.run(Chapter01Application.class, args); } } 注：@SpringBootApplication是一个组合注解，查看其源码，@SpringBootApplication组合了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解，@SpringBootConfiguration表示当前类是一个启动应用程序的入口；@EnableAutoConfiguration注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了@Component注解的类。 然后新建目录controller，在其中新建一个HelloController测试类。 @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String index() { return &quot;Hello, World!&quot;; } } @RestController也是一个组合注解，组合了@Controller，@ResponseBody两个注解 4、运行 使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问http://localhost:8080/hello即可访问HelloController，访问结果如下：","permalink":"/Spring-Boot入门.html","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/tags/Spring-Boot/"}]}]