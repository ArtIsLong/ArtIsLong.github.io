[{"title":"SpringBoot动态数据源切换","date":"2017-06-01T13:30:56.000Z","path":"2017/06/01/SpringBoot动态数据源切换/","text":"最近项目中需要配置两个数据源，并且在不同的包下动态切换，为此，博主费劲九牛二虎之力百度了一天多，参考网上动态切换数据源的博客，实现了满足项目的数据源动态切换功能。 1、Spring的开发者还是挺有先见之明的，为我们提供了扩展Spring的AbstractRoutingDataSource抽象类，我们来看它的源码 1234567891011121314151617181920212223242526272829 /** * Retrieve the current target DataSource. Determines the * &#123;@link #determineCurrentLookupKey() current lookup key&#125;, performs * a lookup in the &#123;@link #setTargetDataSources targetDataSources&#125; map, * falls back to the specified * &#123;@link #setDefaultTargetDataSource default target DataSource&#125; if necessary. * @see #determineCurrentLookupKey() */protected DataSource determineTargetDataSource() &#123; Assert.notNull(this.resolvedDataSources, \"DataSource router not initialized\"); Object lookupKey = determineCurrentLookupKey(); DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123; dataSource = this.resolvedDefaultDataSource; &#125; if (dataSource == null) &#123; throw new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\"); &#125; return dataSource;&#125;/** * Determine the current lookup key. This will typically be * implemented to check a thread-bound transaction context. * &lt;p&gt;Allows for arbitrary keys. The returned key needs * to match the stored lookup key type, as resolved by the * &#123;@link #resolveSpecifiedLookupKey&#125; method. */protected abstract Object determineCurrentLookupKey(); 源码注释解释的很清楚，determineTargetDataSource 方法通过数据源的标识获取当前数据源；determineCurrentLookupKey方法则是获取数据源标识。（作为英语彩笔，有道词典这种翻译软件还是特别好使的） 所以，我们实现动态切换数据源，需要实现determineCurrentLookupKey方法，动态提供数据源标识即可。 2、自定义DynamicDataSource类，继承AbstractRoutingDataSource，并实现determineCurrentLookupKey方法。 123456789101112public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; /** * DynamicDataSourceContextHolder代码中使用setDataSource * 设置当前的数据源，在路由类中使用getDataSource进行获取， * 交给AbstractRoutingDataSource进行注入使用。 */ return DynamicDataSourceContextHolder.getDataSource(); &#125;&#125; 3、创建统一数据源管理类DynamicDataSourceContextHolder 12345678910111213141516171819202122public class DynamicDataSourceContextHolder &#123; // 线程本地环境 private static final ThreadLocal&lt;String&gt; dataSources = new ThreadLocal&lt;String&gt;(); // 管理所有的数据源Id public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;String&gt;(); public static void setDataSource(String dataSource) &#123; dataSources.set(dataSource); &#125; public static String getDataSource() &#123; return dataSources.get(); &#125; public static void clearDataSource() &#123; dataSources.remove(); &#125; // 判断指定的DataSource当前是否存在 public static boolean containsDataSource(String dataSourceId) &#123; return dataSourceIds.contains(dataSourceId); &#125;&#125; 4、重点来了，创建动态数据源注册器DynamicDataSourceRegister 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; // 默认数据连接池 public static final Object DATASOURCE_TYPE_DEFAULT = \"org.apache.tomcat.jdbc.pool.DataSource\"; private Class&lt;? extends DataSource&gt; dataSourceType; // 默认数据源 private DataSource defaultDataSource; private Map&lt;String, DataSource&gt; dataSourceMaps = new HashMap&lt;String, DataSource&gt;(); /** * 加载多数据源配置 * @param environment */ @Override public void setEnvironment(Environment environment) &#123; initDefaultDataSource(environment); &#125; /** * 初始化默认数据源 * @param environment */ private void initDefaultDataSource(Environment environment) &#123; RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(environment, \"spring.datasource.\"); try &#123; if(propertyResolver.getProperty(\"type\") == null) &#123; dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(DATASOURCE_TYPE_DEFAULT.toString()); &#125; else &#123; dataSourceType = (Class&lt;? extends DataSource&gt;)Class.forName(propertyResolver.getProperty(\"type\")); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 创建数据源 String jndiName = propertyResolver.getProperty(\"jndi-name\"); String[] jndiNames = jndiName.split(\",\"); defaultDataSource = new JndiDataSourceLookup().getDataSource(jndiNames[0]); dataSourceMaps.put(\"AAA\", defaultDataSource); DataSource dataSource1 = new JndiDataSourceLookup().getDataSource(jndiNames[1]); dataSourceMaps.put(\"BBB\", dataSource1); &#125; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; Map&lt;String, Object&gt; targetDataSources = new HashMap&lt;String, Object&gt;(); // 将主数据源添加到更多数据源中 targetDataSources.put(\"dataSource\", defaultDataSource); DynamicDataSourceContextHolder.dataSourceIds.add(\"dataSource\"); // 添加更多数据源 targetDataSources.putAll(dataSourceMaps); for(String key : dataSourceMaps.keySet()) &#123; DynamicDataSourceContextHolder.dataSourceIds.add(key); &#125; // 创建DynamicDataSource GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(DynamicDataSource.class); beanDefinition.setSynthetic(true); MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues(); mutablePropertyValues.addPropertyValue(\"defaultTargetDataSource\", defaultDataSource); mutablePropertyValues.addPropertyValue(\"targetDataSources\", targetDataSources); beanDefinitionRegistry.registerBeanDefinition(\"dataSource\", beanDefinition); &#125;&#125; 好了，这么一坨代码丢在这儿，相信读者也看着费劲，接下来对动态数据源注册器略作解释 &gt; EnvironmentAware接口提供了一个setEnvironment(Environment environment)方法，通过这个方法我们可以从application.properties配置文件中获取到所有数据源的配置信息，然后创建数据源并加载到内存中 &gt; ImportBeanDefinitionRegistrar接口，光看接口名字大概都能猜到是做什么的，对，就是注册Bean的。该接口用于在系统处理@Configuration class时注册更多的bean。是bean定义级别的操作，而非@Bean method/instance级别的。该接口提供了registerBeanDefinitions方法，该方法是在Spring加载bean时被Spring调用。通过setEnvironment方法，已经将配置文件中所有的数据源获取到了，然后在registerBeanDefinitions方法中将所有数据源注册到Spring容器中。 5、将动态数据源注册器导入到Spring容器中 1234567@SpringBootApplication@Import(&#123;DynamicDataSourceRegister.class&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 需要注意的是，使用@Import导入的类必须满足符合以下的某一个条件： 导入的类使用@Configuration进行标注 导入的类中至少有一个使用@Bean标准的方法 导入的类实现了ImportSelector接口 导入的类实现了ImportBeanDefinitionRegistrar接口 到这一步了，是不是就完了呢，当然不是，以上这些步骤只是为切换数据源提供了基础 6、新建一个TargetDataSource注解 123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource &#123; String value();&#125; 此注解用来标记当前的方法的数据源的，在需要指定数据源的方法上标记@TargetDataSource(“AAA”)注解即可，还没完，继续往下看。 7、新建数据源切换AOP切面 123456789101112131415161718192021222324@Aspect@Order(-1) //保证此AOP在@Transactional之前执行@Componentpublic class DynamicDataSourceAspect &#123; private transient static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); // 通过注解切换数据源（细粒度） @Around(\"@annotation(targetDataSource)\") public Object changeDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable &#123; Object object = null; String dataSourceId = targetDataSource.value(); if(DynamicDataSourceContextHolder.containsDataSource(dataSourceId)) &#123; logger.info(\"系统将使用&#123;&#125;数据源\", dataSourceId); DynamicDataSourceContextHolder.setDataSource(dataSourceId); &#125; else &#123; logger.debug(\"数据源&#123;&#125;不存在，将使用默认数据源&#123;&#125;\", dataSourceId, joinPoint.getSignature()); &#125; object=joinPoint.proceed(); DynamicDataSourceContextHolder.clearDataSource(); return object; &#125;&#125; 解释解释，这个切面呢，就是切标记了targetDataSource注解的方法，根据targetDataSource注解的value值设置系统当前的数据源。使用注解方式算是一种细粒度的控制，可切换多个数据源；粗粒度的就是直接切某一个包路径，而且只能是两个数据源互切。两种方式各有各的好处，看业务需要。不过总的来说，能解决问题的方法就是好方法。 最后附一下JNDI数据源在application.properties文件中的配置 1spring.datasource.jndi-name=java:comp/env/jdbc/AAA,java:comp/env/jdbc/BBB 其实，JNDI数据源也可以直接配置到application.properties文件中，或者两种模式都支持，此处不做累述。 ————————————————华丽的分割线—————————————————- 在项目的进展中，此数据源切换已被改造，增加了Druid数据源加密功能，因为是多数据源加密，和官网的有些不一样，代码就不一一累述，读者若有需要，可自行研究或联系博主获取","permalink":"/2017/06/01/SpringBoot动态数据源切换/","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"/tags/SpringBoot/"}]},{"title":"个人简历","date":"2017-02-09T14:38:15.000Z","path":"2017/02/09/个人简历/","text":"个人简历基本信息 姓名：陈敏籍贯：甘肃省平凉市出生年月：1993年3月邮箱：15221499301@139.com联系电话：15221499301博客：http://artislong.github.iogithub：https://github.com/artislong求职意向：Java研发 自我评价 简洁清晰的编程习惯，学习能力强工作主动，执行力及抗压性强热爱开源，喜欢学习各种开源技术 专业技能 熟练掌握Java编程语言，有较扎实的代码功底和Java核心基础；熟悉HTML,CSS,JavaScript,JQuery前端技术掌握Oracle，Mysql两种数据库的使用，熟悉SQL语言，了解Oracle的PL/SQL编程；熟练使用SVN进行团队协作开发，熟悉Rational Rose，PowerDesigner建模工具掌握Spring Boot，并能够熟练使用熟悉Struts2,Hibernate,Spring,SpringMVC,MyBatis熟悉Jbpm工作流框架常规工作流程熟悉memcache，redis缓存服务器，熟悉其常用操作命令及存储机制熟悉Linux常用操作命令 工作经历 2015年11月至2016年5月，进入亚信科技实习，从事新业务工单开发工作2016年6月转正，进入产商品中心项目组，进行产品服务项目以及产品配置化项目的开发 项目经验 项目名称：OA开发环境：window 7，MySQL 5.6，Tomcat7，jdk1.7开发工具：MyEclipse 10项目描述：本项目主旨为实现办公自动化功能，实现了系统管理、网上交流、审批流转等几大功能，系统管理包括部门管理、员工管理、角色管理，其中，角色管理通过拦截请求url的方式实现了权限控制，通过角色来控制对应角色下的用户对系统的操作权限。使用JBPM工作流框架实现审批流转功能，审批流转具有提交请假单、报销单等功能，审批流程由各级审批人员（经理）进行审批处理。使用DWR框架进行消息推送，实现用户登录提醒功能，并将登录用户信息存储到memcached中，用户可以实时查看在线用户人数及在线用户列表。项目职责：设计与开发项目相关技术：Spring，Struts2，Hibernate，JBPM，DWR，JQuery，Ajax，Memcached，以及JQuery相关插件代码地址：https://github.com/artislong/OA收获：通过项目的练习，使我掌握了SSH框架的基本使用方式，项目中的Jstl标签，El表达式的应用，使我明白了Jstl和El在Web项目中的真正作用，并且使我有了较扎实的代码编写能力。通过拦截url实现权限功能，使我在以后的学习中能够更加容易的掌握Apapche Shiro以及Spring Security安全框架。项目的简单灵活的架构设计，为我打下了项目架构设计的基础。 项目名称：CRM（客户关系管理系统）开发环境：window 7，Oracle，Tomcat6，jdk1.6开发工具：Eclipse JavaEE项目描述：CRM系统作为亚信科技（中国）上海分公司的主要项目，是一款上海移动用户定制业务系统，功能齐全，系统庞大，并且与多个外平台交互。系统强健的功能为业务处理提供全程支撑和监控，实现了业务处理的实时计费，实时监控、实时优惠、实时帐务、实时信息查询和实时处理等多项功能，高效的支撑了业务运营。项目职责：本人负责CRM个人新业务工单的开发，在实习期间，主要完成了一下工作：1、完成CRM短信模板配置界面功能的开发（已上线）。 2、使用Appframe框架提供的批量导入框架（BP）实现了客户投诉信息的批量导入，使用类似于POI的工具解析并处理了Excel数据。 3、梳理CRM系统产品缓存策略，阅读Appframe实现memcached客户端的源码，并对其进行优化。 4、开发扫描客户信息的后台实时处理进程，基本熟悉实时任务和定时任务。项目相关技术：Appframe，Javascript，Ajax收获：CRM系统作为为上海移动服务的主打产品，其中灵活多变的业务逻辑，使我在以后的工作中能够更加容易的理解复杂的业务需求，在掌握技术的前提下能够快速针对需求而做出最有效的实现。虽然整个系统庞大而复杂的业务让开发人员理解困难，但是其各种有效的数据库设计也为我在之后个人独立项目中提供了更多的数据库表的设计灵感。 项目名称：产商品项目开发环境：window 7，Oracle，Tomcat7，jdk1.7开发工具：Intellij Idea项目描述：本项目为产商品中心项目，主要分为读和写两部分。第一部分为服务的开发（既读的部分），服务的开发是在原crm系统服务的基础上，使用SpringBoot+Redis对原有服务进行优化改造；第二部分为配置化项目（既写的部分），主要针对中国移动的各种套餐、活动的配置，采用敏捷开发模式，使用配置化开发方式开发出各种套餐活动的配置化界面。项目职责：1、在开发服务的过程中，除过对普通的服务进行改造优化外，本人在项目经理的要求下，完成了组合产品定价服务，为移动商城提供服务支持，其功能类似于淘宝天猫等商城中，不同商品组合购买，可以打不同的折扣。 2、在配置化开发部分，主要是采用配置与代码协作开发方式，和同伴一起完成套餐、活动配置模板的开发，并在后期带领实习生完成基本配置工作的入门学习。 项目相关技术：Spring Boot，Redis，JQuery，Ajax，JSON（Java，JS）收获：使我能够熟练使用Spring Boot框架的同时，也使我掌握了查询优化（Java和Oracle）的基本思想，CRM远程调用产品中心接口的改造，也让我基本掌握了通过http协议调用远程接口的方式，同时，项目中，大量JSON数据的处理，也让我能够熟练的利用JSON工具处理JSON类型的数据。 教育经历 2012.9-2016.6 甘肃农业大学 信息管理与信息系统专业2015.7-2015.11 上海杰普科技有限公司 培训JavaEE开发 技术经历 2013.10月开始自学Java方面相关知识2015.9-2016.3，使用SSH框架完成OA系统的开发，同时作为毕设作品2016.12，参考MyBatis的Mapper配置文件，对Spring自身提供的访问数据库的JdbcTemplate进行封装，主要针对JdbcTemplate的自定义SQL进行封装，设计并开发出一个通用的数据容器，用来存储查询结果，并且配置文件具有热加载功能，最后将其做成Spring Boot的一个Starter POM模块。 在校荣誉 2014年10月 甘肃农业大学计算机技能大赛(设计类)一等奖 校级2014年12月 第六届蓝桥杯全国软件大赛甘肃赛区C语言软件开发三等奖 国家级","permalink":"/2017/02/09/个人简历/","tags":[{"name":"个人简历","slug":"个人简历","permalink":"/tags/个人简历/"}]},{"title":"封装JdbcTemplate的自定义SQL","date":"2017-02-07T14:46:56.000Z","path":"2017/02/07/封装JdbcTemplate的自定义SQL/","text":"本博文为博主原创，转载请注明出处！ 封装思路说明：对JdbcTemplate自定义SQL的封装，主要是参考MyBatis来进行的，但又与MyBatis有很大的区别，主要是针对RowMapper接口进行处理，构造一个统一的数据容器来继承并实现RowMapper接口。通过Dom4j解析自定义SQL的XML配置文件，根据自定义SQL的标识code获取对应的SQL。使用JdbcTemplate或者封装的JdbcClient工具类进行查询等操作，查询出的结果封装到数据容器中。 代码路径为：https://github.com/ArtIsLong/JdbcTemplatePackaging.git 博主对JdbcTemplate封装的步骤：一、封装读取XML的工具类（使用Dom4j实现） 多的不说，先上代码，通过代码解释实现思路。 123456789101112131415161718192021222324252627282930313233public String getSQLByClass(String className, String methodName) &#123; String fileName = DynamicConsts.MAPPER_URL_PREFIX + properties.getUrl() + className + DynamicConsts.PARSE_XML_SUFFEX; --1-- Element root = null; Document documentText = null; SAXReader reader = new SAXReader(); String sql = null; try &#123; isReLoad = StringUtils.isEmpty(properties.getIsReLoad()) ? defaultIsReLoad : properties.getIsReLoad(); --2-- if(\"true\".equals(isReLoad)) &#123; documentText = reader.read(new File(fileName)); &#125; else &#123; --3-- if(docCache.isEmpty() || docCache.get(fileName) == null) &#123; documentText = reader.read(new File(fileName)); docCache.put(fileName, documentText); &#125; else &#123; documentText = docCache.get(fileName); &#125; &#125; root = documentText.getRootElement(); Iterator it = root.elementIterator(); while(it.hasNext()) &#123; Element next = (Element) it.next(); Attribute attribute = next.attribute(\"id\"); if(methodName.equals(attribute.getValue())) &#123; --4-- sql = String.valueOf(next.getData()); &#125; &#125; &#125; catch (DocumentException e) &#123; e.printStackTrace(); log.error(\"获取SQL失败，错误信息:\" + e.getMessage()); &#125; return sql; &#125; 说明：1：读取XML配置文件全路径，配置主要有XML配置文件在工程中的包路径，配置文件固定后缀2：读取配置使用重新加载配置文件的配置，配置值为true或false3：通过2的配置，来判断XML配置文件修改之后是否需要重新加载；代码思路为，如果isReLoad为true，则程序每次访问，都会去加载XML配置文件，如果为false，则第一次加载之后会将XML配置文件放到内存中，下次访问直接从内存中获取（isReload默认为false，在开发阶段建议设为true）4：根据自定义SQL的标识code获取SQL（标识code建议和DAO方法名一致） 二、封装统一的数据容器实现思路：实现RowMapper接口的mapRow方法，遍历ResultSet里的数据，将其存到Map里，其中key默认为表的列名，","permalink":"/2017/02/07/封装JdbcTemplate的自定义SQL/","tags":[{"name":"jdbcTemplate","slug":"jdbcTemplate","permalink":"/tags/jdbcTemplate/"}]},{"title":"nginx+tomcat+redis实现session共享","date":"2017-01-27T04:48:26.000Z","path":"2017/01/27/nginx-tomcat-redis实现session共享/","text":"本文是基于window系统实现。 1、软件准备","permalink":"/2017/01/27/nginx-tomcat-redis实现session共享/","tags":[{"name":"session共享","slug":"session共享","permalink":"/tags/session共享/"}]},{"title":"js工具库","date":"2016-12-22T14:14:08.000Z","path":"2016/12/22/js工具库/","text":"1、时间格式的校验1）校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间1234567891011121314151617/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsDateTime(obj, msg) &#123; //var str = \"2016-04-15 00:00:00\"; if(obj.value != \"\")&#123; var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;) (\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;)$/; var r = str.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); obj.value=\"\"; return false; &#125; &#125;&#125; 2）判断日期类型是否为yyyy-MM-dd格式的类型123456789101112131415/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsDate(obj,msg) &#123; //var str = \"2016-04-15\"; if(obj.value != \"\")&#123; var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; var r = obj.value.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); &#125; &#125;&#125; 3）判断日期类型是否为hh:mm:ss格式的类型123456789101112131415/** * 校验时间格式是否是yyyy-MM-dd HH:mm:ss格式的时间 * @param obj 输入框对象 * @param msg 错误信息 */function checkIsTime(obj,msg) &#123; //var str = \"16:13:69\"; if(obj.value != \"\")&#123; var reg = /^((20|21|22|23|[0-1]\\d)\\:[0-5][0-9])(\\:[0-5][0-9])?$/; var r = obj.value.match(reg); if(r==null) &#123; $.showErrorMessage(\"校验失败\",msg); &#125; &#125;&#125; 4）","permalink":"/2016/12/22/js工具库/","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"java基本数据类型缓存解析","date":"2016-12-21T16:46:28.000Z","path":"2016/12/22/java基本数据类型缓存解析/","text":"基本类型缓存解析一、Integer缓存解析：123456789101112131415161718192021222324252627282930private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low)); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 1、使用自动装箱（Integer i = 1）方式创建Integer对象时，会使用valueOf进行Integer对象的初始化，此时，会调用IntegerCache.high，这是需要对IntegerCache这个静态内部类进行初始化。2、IntegerCache类中有一个cache数组，在加载IntegerCache的时候，会将-128到127的Integer对象都创建了，并存到cache数组中，然后在判断当前初始化的Integer对象的值是否在-128到127之间，如果是，就直接从cache缓存中取，如果不存在，则new一个新的Integer对象。3、之后再使用自动装箱的方式创建Integer对象时，值在-128到127之间时会直接从cache缓存中取。 所以，使用自动装箱的方式创建的Integer对象，两者进行比较时，只要其值相等就是ture。而不在-128到127之间的，比较时会新new一个对象，而导致比较结果为false注意：Integer的最低值是固定的，只能是-128，而最高值是可以通过jvm参数设置的。在执行java程序的时候加上-XX:AutoBoxCacheMax=参数即可。 二、Long及Byte、Character缓存解析12345678910111213141516private static class LongCache &#123; private LongCache()&#123;&#125; static final Long cache[] = new Long[-(-128) + 127 + 1]; static &#123; for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); &#125;&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; Long的缓存机制（LongCache）与Integer的类似，还有Character（CharacterCache），Byte（ByteCache）的缓存机制也是类似。不过只有Integer的最大值可以通过jvm参数设置，其他的都固定的。其中，Byte，Short，Long 的范围： -128 到 127；Character, 范围是 0 到 127。","permalink":"/2016/12/22/java基本数据类型缓存解析/","tags":[{"name":"java缓存","slug":"java缓存","permalink":"/tags/java缓存/"}]},{"title":"maven配置","date":"2016-12-21T16:43:01.000Z","path":"2016/12/22/maven配置/","text":"maven打包加载src/main/java中的配置文件 maven打jar包时，不能识别src/main/java中的配置文件(.xml,.properties)，需要在build中添加以下配置： 123456789101112131415161718192021&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java/&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- 是否替换资源中的属性 --&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; --&gt; &lt;/resource&gt;&lt;/resources&gt;","permalink":"/2016/12/22/maven配置/","tags":[{"name":"maven","slug":"maven","permalink":"/tags/maven/"}]},{"title":"zookeeper集群部署(单机版)","date":"2016-12-19T16:05:59.000Z","path":"2016/12/20/zookeeper集群部署-单机版/","text":"本文是在机器已经配置好java开发环境的基础上完成的。 软件准备Zookeeper最新版本是3.4.6，笔者使用zookeeper-3.4.5-cdh5.3.6.tar.gz完成集群的搭建。Zk的其他版本下载地址：http://www.apache.org/dist/zookeeper/将下载好的zookeeper解压，建议重命名为zookeeper-3.4.5-1，并且拷贝出相同的两份，分别命名为zookeeper-3.4.5-2，zookeeper-3.4.5-3。 然后在适当的目录下新建一个存放zookeeper数据的目录，笔者新建了devtools目录，在devtools目录中新建zookeeper-1目录，在其中增加data目录和log目录（这两个目录的作用在后面会做说明）；然后将zookeeper-1目录拷贝出两份，分别命名为zookeeper-2，zookeeper-3。笔者目录结构为： 到此，软件和环境准备工作已经做好，接下来就需要对zookeeper的相关配置文件做修改了。 集群配置新下载的Zookeeper，conf目录下有configuration.xsl，log4j.properties，zoo_sample.cfg三个配置文件，我们需要将zoo_sample.cfg复制一份，命名为zoo.cfg，因为zookeeper启动的时候会读取zoo.cfg文件的配置信息。zoo.cfg文件中有几项参数，主要解释一下三项参数：tickTime=2000 基本事件单元，以毫秒为单位。它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。clientPort=2181 监听客户端连接的端口。dataDir=/tmp/zookeeper zookeeper默认存放数据的目录 接下来我们需要修改zoo.cfg中的配置信息。在zoo.cfg中增加这两项配置： 12dataDir=F:/hadoop/tools/devtools/zookeeper-1/datadataLogDir=F:/hadoop/tools/devtools/zookeeper-1/log 这都是我们之前新建的目录，dataDir前面已经作过说明，dataLogDir是zookeeper存放日志文件的目录，如果不配置dataLogDir，日志文件默认存放到dataDir中。 然后配置zk进程（server.x=ip:clientPort:zkReqPort）： 123server.1=localhost:2287:3387 server.2=localhost:2288:3388server.3=localhost:2289:3389 server.x中的“x”表示ZooKeeper Server进程的标识，同一个ZooKeeper集群内的ZooKeeper Server进程间的通信不仅可以使用具体的点IP地址，也可以使用组播地址。 clientPort 表示监听Client端请求的端口号 zkReqPort 表示监听同ZooKeeper集群内其他ZooKeeper Server进程通信请求的端口号因为笔者是在同一台机器上作伪集群的搭建，所以各个zookeeper的ip相同，保证每个zk进程的监听端口错开就可以了，如果是在不同机器上，则不需要。以上配置已经完成了集群99%的搭建工作。 此时需要在每个zookeeper-1/data目录中新建myid文件，文件内容为1，然后在zookeeper-2/data，zookeeper-3/data目录中也同样新建myid文件，内容分别为2和3。1,2,3分别对应server.x中的x，表示zookeeper进程的进程标识。如果不配置zookeeper的进程标识，zk集群将不能找到自己所对应的进程。因此，之前99%的工作也不如此处1%的重要。自此，入门级集群的搭建基本完成。 集群测试首先启动zk集群，windows下直接运行三个zookeeper服务器的zkServer.cmd即可。在启动第一个zookeeper的时候会出现以下错误信息： 这些错误信息不要害怕，因为集群其他进程没启动，检查线程没有找到其他的服务器节点。在启动第二个zookeeper服务器之后就正常了。 启动成功之后就需要我们通过java代码去测试集群是否可用。 新建一个maven工程，在pom.xml文件中添加一下依赖信息： 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; Zkclient是github上一个开源的java zk客户端。编写测试代码 12345678@Testpublic void testZkClient() &#123; ZkClient zkClient = new ZkClient(\"localhost:2181,localhost:2182,localhost:2183\"); String node = \"/zookeeper-3.4.5-1\"; if (zkClient.exists(node)) &#123; System.out.println(node); &#125;&#125; zkClient.exists(node) 检测zookeeper-3.4.5-1 是否存在 zookeeper集群的搭建及测试完成，在Linux下搭建伪集群和不同机器下搭建集群方式基本相同。笔者建议后来者可先在windows环境下搭建，windows的可视化界面效果能够为初学者减少很多出错的地方。","permalink":"/2016/12/20/zookeeper集群部署-单机版/","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"/tags/zookeeper/"}]},{"title":"Spring Boot核心","date":"2016-12-18T12:26:36.000Z","path":"2016/12/18/Spring-Boot核心/","text":"一、Spring Boot基本配置 1、入口类和@SpringBootApplicationSpring Boot通常有一个名为*Application的入口类，入口类中有一个main方法，这个main方法其实就是一个标准的Java应用程序的入口方法。在main方法中使用SpringApplication.run(Chapter01Application.class, args),启动Spring Boot应用项目。 2、关闭特定的自动配置通过@SpringBootApplication源码可以看出，关闭特定的自动配置应该使用@SpringBootApplication注解的exclude参数，例如:@SpringBootApplication(exclude={DataSourceAutoConfiguration.class}) 3、定制Banner在Spring Boot启动的时候会有一个默认启动图案，这个图案是可以自定义的。1）我们在src/main/resources下新建一个banner.txt2）通过http://patorjk.com/software/taag网站生成字符，将生成的字符复制到banner.txt文件中3）自动程序，这时控制台图案将变成刚才生成的图案 4、关闭banner在main方法中修改为(Spring Boot:1.4.0)： 123SpringApplication application = new SpringApplication(Chapter1Application.class); application.setBannerMode(Mode.OFF); application.run(args); 或者 123new SpringApplicationBuilder(Chapter1Application.class) // .bannerMode(Mode.OFF) // .run(args); 5、Spring Boot配置文件Spring Boot使用一个全局的配置文件application.properties或application.yml，放置在src/main/resources目录或者类路径的/config下。Spring Boot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。Spring Boot的全局配置文件的作用是对一些默认配置值进行修改。例如：修改tomcat端口为8080-&gt;8888，默认的访问路径为”/“-&gt;”/helloboot”。可以在application.properties中添加： 12server.port=9090 server.context-path=/helloBoot 6、官方starter pomspring-boot-starter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持spring-boot-starter-actuator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 准生产特性，用来监控和管理应用spring-boot-starter-remote-shell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供基于ssh协议的监控和管理spring-boot-starter-amqp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-rabbit来支持AMQPspring-boot-starter-aop &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用spring-aop和AspectJ支持面向切面变成spring-boot-starter-batch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Batch的支持spring-boot-starter-cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Spring Cache抽象的支持spring-boot-starter-cloud-connectors &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对云平台（Cloud Foundry，Heroku）提供的服务提供简化的连接方法spring-boot-starter-data-elasticsearch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-elasticsearch对Elasticsearch的支持spring-boot-starter-data-gemfire &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-gemfire对分布式存储GenFile的支持spring-boot-starter-data-jpa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JPA的支持，包含spring-data-jpa，spring-orm和Hibernatespring-boot-starter-data-mongodb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-mongodb，对MongoDB进行支持spring-boot-starter-data-rest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-rest-webmvc将Spring Data Repository暴露REST形式的服务spring-boot-starter-data-solr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-data-solr对Apache Solr数据检索平台的支持spring-boot-starter-freemarker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对FreeMarker模板引擎的支持spring-boot-starter-groovy-templates &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Groovy模板引擎的支持spring-boot-starter-hateoas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-hateoas 通过spring-hateoas对基于HATEOAS的REST形式的网络服务的支持spring-boot-starter-hornetq &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过HornetQ对JMS的支持spring-boot-starter-integration &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对系统集成框架spring-integration的支持spring-boot-starter-jdbc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对JDBC数据库的支持spring-boot-starter-jersey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Jersery REST形式的网络服务的支持spring-boot-starter-jta-atomikos &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Atomikos对分布式事务的支持spring-boot-starter-jta-bitronix &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Bitronix对分布式事务的支持spring-boot-starter-mail &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对javax.mail的支持spring-boot-starter-mobile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-mobile的支持spring-boot-starter-mustache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Mustache模板引擎的支持spring-boot-starter-redis &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对键值对内存数据库Redis的支持，包含spring-reidsspring-boot-starter-security &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对spring-security的支持spring-boot-starter-social-faceboot &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-faceboot对Facebook的支持spring-boot-starter-social-twitter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过spring-social-twitter对Twitter的支持spring-boot-starter-test &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对常用的测试框架Junit，Hamcrest和Mockito的支持，包含spring-test模板spring-boot-starter-thymeleaf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Thymeleaf模板引擎的支持，包含于Spring整合的配置spring-boot-starter-velocity &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Velocity模板引擎的支持spring-boot-starter-web &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对Web项目开发的支持，包含Tomcat和spring-webmvcspring-boot-starter-Tomcat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的Servlet容器Tomcatspring-boot-starter-Jetty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Jetty作为Servlet容器替换Tomcatspring-boot-starter-undertow &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用Undertow作为Servlet容器替换Tomcatspring-boot-starter-logging &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Spring Boot默认的日志框架Logbackspring-boot-starter-log4j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 支持使用Log4j日志框架spring-boot-starter-websocket &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对WebSocket开发的支持spring-boot-starter-ws &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Spring Web Services的支持 还有第三方为Spring Boot所写的starter pom,这里不做介绍 7、使用xml配置Spring Boot提倡零配置，即无xml配置，但是在实际项目中，可能有些特殊要求，使得开发者必须使用xml配置，这时我们可以通过Spring提供的@ImportResource来加载xml配置，例如： 1@ImportResource(&#123;\"classpath:context.xml”&#125;) 8、命令行参数配置Spring Boot可以是基于jar包运行的，打成jar包的程序可以直接通过java -jar xx.jar来运行可以通过java -jar xx.jar —server.port=8888来修改Tomcat端口号 9、常规属性配置在常规Spring环境下，注入properties文件里的值得方式，通过@PropertySource指明properties文件的位置，然后通过@Value注入值。在Spring Boot里，只需要在application.properties定义属性，直接使用@Value注入即可。例如：在application.properties文件中添加属性： 12book.author=cmbook.name=spring boot 在com.gnd.springboot.config.init路径下新建PropertiesTests属性配置类，使用@Value注入book属性 12345678910111213141516171819@Componentpublic class PropertiesTests &#123; @Value(\"book.author\") private String author; @Value(\"book.name\") private String name; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 10、类型安全的配置（基于properties）Spring Boot提供了基于类型安全的配置方式，通过@ConfigurationProperties将properties属性和一个Bean及其属性关联，从而实现类型安全的配置。所以，常规属性配置可以修改为： 123456789101112131415161718@Component@ConfigurationProperties(prefix = \"book\")public class PropertiesTests &#123; private String author; private String name; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 11、日志配置Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，无论使用哪种日志框架，Spring Boot已为当前使用日志框架的控制台输出及文件输出做好了配置。默认情况下，Spring Boot使用Logback作为日志框架。日志级别:logging.file=/home/cm/mylog.log配置日志文件，格式为logging.level.包名=级别：logging.level.org.springframework.web=DEBUG 12、Profile配置Profile是Spring用来针对不同的环境对不同的配置提供支持的，全局Profile配置使用application-{profile}.properties(如application-prod.properties),通过在application.properties中设置spring.profiles.active=prod来指定活动的Profile例如：我们分为生产(prod)和开发(dev)环境，在生产环境下端口号为80，开发环境为8888。两种配置文件分别为： 12application-prod.properties: server.port=80application-dev.properties: server.port=8888 然后在application.properties增加： 1spring.profiles.active=dev(prod) 通过Profile可以灵活切换Spring Boot项目的配置了。 二、Spring Boot运行原理Spring Boot关于自动配置的源码在spring-boot-autoconfigure-1.4.0.RELEASE.jar内，主要包含了以下配置：若想知道Spring Boot为我们做了哪些自动配置，可以通过通过三种方式查看以启用和未启用的自动配置的报告：1）运行jar时增加—debug参数：java -jar xx.jar —debug2)在application.properties中设置属性：debug=true（这个方便点）3）在开发工具启动参数中配置 1、Spring Boot运行原理解析： 对@SpringBootApplication注解说明： @SpringBootApplication是一个组合注解，它的核心功能是由@EnableAutoConfiguration注解提供的。查看@EnableAutoConfiguration源码这里@Import注解导入配置功能，EnableAutoConfigurationImportSelector使用SpringFactoriesLoader.loadFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包，而spring-boot-autoconfigure-1.4.0.RELEASE.jar里就有一个spring.factories文件，次问价中声明了有哪些自动配置。 任意打开一个AutoConfiguration文件，一般都有以下条件注解，在spring-boot-autoconfigure-1.4.0.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下，条件注解如下： @ConditionalOnBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里有指定的Bean的条件下 @ConditionalOnClass: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下有指定的类的条件下 @ConditionalOnExpression： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于SpEL表达式作为判断条件 @ConditionalOnJava： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于JVM版本作为判断条件 @ConditionalOnJndi： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在JNDI存在的条件下查找指定的位置 @ConditionalOnMissingBean： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当容器里没有指定Bean的情况下 @ConditionalOnMissingClass： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当类路径下没有指定的类的条件下 @ConditionalOnNotWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目不是Web项目的条件下 @ConditionalOnProperty： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定的属性是否有指定的值 @ConditionalOnResource： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类路径是否有指定的值 @ConditionalOnSingleCandidate： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当指定Bean在容器中只有一个，或者虽然有多个但是指定首选的Bean @ConditionalOnWebApplication： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前项目是Web项目的条件下这些注解都是使用了@Conditional元注解，不过是使用了不同的条件而已。 2、分析http的编码配置配置参数 HttpEncodingProperties的源码如下：这里的配置类可以直接在application.properties中以spring.http.encoding 为前缀配置，比如：如果需要修改默认编码方式，可通过spring.http.encoding.charset=gbk 配置。根据条件配置CharacterEncodingFilter的Bean，源码如下: 3、自定义自动配置（包装成starter pom）1）新建maven工程spring-boot-starter-hello，在pom.xml中添加如下配置: 12345678910111213141516&lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2) 新建属性配置类HellpServiceProperties 1234567891011@ConfigurationProperties(prefix = \"hello\")public class HelloServiceProperties &#123; private static final String MSG = \"world\"; private String msg = MSG; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 此种配置方式为类型安全的属性获取。在application.properties中通过hello.msg= 来设置，若不设置，默认为hello.msg=world 3）新建依据类HelloService（此类可以是第三方类库的类） 123456789101112public class HelloService &#123; private String msg; public String sayHello() &#123; return \"Hello \" + msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 4）新建自动配置类 123456789101112131415@Configuration@EnableConfigurationProperties(HelloServiceProperties.class)@ConditionalOnClass(HelloService.class)@ConditionalOnProperty(prefix = \"hello\", value = \"enabled\", matchIfMissing = true)public class HelloServiceAutoConfiguration &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean @ConditionalOnMissingBean(HelloService.class) public HelloService helloService() &#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 根据HelloServiceProperties提供的参数，并通过@ConditionalOnClass来判断HelloService这个类在类路径中是否存在，且当这个容器中没有这个Bean的情况下自动配置这个Bean。5）注册自动配置在src/main/resources中新建META-INF/spring.factories文件，内容为 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.gnd.springboot.config.HelloServiceAutoConfiguration&lt;br&gt; 其中“\\”是为了在换行之后仍能读到属性，若有多个自动配置，以“,”分隔6）测试自定义自动配置新建一个maven web工程，添加如下依赖: 12345678910111213141516&lt;properties&gt; &lt;spring-framework.version&gt;1.4.0.RELEASE&lt;/spring-framework.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;spring-boot-starter-hello&lt;/groupId&gt; &lt;artifactId&gt;com.gnd.springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-hello为之前新建的自定义自动配置starter pom新建测试启动类 12345678910111213@RestController@SpringBootApplicationpublic class Chapter11Application &#123; @Autowired private HelloService helloService; @RequestMapping(\"/test\") public String index() &#123; return helloService.sayHello(); &#125; public static void main(String[] args)&#123; SpringApplication.run(Chapter11Application.class, args); &#125;&#125; 运行测试工程之后，浏览器输入”http://localhost:8080/test“测试，测试结果如下:新建application.properties配置文件，内容为 1hello.msg=haha 重启工程，浏览器输入”http://localhost:8080/test“测试，测试结果如下:","permalink":"/2016/12/18/Spring-Boot核心/","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/tags/Spring-Boot/"}]},{"title":"jdk各版本区别","date":"2016-12-17T16:06:43.000Z","path":"2016/12/18/jdk各版本区别/","text":"jdk5新特性1、自动装箱和拆箱2、枚举3、静态导入4、可变参数5、內省 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。 一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 6、泛型7、For-Each循环jdk6新特性1、Desktop类和SystemTray类 AWT新增加了两个雷：Desktop，SystemTray。 Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档 SystemTray可以用来在系统托盘区创建一个托盘程序 2、使用JAXB2来实现对象与XML之间的映射 也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。 3、StAX StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4、使用Compiler API 使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。 5、轻量级Http Server API6、插入式注解处理API7、用Console开发控制台程序8、对脚本语言的支持如：ruby，groovy，javascript9、Common Annotationsjdk7新特性1、switch中可以使用字符串2、泛型的自动判断3、自定义自动关闭类（实现AutoCloseable接口）4、新增一些取环境信息的工具方法（System中的方法）5、Boolean类型反转，空指针安全，参数与位运算6、两个char间的equals7、安全的加减乘除1、对Java集合（Collections）的增强支持12345List&lt;String&gt; list=[\"item\"]; //向List集合中添加元素String item=list[0]; //从List集合中获取元素Set&lt;String&gt; set=&#123;\"item\"&#125;; //向Set集合对象中添加元Map&lt;String,Integer&gt; map=&#123;\"key\":1&#125;; //向Map集合中添加对象int value=map[\"key\"]; //从Map集合中获取对象 但是经过自己测试，按照上面的使用方法，并不能创建集合。 2、int支持二进制数据3、在try catch异常捕捉中，一个catch可以写多个异常类型1234567Connection conn = null;try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"\",\"\",\"\");&#125; catch(ClassNotFoundException|SQLException ex) &#123; ex.printStackTrace();&#125; 4、try catch中资源定义好之后try catch自动关闭12345678910try (BufferedReader in = new BufferedReader(new FileReader(\"in.txt\")); BufferedWriter out = new BufferedWriter(new FileWriter(\"out.txt\"))) &#123; int charRead; while ((charRead = in.read()) != -1) &#123; System.out.printf(\"%c \", (char)charRead); out.write(charRead); &#125;&#125; catch (IOException ex) &#123; ex.printStackTrace();&#125; jdk8新特性1、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下： 123456public interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678 Formula formula = new Formula() &#123;@Overridepublic double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常 2、Lambda表达式1234567List&lt;String&gt; names = Arrays.asList(\"tom\",\"jace\",\"mike\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125;&#125;); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。在Java 8中提供了更简洁的语法，lambda表达式： 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 还可以更简洁： 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 去掉大括号以及return关键字 1Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。 3、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@FunctionalInterface注解标注的接口只能有一个抽象方法。例如： 1234567@FunctionalInterfacepublic interface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); 以上代码不需要@FunctionalInterface注解也是正确的。 4、方法与构造函数引用上面的代码也可以通过静态方法引用来表示： 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 12345678910public class Person &#123; String firstName; String lastName; Person() &#123; &#125; public Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 指定一个用来创建Person对象的对象工厂接口： 123public interface PersonFactory&lt;P extends Person&gt; &#123; P create(String fisrtName, String lastName);&#125; 创建Person对象 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(\"Peter\",\"Parker”); 我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5、Lambda作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6、访问局部变量我们可以直接在lambda表达式中访问外层的局部变量 123final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。 7、访问对象字段与静态变量和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： 123456789101112static int outerStaticNum;int outerNum;public void testScopes() &#123; Converter stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;;&#125; 8、访问接口的默认方法9、Date API10、Annotation注解","permalink":"/2016/12/18/jdk各版本区别/","tags":[{"name":"jdk版本","slug":"jdk版本","permalink":"/tags/jdk版本/"}]},{"title":"Spring Boot入门","date":"2016-12-13T15:18:29.000Z","path":"2016/12/13/Spring-Boot入门/","text":"一、Spring Boot简介 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式使得开发人员使用Spring开发极大的简便了配置过程，基本上实现了零配置。 Spring Boot有以下几个优点： 1、 没有代码生成，不需要XML配置文件 2、 内嵌Tomcat，Jetty或者Undertow服务器，不需要额外部署web工程到Servlet容器 3、 可以独立运行Spring应用程序 4、 提供了Maven，Gradle两种方法搭建Spring Boot工程 5、 无缝整合其他开源框架（只需要添加开源框架的依赖包，Spring Boot自动完成整合） 6、 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查 二、Spring Boot入门工程搭建：1、采用Spring官网提供的SPRING INITIALIZR进行搭建。可以选择Maven Project或者Gradle Project来搭建，然后选择Spring Boot版本，输入Group，Artifact，以及需要的依赖包，然后点击Generate Project，会生成一个Artifact.zip压缩包，将Artifact工程导入常用的开发工具即可。 2、使用开发工具手动构建Spring Boot工程（本文采用Intellij Idea 2016.3）1、新建一个Maven的web工程2、在pom.xml文件中添加Spring Boot的相关依赖 添加父级依赖，这样当前的项目就是Spring Boot项目了。spring-boot-starter-parent是一个特殊的starer，它用来提供相关的maven默认依赖，使用它之后，当前项目的的常用依赖包就可以省去version标签。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 添加spring-boot-starter依赖，spring-boot-starter是Spring Boot核心starter，包含自动配置、日志、yaml配置文件的支持。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 然后在dependencies中添加Web支持的starter pom。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web会自动添加它所依赖的jar包 然后添加Spring Boot的编译插件，便于使用Spring Boot命令操作工程 12345678910 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;``` ### 3、简单测试 新建包路径com.gnd.chapter01，在com.gnd.chapter01包路径下新建Chapter01Application.java入口类，编写入口方法 @SpringBootApplication public class Chapter01Application { public static void main(String[] args){ SpringApplication.run(Chapter01Application.class, args); } } 12345***注***：**@SpringBootApplication**是一个组合注解，查看其源码，**@SpringBootApplication**组合了**@SpringBootConfiguration**，**@EnableAutoConfiguration**，**@ComponentScan**三个注解，**@SpringBootConfiguration**表示当前类是一个启动应用程序的入口；**@EnableAutoConfiguration**注解开启自动配置，让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置(例如:添加了spring-boot-starter-web依赖，会自动添加tomcat和SpringMVC的依赖)；@ComponentScan会以Application入口类所在目录为根目录，自动扫描工程中标注了**@Component**注解的类。&lt;a href=\"http://i1.piimg.com/4851/5c5bb70a10d94825.png\" title=\"点击显示原始图片\"&gt;&lt;img src=\"http://i1.piimg.com/4851/5c5bb70a10d94825t.jpg\"&gt;&lt;/a&gt; 然后新建目录controller，在其中新建一个HelloController测试类。 @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String index() { return &quot;Hello, World!&quot;; } } ```@RestController也是一个组合注解，组合了@Controller，@ResponseBody两个注解 4、运行 使用Spring Boot命令运行工程，mvn spring-boot:run，或者直接运行Chapter01Application类，在浏览器中访问http://localhost:8080/hello即可访问HelloController，访问结果如下：","permalink":"/2016/12/13/Spring-Boot入门/","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/tags/Spring-Boot/"}]}]